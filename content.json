{"meta":{"title":"崎径 其镜","subtitle":"求学道路上的行车记录仪","description":null,"author":"Anqi Zhao","url":"http://www.z16388.top"},"pages":[{"title":"","date":"2018-01-17T15:02:10.651Z","updated":"2018-01-17T15:02:10.651Z","comments":true,"path":"README.html","permalink":"http://www.z16388.top/README.html","excerpt":"","text":"blogsource我的博客，欢迎光临 http://z16388.top"},{"title":"","date":"2019-11-13T01:31:46.135Z","updated":"2017-04-13T13:25:20.476Z","comments":true,"path":"baidu_verify_bJsKt9rMJw.html","permalink":"http://www.z16388.top/baidu_verify_bJsKt9rMJw.html","excerpt":"","text":"bJsKt9rMJw"},{"title":"","date":"2017-04-13T13:25:20.983Z","updated":"2017-04-13T13:25:20.983Z","comments":true,"path":"7d0a5d56bfd911bf552ed1753dc23c1f.html","permalink":"http://www.z16388.top/7d0a5d56bfd911bf552ed1753dc23c1f.html","excerpt":"","text":"7d0a5d56bfd911bf552ed1753dc23c1f"},{"title":"XML解释器的实现","date":"2018-03-19T08:42:20.000Z","updated":"2018-03-20T05:57:49.256Z","comments":true,"path":"xmlparser.html","permalink":"http://www.z16388.top/xmlparser.html","excerpt":"","text":"引言&emsp;&emsp;拿到题目的第一时间是有点慌的。虽然知道怎么去写，一来这两天是满课，时间比较少，再者我也是好久没有进行过类似的编码了，可能会有些生疏。题目内容如下： XML分析实现一个xml的解析器通过文件流读取资源进行逐字符判断实现对XML的解析最终结果保存在一个多层的树状数据结构中如map或Dictionary中XML样例： 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;node1&gt; &lt;name&gt;字符串&lt;/name&gt; &lt;type&gt;string&lt;/type&gt; &lt;dec&gt;字符数组管理类&lt;/dec&gt; &lt;body&gt;这是一个需要被解析的XML方案&lt;/body&gt;&lt;/node1&gt;&lt;node2&gt; &lt;name&gt;结构体&lt;/name&gt; &lt;type&gt;struct&lt;/type&gt; &lt;dec&gt;自定义结构体&lt;/dec&gt; &lt;body&gt; &lt;node1&gt; &lt;name&gt;字符串&lt;/name&gt; &lt;type&gt;string&lt;/type&gt; &lt;dec&gt;字符数组管理类&lt;/dec&gt; &lt;body&gt;这是一个深层次的字符串&lt;/body&gt; &lt;/node1&gt; &lt;/body&gt;&lt;/node2&gt; 要求 不能用语言自带的xml解析库或者第三方库使用文件流对资源进行读取 代码规范易懂 保存为控制台项目 &emsp;&emsp;题目要求实现一个XML解析器，通过文件流逐字读取实现对XML的解析，最终结果保存在一个多层的树状数据结构中。 &emsp;&emsp;在此之前我是接触过XML的。之前做过安卓和QT，他们都是使用来XML写布局的，所以对大致的状况有所了解。从题目中所给的样例来看，处理嵌套的标签是不可避免的。但是，可以看到标签只是单纯的标签，内部并没有属性。本来想问一下面试官是否要实现对属性的解析，但是又看了以下题目的要求。使用map即可，既然不用自建数据结构，那么肯定不需要处理属性了。之所以使用map，是因为我在ACM的比赛中使用过这个结构。刚好C++的STL标准模板库中有这个功能，不需要我们对这个数据结构进行单独实现。确定好了编码内容，下面对程序的结构进行设计。 结构设计&emsp;&emsp;要实现对XML的解析，这个程序要分成以下3个步骤： 文件读取 内容检查 在控制台中显示 &emsp;&emsp;文件读取部分较为简单。 &emsp;&emsp;内容检查。这道题中要处理的内容为XML的标签和标签中的信息。对于标签，需要保证&lt;和&gt;是成对出现的。虽然XML中，标签分为单标签和成对的双标签，但是这里不考虑标签内部的属性，只考虑标签和内容，因此只考虑双标签的情况。 &emsp;&emsp;到这里，整个程序的思路就已经出来了：逐字读取，读取到&lt;时，把后面的内容存作为一个字符串进行压栈。然后遇到成对的另一个标签时，就是&lt;/开头的内容，对标签进行验证。如果存在栈顶的标签和这个标签不同，那么说明这个标签中没有存储内容，看栈里有几个元素，就说明它是第几级标签，直接作为标签输出；如果是相同的，说明这是这个XML文件树形结构的一个叶子结点。将它的标签，以及中间的内容存放在一个map的数组中。继续往后读取，直到遇到它的上一级标签，输出所有存放的内容，栈中存放的上级标签出栈。 实现文件读取&emsp;&emsp;这是解决问题的第一步。但是在这里，我花了好多的时间。各种编译器和语言都进行了尝试，最后还是使用了平时常用的语言和IDE。 &emsp;&emsp;因为文件操作是平时写程序不太使用的操作。在比赛中也只是作为数据的输入输出，是比较简单的类型。其实这也应该是熟练掌握的技能，应该归咎于自己平时缺少学习。言归正传，我使用的语言是C++，IDE是Code::Blocks，这个是ACM的比赛环境，我写C的时候一直是使用这个。 &emsp;&emsp;查阅相关资料后，遇到的第一个问题就是在编译的时候，提示这是C++11的特性，编译时需要进行特殊的参数设定。 mingw32-g++.exe -std=c++11 -c &emsp;&emsp;进行编译设置之后，又出现了第二个问题，文本编码格式问题。默认在处理文本的时候都是ANSI格式。所以读取文件之后，会出现乱码。于是我从网上找到了处理UTF-8编码的C++程序，代码如下： 12345678910111213141516171819202122string UTF8ToGB(const char* str)&#123; string result; WCHAR *strSrc; LPSTR szRes; //获得临时变量的大小 int i = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0); strSrc = new WCHAR[i+1]; MultiByteToWideChar(CP_UTF8, 0, str, -1, strSrc, i); //获得临时变量的大小 i = WideCharToMultiByte(CP_ACP, 0, strSrc, -1, NULL, 0, NULL, NULL); szRes = new CHAR[i+1]; WideCharToMultiByte(CP_ACP, 0, strSrc, -1, szRes, i, NULL, NULL); result = szRes; delete []strSrc; delete []szRes; return result;&#125; &emsp;&emsp;进行了输入输出测试，读取文件，输出到控制台，没有任何问题。 &emsp;&emsp;接下来是选择存放XML的数据结构，这里使用了C++STL里的队列。结束存放之后，对队头进行出列，然后行数减一。这里是避免处理XML的第一行内容的笨方法： 1234567891011121314151617181920212223242526272829303132void fileReader()&#123; ifstream fileIn; fileIn.open(\"in.xml\"); string line; char txt[100]; if(fileIn) &#123; while(!fileIn.eof()) &#123; fileIn.getline(txt, 100); line = UTF8ToGB(txt); xmlQueue.push(line); lineNum ++; &#125; lineNum--; xmlQueue.pop(); //忽略第一行 &#125; fileIn.close();&#125;int main()&#123; fileReader(); while(lineNum--) &#123; cout &lt;&lt; xmlQueue.front() &lt;&lt; endl; xmlQueue.pop(); &#125; return 0;&#125; &emsp;&emsp;至此，完成了整个XML文件的读取工作和测试。 内容检查12345678910111213141516171819import java.io.*;import java.util.*;public class Parser &#123; public static void main(String args[]) &#123; LabelMessage tempStruct; String tempStr; Queue&lt;String&gt; xmlQueue = new LinkedList&lt;String&gt;(); //输出队列 HashMap&lt;String, LabelMessage&gt; xmlMap = new HashMap(); xmlQueue.offer(\"A\"); tempStruct = new LabelMessage(1,true,\"ABC\"); xmlMap.put(\"A\",tempStruct); tempStr = xmlQueue.poll(); tempStruct = xmlMap.get(tempStr); System.out.println(tempStruct.getConStr()); &#125;&#125;"},{"title":"友情链接","date":"2016-09-10T07:46:28.000Z","updated":"2018-01-10T14:18:48.979Z","comments":true,"path":"friend/index.html","permalink":"http://www.z16388.top/friend/index.html","excerpt":"","text":"&emsp;&emsp;小川先生：http://www.superxc.com/ &emsp;&emsp;田&emsp;浩：http://tianhao.site &emsp;&emsp;林嘉铭：http://jammylin.win &emsp;&emsp;Rainary：http://www.rainary.com &emsp;&emsp;仇博：http://remilitarize.space &emsp;&emsp;keysking：http://keysking.github.io"},{"title":"hdu答案","date":"2016-10-28T11:14:23.000Z","updated":"2018-01-10T12:10:34.353Z","comments":true,"path":"answer/index.html","permalink":"http://www.z16388.top/answer/index.html","excerpt":"","text":"1089-1096输入输出练习答案:http://www.z16388.top/2016/10/28/1089-1096输入输出练习/ hdu1326:http://www.z16388.top/2016/11/16/hdu1326-hdu2088/ hdu1720:http://www.z16388.top/2016/11/16/hdu1720/ hdu2000-2010:http://www.z16388.top/2016/10/28/hdu2000-2010/ hdu2011-2020:http://www.z16388.top/2016/10/30/hud2011-2020答案/ hdu2088:http://www.z16388.top/2016/11/16/hdu1326-hdu2088/"},{"title":"下载资源","date":"2016-09-11T05:56:07.000Z","updated":"2019-11-12T15:33:32.546Z","comments":true,"path":"Download/index.html","permalink":"http://www.z16388.top/Download/index.html","excerpt":"","text":"工具锐捷破解版:http://pan.baidu.com/s/1slCLdFn SQSXvpn:http://pan.baidu.com/s/1qX9Pb20 everything:https://pan.baidu.com/s/1gfE1wD9 vegas Pro12.0-64:https://pan.baidu.com/s/1slVHVNB vegas Pro12.0-64汉化补丁：https://pan.baidu.com/s/1dEHDamt matlab 2014b:https://pan.baidu.com/s/1qYo0AG8 Guitar Pro 5.2:https://pan.baidu.com/s/1dF2ukpz Adobe Audition CC:http://pan.baidu.com/s/1dFgF4Hj Adobe Photoshop CC:http://pan.baidu.com/s/1slvkkjz 软件开发ADTx86:https://pan.baidu.com/s/1nuABjxJ Eclipse:http://pan.baidu.com/s/1mio8JxQ Code:Blocks:http://pan.baidu.com/s/1mihhkvu Dev-C++:http://pan.baidu.com/s/1kVoALH9 MarkdownPad 2:http://markdownpad.com/download/markdownpad2-setup.exe Macdown(Mac用markdown编辑器):http://macdown.uranusjr.com 电子书Qt及Qt Quick开发实战精解：https://pan.baidu.com/s/1gfqeSCj Qt+Creator快速入门：https://pan.baidu.com/s/1bo2ib1P 音乐相关一万首吉他谱：https://pan.baidu.com/s/1kUOmzPH Sound Horizon全专辑：https://pan.baidu.com/s/1o8k0Ujo"},{"title":"关于我","date":"2020-05-24T09:54:10.000Z","updated":"2021-05-13T16:01:23.552Z","comments":true,"path":"about/index.html","permalink":"http://www.z16388.top/about/index.html","excerpt":"","text":"赵安琪/Anqi Zhao mail:1021622929@qq.com blog:http://z16388.top github:https://github.com/z16388 教育经历 大连交通大学 &emsp;&emsp;数学与应用数学+软件工程&emsp;&emsp;2013年9月至2018年7月（五年制，双学位） 学习课程： 数学分析、高等代数、解析几何、最优化方法、数学模型、数值计算方法、概率论与数理统计、常微分方程、数学物理方程、图论、数学史、模糊数学、计算机网络、计算机组织与结构（COA）、操作系统、软件工程、数据结构、软件体系结构、C语言、C++、Java、JSP、数据库、DB2、日语 技能掌握 熟练使用：js、Lua、Python、C#、markdown、Redis、MongoDB 使用过：C/C++、Java、Qt Creator、matlab、Unity、MySql、Elasticsearch 工作经历（2018年4月至今）北京帝江网络科技有限公司 《篮球经理》游戏客户端（2018年4月~2019年5月） Unity+NGUI+Tolua项目，起初负责勋章、国籍、角标、举报功能开发。 UI改版时期，负责市场、挑战、财政、球员训练、赛程界面的重写。其他新功能开发：支持者增值服务，设计支持者修改球场、球衣、球员、头像等功能；联盟系统。 日常负责客户端线上分支代码合并，安卓IOS应用和更新包的打包和上传，以及Google Play和IOS商店提审。 国内推广期间，接入华为、OPPO、VIVO等二十多个安卓渠道SDK，负责和第三方运营公司工作人员交接；接入头条统计SDK，以及微信分享SDK。维护出包工具，做出一键出所有安卓渠道包工具、Linux出包工具。 制作爬虫，爬取游戏论坛内容，用于游戏网站建设。并负责网站SEO优化。 游戏链接：https://www.taptap.com/app/61133 《一度甄选》后端（2019年5月~2020年10月） 在线教育项目，使用技术有：Node.JS MongoDB Redis Mysql Elasticsearch Python。 进入项目时，负责IOS第三方登录，接入QQ和微信登录SDK，并创建IOS出包工程（HBuilder）。 制作并维护微信公众号爬虫，采集公众号文章作者、内容与评论信息。 全程负责信息流推荐系统的开发与维护。学习并开发了项目中使用的基于标签的推荐系统。 Python开发内容录入工具。工具可将特定格式的word文档转化成前端可展示的json格式文件。同时还协助开发了前端编辑器的word文档粘贴功能，负责其中的有序列表和无序列表的逻辑处理。 社区开发阶段，负责：信息流、日记本、问答贴和悬赏提问、搜索、家庭教育、学习辅导、孩子档案、个人信息等功能的开发。制作自动回贴与点赞机器人。 商城开发阶段，负责：商城、APP、分销中心、创作者、提现等功能的开发。接入实名认证系统。接入微信、支付宝SDK。 同时负责运营后台、商城后台、供应商后台、作者后台等后台功能开发。 PC版网站：Sitemap生成工具、SEO优化。负责搜索、个人信息等功能。在前期负责SEO优化。 使用DroidPlugin、Whale研究安卓Hook相关内容。 线上服务器更新与维护。 应用官网：https://www.yiduzhenxuan.com/ 《黎明远征》游戏客户端（2020年10月至今） 放置类(刀塔传奇like)游戏、Unity+FairyGUI+ILRuntime项目。 负责功能悬赏、传奇战场、训练中心、VIP界面的开发，以及多轮次的UI优化。 负责文本检测工具、Spine文件检测与管理工具的开发，以及配置表生成工具的改版。 负责二次打包工具开发。 使用Unity Profile工具分析内存泄漏问题。 搭建SPUG运维平台，实现服务器进程监控报警、使服务器更新维护操作平台化。 搭建EFK日志分析系统。 应用官网：https://www.taptap.com/app/200938 大学经历 大连交通大学理学院学生会 科技部部长&emsp;&emsp;参与两台晚会音视频制作，音控、灯光管理工作&emsp;&emsp;迎新招新宣传板制作 交大软件竞赛协会 创始人&emsp;&emsp;创立协会，带领同学参加比赛&emsp;&emsp;对15、16、17级同学开设算法小课堂 大连交通大学汉服社 工部部长&emsp;&emsp;参与汉服社创建，参加部分活动 获奖经历 2012年1月 中华情艺术风采国际交流展演活动安徽赛区选拔赛 吉他·少年B组·金奖 2015年4月 第六届蓝桥杯软件和信息技术专业人才大赛辽宁省赛区C/C++程序设计大学生B组 一等奖 2015年5月 ACM-ICPC Contest 辽宁省 二等奖 2015年5月 第六届蓝桥杯软件和信息技术专业人才大赛全国总决赛C/C++程序设计大学生B组 三等奖 2015年7月 大连交通大学2015年(第三届)Java程序设计大赛（JPC） 二等奖 2016年3月 第七届蓝桥杯软件和信息技术专业人才大赛辽宁省赛区C/C++程序设计大学生B组 二等奖 2017年3月 第八届蓝桥杯软件和信息技术专业人才大赛辽宁省赛区C/C++程序设计大学生B组 二等奖 等级考试 CET-4 其他 中国音乐学院 社会艺术水平考试 吉他六级 中国音乐艺术家研究院 全国艺术特长生认证 中国音乐家协会 中国音协吉他学会会员 尺八 琴古流 贵风会 学生 游戏经验 玩家时间：2002年至今 PSN信息：http://psnine.com/psnid/z16388（白金数/游戏数：15/96） Steam信息：http://steamcommunity.com/id/z16388/ 其他游戏主机：Xbox1、NS、PSV、PSP 最终幻想14 导师"},{"title":"fan","date":"2017-01-24T12:25:38.000Z","updated":"2017-04-13T13:25:15.975Z","comments":true,"path":"fan/index.html","permalink":"http://www.z16388.top/fan/index.html","excerpt":"","text":"评分标准： 5 值得回味4 不可多得3 好看2 可以看1 渣作 动画 番名 类型 年份 评分 备注 Air TV12话+2OVA+总集 2005年冬 Key社季节四部曲，夏之Air Angel Beats！ TV13+1OVA+2特别篇 5 阿拉德战记 TV26集 2009年春夏 2 DNF游戏改编 爱丝卡&amp;罗吉的炼金工房～黄昏天空之炼金术士～ TV12话 2014春 3 爱杀宝贝 TV13+1OVA 2012冬 5 暗杀教室 TV22话+2OVA 2015冬、春 4 BIKINI WARRIORS TV12话+1OVA 2015夏 2 没看完 Black★RockShooter TV8话 2012冬 2 Black★RockShooter OVA 1话 2010年7月 2 百合熊风暴 TV12话 2015冬 ？ 看不懂+没看完 笨蛋、测验、召唤兽 TV13话+2OVA 2010冬 4 笨蛋、测验、召唤兽2！ TV13话 2011夏 4 不思议美眉 12话泡面番 2015秋 4 Clannad TV22话+1番外+1特别 2007秋、2008冬 5 Key社季节四部曲，春之Clannad CLANNAD～AFTER STORY～ TV22话+1番外+1总集+1特别 2008秋、2009冬 5 Clannad第二季 Chaos Dragon 赤龙战役 TV12话 2015夏 2.5 没看完 侧耳倾听 剧场版 1995年 5 曾几何时天魔的黑兔 TV13话 2011夏 3 没看完 赤发白雪姬 TV24话 2015夏秋 3.5 没看完 出包王女 TV26话+6OVA 2008年春夏 4 &amp; 更多出包王女 TV12话 2010年秋 4 出包王女Darkness TV12+6OVA 2012秋 4 出包王女Darkness 2nd TV14+1特别+3OVA 2015夏 4 穿越时空的少女 剧场版 2006年7月 5 小说之后的故事 纯白交响曲 TV12话 2011年秋 3 大家集合吧！Falcom学园 两季26话泡面番 2014冬、2015春 3.5 fans向 电波教师 TV24话 2015春夏 3 没看完 东京食尸鬼 TV12话 2014夏 3 哆啦A梦：新·大雄的日本诞生 剧场版 2016年3月 5 ef - a tale of memories. TV12话 2007秋 &amp; ef - a tale of melodies. TV12话 2008秋 &amp; 恶魔阿萨谢尔在召唤你 恶魔阿萨谢尔在召唤你z Fate/Stay Night TV24话 2006年冬春 5 Fate/stay night [Unlimited Blade Works] TV26+1OVA 2014秋、2015春 5 Fate/Stay Night Unlimited Blade Works 剧场版 2010年1月 4 节奏过快，需要结合原作去看才能跟上 Fate/Zero TV两季25话 2011年秋、2012年春 5 风之谷 剧场版 1984 5 GATE 奇幻自卫队 TV24话 2015夏、2016冬 4.5 甘城辉煌乐园救世主 TV13+OVA 2014秋 &amp; 搞姬日常 13话 泡面番 2014夏 5 搞笑漫画日和 4季12*3+25话 泡面番 - 5 干物妹！小埋 TV12+1OVA 2015夏 5 关于完全听不懂老公在说什么的事 两季26话 泡面番 2014秋、2015春 5、4 哈尔的移动城堡 剧场版 2014年11月 4 好想告诉你 TV25+TV13 2009秋、2010冬+2011冬 4 &amp; 红猪 剧场版 4 花舞少女 TV12话 2014夏 4 幻想嘉年华 12+α 2011年夏秋 5 极黑的布伦希尔德 TV13话 2014春 5-1 后面烂尾 机巧少女不会受伤 TV12话 2013秋 4 没看完 寄生兽 TV24话 2014秋、2015冬 4 没看完 加速世界 TV24话+2OVA 2012春 5 舰队collection TV12话 2015冬 * 结城友奈是勇者 TV12话 2014秋 4 没看完 借东西的小人阿莉埃蒂 剧场版 2010年7月 4 尽管如此世界依然美丽 TV12话 2014春 5 老夫的少女心~(@^_^@)~ 进击的巨人 TV26+5OAD 2013春夏 2 没看完 境界的彼方 TV12+OVA 2013秋 5 境界的彼方 -I’LL BE HERE- 未来篇 剧场版 2015年4月 4 绝对双刃 TV12话 2015冬 X 完全没有印象了 Kannon TV 5 key社季节四部曲，冬之Kannon 可塑性记忆 TV13话 2015春 4 &amp; 科学超电磁炮 TV24+OVA 2009秋、2010冬 3 科学超电磁炮S TV24+OVA 2013春夏 3 空之境界 剧场版8集 2007~2010年 5 LoveLive! TV两季16话+OVA 2013冬、2014春 3 来自虞美人之坡 剧场版 2011年7月 3 宫崎吾朗第二作 凉宫春日的消失 剧场版 2010年2月 5 凉宫春日的忧郁 TV14话 2006春 5 凉宫春日的忧郁 TV28话（包括前作14话） 2009年春夏 -5 邻座的怪同学 TV13+1OAD 2012秋 4 零之使魔 TV13话 2006夏 4 零之使魔～双月的骑士～ TV12话 2007夏 4 零之使魔～三美姬的轮舞～ TV12+OVA 2008夏 4 零之使魔F TV12话 2012冬 4 六叠间的侵略者 TV12话 2014夏 4 六花的勇者 TV12话 2015夏 3.5 龙猫 剧场版 5 龙娘七七七埋藏的宝藏 TV11话 2014春 4 &amp; 龙与虎 TV25+OVA 2008秋、2009冬 5 鲁邦三世VS名侦探柯南 剧场版 2009年3月 5 鲁邦三世：卡里奥斯特罗城 剧场版 1979年 5 路人女主的养成方法 TV13话 2015冬 4 萝球社！ TV12+1OVA 2011夏 4 小仓唯圈粉作 轮回的拉格朗日 两季TV24+OVA 2012冬、夏 ？ &amp; MACROSS DELTA TV16话 2016春夏 5 GiriGiri~EYE~ MM一族 TV12话 2010秋 4 漫画家与助手 TV12话+6OVA 2014春 5 猫的报恩 剧场版 2002年7月 4 《侧耳倾听》外传 每度！浦安铁筋家族 泡面番 2014夏 4 迷茫管家与懦弱的我 秒速五厘米 剧场版 2007年 5 魔法禁书目录 TV24话 2008秋、2009冬 3 魔法禁书目录 TV24话 2010秋、2011春 3 魔法的禁书目录：恩底弥翁的奇迹 剧场版 2013年2月 4 魔法少女小圆 TV12话 2011冬 4 魔法少女小圆剧场版 [前篇] 起始的物语 剧场版 2012年10月 3 魔法少女小圆剧场版 [后篇] 永远的物语 剧场版 2012年10月 3 魔法少女小圆剧场版 [新篇] 叛逆的物语 剧场版 2013年10月 5 魔法少女什么的已经够了啦。 泡面番两季24话 2016冬、秋 3 没看完 魔女宅急便 剧场版 1989 4 魔物娘的同居日常 TV12话+OAD 2015夏 3 没看完 目隐都市的演绎者 TV12话 2014春 * 没看完 NO GAME NO LIFE游戏人生 TV12话 2014春 4 虎纹鲨鱼~ 那就是声优！ TV13话 2015夏 4 南家三姐妹 你的名字。 剧场版 2016年12月 5 新海老贼！！！！ 虐杀姬 5OVA 2007年 4 Overlord TV13+1OVA 2015夏 4.5 乒乓 TV11话 2014春 5 普通女高中生要做当地偶像 TV12话 2014夏 3 起风了 剧场版 2013年7月 4 漆黑的子弹 TV13话 2014春 3 没看完 齐木楠雄的灾难 TV24话 2016夏秋 5 潜行吧！奈亚子 TV12话+1OVA 2012春 4 潜行吧！奈亚子W TV12话+1OVA 2013春 4 潜行吧！奈亚子F OVA1话 2015年5月 4 琴浦小姐 TV12话 2013冬 4 平胸小姐 侵略！乌贼娘 TV24话+3OVA 2010秋、2011秋 3 前进吧！登山少女 TV两季36话泡面番 2013冬、2014夏秋 3 千与千寻 剧场版 2001年 5 枪神斯托拉塔斯 TV12话 2015春 3 没看完 青春×机关枪 TV12话 2015夏 3 青春之旅 TV12话 2014夏 4 &amp; 请问您今天要来点兔子吗？ TV12话 2014春 3.5 请问您今天要来点兔子吗？？ TV12话 2015秋 3 轻音少女！ TV12+2番外 2009春 5 轻音少女！！ TV24+3番外 2010春夏 5 轻音少女 剧场版 剧场版 2011年12月 5 犬神同学和猫山同学 12话+1OVA 泡面番 2014春 5 日常 TV26+OVA 2011春夏 5 散华礼弥 TV12+2OVA+1OAD 2012春 3 神的记事本 死亡笔记 TV37+2SP 2006秋~2007春 3 四月是你的谎言 TV22话+1OAD 2014秋、2015冬 5 上课小动作 TV全21集+OVA2集+映像特典2集 泡面番 2014冬、春 5 石膏男孩 TV12话 2016冬 4.5 噬神者 TV13话 2015夏、2016冬 5 御神乐学园组曲 TV12话 2015春 3 &amp; 授业到天亮Chu! 剧场版 2014年6月 4.5 黄漫改编表番！？ 桃剑 TV12话 2014夏 2.5 没看完 天降之物 TV13+OVA 2009秋 3 天降之物 f TV12 2010秋 3 天降之物：发条装置之哀女神 剧场版 2011年6月 3 天降之物Final：永远的我的鸟笼 剧场版 2014年4月 3 天空之城 剧场版 1986年 5 天体的秩序 图书馆战争 TV12+1 2008年春 3 没看完 妄想学生会 TV13+8OVA 2010年夏 5 妄想学生会* TV13+6OVA 2014冬 5 未来日记 TV26话 2011秋、2012冬 2 单纯的不喜欢而已 伪恋 TV20话+3OVA 2014冬春 4 伪恋： TV12话 2015春 3 为美好的世界献上祝福！ TV10+2OVA 2016冬 4 为美好的世界献上祝福！2 2017冬 &amp; 问题儿童都来自异世界？ TV10+OVA 2013冬 3 没看完 我不受欢迎，怎么想都是你们的错！ TV12话+1OVA 2013夏 5 我被抓到贵族女校当“庶民样本” TV12话 2015秋 3 我老婆是学生会长！ TV12+1OVA 2015夏 3.5 我老婆是学生会长！+！ TV12话 2016秋 3 我的妹妹哪有这么可爱！ 16话+1番外 2010秋 5 我的妹妹哪有这么可爱。 16话 2013年春 4 我的脑内恋碍选项 TV10话+OVA 2013秋 3 没看完 我的朋友很少 TV12+OVA+OAD 2011秋 4 我的朋友很少NEXT TV12话 2013冬 3 &amp; 我的青春恋爱物语果然有问题。 TV13+OVA 2013春 5 我的青春恋爱物语果然有问题。续 TV13话 2015春 -5 惨不忍睹，渣作之最，只看2分钟 我家浴室的现况 13话 泡面番 2014秋 3 我女友与青梅竹马的惨烈修罗场 TV13 2013春 3 毁于画风 我们大家的河合庄 TV13话 2014春 4.5 我们没有羽翼 TV12话 2011春 5 贼他喵黄暴 我们仍未知道那天所看见的花的名字 TV11话 2011春 5 我们仍未知道那天所看见的花的名字剧场版 剧场版 2013年8月 5 我太受欢迎了该怎么办 TV12话 2016秋 4 我永远的圣诞老人 2OVA 2005年12月 3 物语系列 - - - - 化物语 TV12+3 2009夏 5 伪物语 TV11话 2012冬 5 猫物语（黑） TV4话 2012年12月31日 5 物语系列 2nd Season TV26+5SP 2012夏、秋 5 包括《猫物语（白）》、《倾物语》、《囮物语》、《鬼物语》和《恋物语》，SP为《花物语》 凭物语 TV4话 2014年12月31日 5 &amp; 终物语 TV12话 2015秋 5 &amp; 历物语 APP12话 2016年1月 ？ &amp; 伤物语Ⅰ铁血篇 剧场版 2016年1月 ？ &amp; 伤物语Ⅱ 热血篇 剧场版 2016年8月 ？ &amp; 伤物语Ⅲ 冷血篇 剧场版 2017年1月 ？ &amp; 下流梗不存在的灰暗世界 TV12话 2015夏 5 夏目友人帐 TV13话 2008夏 5 续夏目友人帐 TV13话 2009冬 5 夏目友人帐叁 TV13话 2011夏 5 夏目友人帐肆 TV13话 2012冬 5 夏目友人帐 猫咪老师首次变身使者 OVA 2013年8月 5 夏目友人帐 曾几何时下雪之日 OVA 2014年2月 5 夏目友人帐伍 TV11话+OVA 2016秋 4 小长门有希的消失 TV16+OVA 2015春夏 4 线上游戏的老婆不可能是女生？ TV12话 2016春 3 没看完 幸腹涂鸦 TV12话 2015冬 3 没看完 星刻的龙骑士 TV12话 2014春 2 幸运星 TV24+OVA 2007春 4 &amp; 修业魔女璐璐萌 TV12话 2014夏 &amp; 悬崖上的金鱼公主 剧场版 2008年7月 4 学生会的一己之见 TV12话 2009年秋 4 学生会的一己之见 Lv.2 TV9+1EX 2013年、冬 3 &amp; 血型君 四季49话泡面番 2013春、2015冬、秋、2016冬 3 要听爸爸的话！ TV12+1+2OVA 2012冬 3 没看完 摇曳百合 TV12话 2011夏 5 摇曳百合♪♪ TV12话 2012夏 4.5 摇曳百合 3☆High! TV12话 2015秋 5 摇曳百合 夏日时光+ 2话 2015年8月 5 野良神 两季 -4 异国迷路的十字路口 一拳超人 TV12+OVA+OAD 2015秋 5 樱花庄的宠物女孩 TV24话 2012秋、2013冬 2 没看完 幽灵公主 剧场版 1997年 5 有你的小镇 TV12+3OVA 2013夏 4 有你的碧池 元气囝仔 TV12话 2014夏 5 元气少女缘结神 TV13+OVA 2012秋 4 元气少女缘结神◎ TV12话 2015冬 4 月刊少女野崎君 TV12话 2014夏 5 在下坂本，有何贵干？ TV12话 2016春 4 斩·赤红之瞳！ TV24话 2014夏 3 没看完 这个是僵尸吗？ TV12+1OVA 2011冬 3 这样算是僵尸吗？OF THE DEAD TV10话 2012春 3 枕男子 TV12泡面番 2015夏 3 只有神知道的世界 TV12话 2010秋 4 只有神知道的世界2 TV12话 2011春 4 只有神知道的世界·女神篇 TV12话 2013夏 4 重金属摇滚双面人 中二病也要谈恋爱！ TV12+1 2012秋 5 中二病也要谈恋爱！恋 TV12+1 2014冬 3.5 终结的炽天使 TV24话 2015春、秋 3.4 没看完 罪恶王冠 TV22+1+1OVA 2011秋、2012冬 3 没看完 - - - - - 补 荒川爆笑团 TV两季26话 2010春、秋 4 黑白来看守所 人渣的本愿 小林家的妹抖龙 One Room 珈百璃的堕落 风夏 政宗君的复仇 清恋 杀老师Quest NEW GAME! 双星之阴阳师 Re：从零开始的异世界生活 无彩限的怪灵世界 吹响！上低音号 两季TV26+1 2015春、2016秋 &amp; 军火女王 TV两季24话 2012春、秋 恶魔阿萨谢尔在召唤你 恶魔阿萨谢尔在召唤你z 文学少女 银魂 薄樱鬼 迷糊餐厅 会长大人是女仆 真·恋姬无双 黑塔利亚 一骑当千 玉响 黑之契约者 传颂之物 亲吻姐姐 滑头鬼之孙 学园默示录 缘之空 食梦者 GOSIC 追逐繁星的孩子 君吻 圣诞之吻 学园默示录 无口的森田小姐 电波女与青春男 命运石之门 花开伊吕波 萤火之森 旋风管家 就算是哥哥，有爱就没问题了，对吧 绝园的暴风雨 玉子市场 超元气三姐妹 魔王勇者 变态王子与不笑猫 打工吧！魔王大人 言叶之庭 high school 神不在的星期天 来自风平浪静的明天 三者三叶 京骚戏画 最近，妹妹的样子有点怪？ 一周的朋友 我，要成为双马尾 肯普法 安琪莉可 电波女 圣剑锻造师 Another 在盛夏等待 东京残响 新妹魔王的契约者 山田君与7人魔女 俺物语！！ 学园孤岛 灵感！ 苍之彼方的四重奏 灰与幻想的格林姆迦尔 若叶女孩 亚人酱有话要说 冰上的尤里 日剧 番名 类型 年份 评分 备注 百鬼夜行抄 虫师 我们仍未知道那天所看见的花的名字。 剧场版 2015年9月 5 那朵花SP 排名200补番表200.希德尼娅的骑士197.心理测量者193.光之美少女192.冰菓188.坂道上的阿波罗186.刀语185.东之伊甸184.魔法少女奈叶182.flcl特别的她181.狼与香辛料180.悠哉日常大王179.樱兰高校男公关部178.圣母在上177.异邦人 无皇刃谭174.阿兹漫画大王172.星界的战旗170.无限的未知169.校园迷糊大王165.重金属摇滚双面人164.飞跃巅峰163.只有我不在的街道157.萤火虫之墓156.摇滚新乐园154.无头骑士异闻录141.xxxHOLIC继140.赌博默示录137.剑风传奇136.向阳素描135.自新世界131.黑之契约者126.奇诺之旅125.千年女优123.ef122.盗梦侦探121.狼的孩子雨和雪120.海马118.秀逗魔导师115.欢迎加入NHK113.夏日大作战（细田守）112.飞跃巅峰110.宇宙战舰大和号109.超智游戏108.ef2106.怪化猫（怪物）96.星界的战旗295.相聚一刻94.宇宙兄弟93.交响诗篇91.星界的纹章89.jojo88.东京教父87.perfect blue86.吹响！上低音号 （上面有）85.王牌投手83.第一神拳81.机动警察 和平保卫战80.昭和元禄落语中心77.四畳半神话大系（歌）、75.夏娃的时间70.电脑线圈68.精灵守护者67.交响情人梦61.黑礁60.白兔糖57.全职猎人55.全金属狂潮54.皇家国教骑士团51.百变之星 不死鸟传说48.十二国记45.食梦者43.空之境界40.混沌武士38.百变之星37.永生之酒35.蜂蜜与四叶草（长井龙雪）31.死亡笔记30.歌牌情缘28.怪物26.少女与战车25.天元突破22.星空清理着20.白箱17.排球少年15.反叛的鲁路修14.虫师13.EVA10.水星领航员9.浪客剑心8.钢之炼金术师7.命运石之门6.银魂5.星际牛仔4.银河英雄传说2.攻壳机动队 歌龙与虎 田中君总是如此慵懒的小剧场亚人甲铁城三月的狮子橘色奇迹91天黑色幻想的格林姆加尔昭和元禄落语中心jojo漂流武士drifters文豪野犬relife重生计划我的英雄学院冰上的尤里灵能百分百排球少年只有我不在的街道"},{"title":"常用网址导航","date":"2016-09-09T12:08:29.000Z","updated":"2018-11-10T12:19:24.625Z","comments":true,"path":"int/index.html","permalink":"http://www.z16388.top/int/index.html","excerpt":"","text":"分析 学习廖雪峰的官方网站：Python，js，git教程 DSQiu的博客(旧) (新) 立航的博客园 善用佳软：IT义工的个人博客 教你画像素画：教你画像素画的豆瓣小组 程序猿七牛云 在线查看apk的dex数 学校教务在线 网络中心 音乐现音研 吉他社"},{"title":"tags","date":"2016-09-09T07:42:07.000Z","updated":"2017-04-13T13:25:15.990Z","comments":false,"path":"tags/index.html","permalink":"http://www.z16388.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-30T11:09:08.147Z","updated":"2020-10-30T11:09:08.147Z","comments":true,"path":"un/index.html","permalink":"http://www.z16388.top/un/index.html","excerpt":"","text":"U3D面试相关问题总结 计算机基础与C# 线性代数与算法 Unity基础 物理相关 渲染与光照 优化问题 lua"},{"title":"工作笔记","date":"2016-09-10T07:46:28.000Z","updated":"2020-10-29T15:31:11.949Z","comments":true,"path":"work/index.html","permalink":"http://www.z16388.top/work/index.html","excerpt":"","text":"游戏Lua学习笔记 AnySDK生成aar Android各渠道接入体验 JavaScript连接MySQL闪退 使用Splice()函数操作数组 使用replace()函数全部替换 AndroidAndroid28前期的坑 Android应用生成闪屏 命令行修改apk工具 Android逆向笔记 爬虫某爬虫工具多开方案"}],"posts":[{"title":"震惊，JS不加分号会造成错误！？","slug":"震惊js","date":"2019-12-01T16:12:19.000Z","updated":"2019-12-01T16:48:03.109Z","comments":true,"path":"2019/12/02/震惊js/","link":"","permalink":"http://www.z16388.top/2019/12/02/震惊js/","excerpt":"","text":"在之前的工作中，我遇到了一个奇怪的问题。明明在语法上没有问题，找同事也看了，但是程序依旧会产生奇怪的错误。最后通过一步一步断点，定为了错误位置，才找到了造成这个错误的原因———在一个不需要分号的语言中，句末不加分号居然报错了。 不卖关子了，这个错误是多返回值函数造成了对上一句值的影响。下面举个例子： 12345678910function func() &#123; return [1, 2]&#125;let b = 0let c = 0let a = 3[b, c] = func();console.log(\"a is :\" + a)console.log(\"b is :\" + b + \" c is :\" + c) 运行的结果将会是这样: a is :1,2b is :0 c is :0 很容易看到，我们函数的返回值给了上一行的a。这是因为我们的编译器将代码认为了： 1let a = 3 ,[b, c] = func(); 避免这种情况，还是要多加分号吧——虽然它并不会报错。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.z16388.top/tags/JavaScript/"}],"keywords":[]},{"title":"Linux升级Python","slug":"linuxuppy","date":"2019-11-28T04:12:19.000Z","updated":"2019-12-01T17:10:37.987Z","comments":true,"path":"2019/11/28/linuxuppy/","link":"","permalink":"http://www.z16388.top/2019/11/28/linuxuppy/","excerpt":"","text":"11月底，腾讯云搞了一波双11返场活动，我买了三年的服务器。 和买了新的电脑或者做了新系统一样，得先把生产环境搞好。 距离Python2.x停止维护大概只有5个月了吧，所以第一要务是升级Python的版本。但是yum是依赖Python2的，所以升级还是会有一些顾虑的。下面是升级的过程： 下载、解压12wget https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tgztar -zxvf Python-3.8.0.tgz 安装编译环境12yum install make build-essential libssl-dev zlib1g-dev libbz2-devyum install zlib 编译、安装123456yum install -y make build-essential libssl-dev zlib1g-dev libbz2-devyum -y install zlibcd Python-3.8.0./configuremake &amp;&amp; make install 备份与配置12mv /usr/bin/python /usr/bin/python.bakln -s /usr/local/bin/python3 /usr/bin/python 保证yum可用将下面文件中的配置修改为Python2.x版本的路径。 12/usr/bin/yum/usr/libexec/urlgrabber-ext-down 安装pippip需要依赖setuptools，所以要先安装setuptools。 1234567891011wget https://files.pythonhosted.org/packages/ce/1d/96320b9784b04943c924a9f1c6fa49124a1542039ce098a5f9a369227bad/setuptools-42.0.1.zipunzip setuptools-42.0.1.zipcd setuptools-42.0.1python setup.py buildpython setup.py installwget https://files.pythonhosted.org/packages/ce/ea/9b445176a65ae4ba22dce1d93e4b5fe182f953df71a145f557cffaffc1bf/pip-19.3.1.tar.gztar -zxvf pip-19.3.1.tar.gzcd pip-19.3.1python setup.py buildpython setup.py install 参考资料https://www.cnblogs.com/zhangym/p/6226435.htmlhttps://www.cnblogs.com/fjping0606/p/9156344.htmlhttps://www.cnblogs.com/fyly/p/11112169.html","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.z16388.top/tags/Python/"},{"name":"Linux","slug":"Linux","permalink":"http://www.z16388.top/tags/Linux/"}],"keywords":[]},{"title":"Github图床工具","slug":"picupdate","date":"2019-11-17T10:32:44.000Z","updated":"2019-11-17T10:33:15.419Z","comments":true,"path":"2019/11/17/picupdate/","link":"","permalink":"http://www.z16388.top/2019/11/17/picupdate/","excerpt":"","text":"这是一个上传图片到github的工具，目前还不是很成熟，不过已经可以实现压缩并上传图片的目的了，对于写博客来说已经够用了。 使用步骤 创建todo目录 创建pic目录，在github上创建一个空项目，然后pull到这里 修改配置文件，将git_url修改为上一步新建的项目 将图片放到todo文件夹下 执行工具 需要注意的是，因为图床需要一个git目录，同时代码也需要。在使用部分git管理工具时会禁止这种目录的嵌套。因此最好将代码独立运行。可以自己打包，也可以使用我打好的可执行程序。 在这里需要提一句，一般如果只想要下载github上项目的一个目录或者一个文件，可以使用svn进行下载。将文件路径中的文件名/master替换为trunk即可使用下载。 经过配置之后，以后只需要将图片放到todo目录下，执行脚本即可。 编译时需要安装以下运行库 123pip install pyyamlpip install gitpythonpip install pillow 更新文档Ver.0.2 2019-11-17 提交编译的可执行程序；增加配置文件 Ver.0.1 2019-11-12 提交项目","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.z16388.top/tags/Python/"},{"name":"Github","slug":"Github","permalink":"http://www.z16388.top/tags/Github/"}],"keywords":[]},{"title":"JS使用replace()函数全部替换","slug":"jsreplace","date":"2019-11-16T14:03:56.000Z","updated":"2019-11-16T14:03:21.249Z","comments":true,"path":"2019/11/16/jsreplace/","link":"","permalink":"http://www.z16388.top/2019/11/16/jsreplace/","excerpt":"","text":"在处理爬虫爬取下来的数据时，遇到了在文字中出现了经过转义的换行符，在文中显示出了\\n，很影响观赏效果。因此，我对内容做了处理。 但是在刷库的过程中，我发现，我总不能一次处理完所有的数据。后来发现是JavaScript的Replace函数的问题，这个函数默认只能替换第一个匹配到的项目。如果需要处理全部的，需要使用正则表达式： 1string.replace(/\\\\n/g, \"\\n\") 除此之外，下面是一些处理爬取内容常用操作，包含了html的转义： 12345678910string.replace(/&amp;nbsp;/g, ' ')string.replace(/&amp;lt;/g, '&lt;')string.replace(/&amp;gt;/g, '&gt;')string.replace(/&amp;amp;/g, '&amp;')string.replace(/&amp;quot;/g, '\"') string.replace(/&amp;#x3D;/g, '=') string.replace(/\\[.*?\\]/g,'') string.replace(\"\\\\n\",\"\\n\") string.replace(\"\\\\t\",\"\") string.replace(\"\\\\r\",\"\")","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.z16388.top/tags/JavaScript/"}],"keywords":[]},{"title":"JS使用Splice()函数操作数组","slug":"jssplice","date":"2019-11-16T13:59:56.000Z","updated":"2019-11-16T14:00:02.652Z","comments":true,"path":"2019/11/16/jssplice/","link":"","permalink":"http://www.z16388.top/2019/11/16/jssplice/","excerpt":"","text":"在js的使用过程中，有一次需要对数组进行各种操作，一时间迫使我想要去使用链表。后来通过查阅资料，总结了下面的一些方法，主要使用了splice()函数。 下面的方法主要是使用下标进行操作。如果是用值的话，可以通过indexOf()函数来获取下标。若不存在则返回-1。 值交换 1234function swap_arr(a_list, index1, index2) &#123; a_list[index1] = a_list.splice(index2, 1, a_list[index1])[0]; return a_list;&#125; 置顶 12345function up_arr(a_list, index)&#123; if(index!=0 &amp;&amp; index!=-1)&#123; a_list[index] = a_list.splice(index-1, 1, a_list[index])[0]; &#125;&#125; 下移 12345function down_arr(a_list, index) &#123; if(index!=a_list.length-1 &amp;&amp; index!=-1)&#123; a_list[index] = a_list.splice(index+1, 1, a_list[index])[0]; &#125;&#125; 插入 1234567891011function ins_arr(a_list, index, a_data) &#123; if(index!=-1)&#123; if (a_list.indexOf(a_data)==-1) &#123; a_list.splice(index+1, 0, a_data); return true; &#125; else &#123; return false; &#125; &#125;&#125; 在顶部插入 123function topins_arr(a_list, a_data) &#123; a_list.splice(0, 0, a_data)&#125; 删除元素 12345678function del_arr(a_list, a_data_list) &#123; for (const ele of a_data_list) &#123; let index = a_list.indexOf(ele); if(index!=-1)&#123; a_list.splice(index, 1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.z16388.top/tags/JavaScript/"}],"keywords":[]},{"title":"当你的程序连接Mysql然后崩溃时","slug":"mysqltimeout","date":"2019-11-16T13:43:56.000Z","updated":"2019-11-16T13:47:13.465Z","comments":true,"path":"2019/11/16/mysqltimeout/","link":"","permalink":"http://www.z16388.top/2019/11/16/mysqltimeout/","excerpt":"","text":"之前写过一个监控mysql数据库更新状态的预警程序，总是莫名其妙的报一个连接错误的错，然后程序死掉。后来在系统趋于稳定之后，我就没再继续维护这个工具了。 但是最近我在写另一个工具时，遇到了一个奇怪的问题，就是：tick总在27000多左右的时候崩溃。 我进行了一系列的猜测，比如tick的代码，或者是逻辑有问题，最后我把思路放在了之前遇到的这个错误上。查阅资料后发现，MySQL数据库在连接之后，如果超过一个设定的时间戳之后，会断开。这个值叫WAIT_TIMEOUT，默认值是28800，也就是说如果连上MySQL数据库之后，8小时内没有进行操作，这个连接便会断开。 网上很多连接MySQL数据库的代码没有处理过超时连接的问题，就连JS的官方代码好像也是在17年之后才更新的。以往这个问题，大家都是通过修改这个值来进行规避的。比如改成300天。修改有两种方式，一种是修改配置文件，这样在启动时便会使用这个配置；另一种是修改这个值，或者全局，或者当次生效。 下面是我在使用JavaScript语言链接MySQL数据库时，处理超时重连问题的代码： 1234567891011121314151617181920212223242526272829303132this.config = &#123; \"host\": \"x.x.x.x\", \"port\": xxxx, \"user\": \"root\", \"password\": \"pass\", \"database\": \"name\"\"&#125; async connect() &#123; let self = this; console.log(\"connect mysql success with\", JSON.stringify(this.config)) // 创建连接 this.db_mysql = mysql.createConnection( this.config ); // 连接数据库 await this.db_mysql.connect(); // 错误处理 this.db_mysql.on('error', function(err) &#123; if (err) &#123; if (err.code === 'PROTOCOL_CONNECTION_LOST') &#123; // 处理超时 console.warning(\"start reconnect mysql\"); self.connect(); &#125; else &#123; console.error(err.stack || err); console.warning(\"start reconnect mysql\"); self.connect(); &#125; &#125; &#125;);&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.z16388.top/tags/JavaScript/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.z16388.top/tags/MySQL/"}],"keywords":[]},{"title":"安卓应用闪屏","slug":"AndroidSplash","date":"2019-11-16T13:19:56.000Z","updated":"2019-11-16T13:41:45.264Z","comments":true,"path":"2019/11/16/AndroidSplash/","link":"","permalink":"http://www.z16388.top/2019/11/16/AndroidSplash/","excerpt":"","text":"去年在接入安卓SDK时，会有部分渠道有要求手写闪屏的情况，下面是当时的笔记，这只是最简单的一种方法。 参考资料：很好的例子： https://www.jianshu.com/p/a609f510b19a https://blog.csdn.net/l799069596/article/details/47094731 安卓动画：https://blog.csdn.net/IO_Field/article/details/53101499 背景：除去游戏本身的闪屏之外，有的渠道会要求，有额外的渠道闪屏。为了使用一套资源出不同渠道包，我们可以对接渠道的AS工程进行处理，单独设置闪屏。 首先，创建一个闪屏Activity，为你的主Activity，这样在游戏的一开始你就可以看到闪屏了。 这里需要注意的是，你原先的Activit也需要在Manifest中注册打开日志，否则在打包的时候会找不到，报错： https://blog.csdn.net/qq_28301007/article/details/52265775 1&lt;activity android:name=\"...Activity\"/&gt; 下面是主Activity，也就是闪屏Activity的代码，需要根据AS的提示import缺少的部分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import android.animation.ObjectAnimator;import android.animation.ValueAnimator;import android.app.Activity;import android.content.Intent;import android.os.Bundle;import android.os.Handler;import android.view.WindowManager;import android.widget.ImageView;public class SplashActivity extends Activity &#123; private final int TimeAnimDurning = 2000; private int displayDeviceWidth; ImageView iv_splash; private ObjectAnimator objAnim; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); displayDeviceWidth = getResources().getDisplayMetrics().widthPixels; setContentView(R.layout.activity_splash); iv_splash = (ImageView) findViewById(R.id.splash); objAnim = ObjectAnimator.ofFloat(iv_splash,\"alpha\",1,0); objAnim.setDuration(TimeAnimDurning); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; objAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; if((int)animation.getAnimatedFraction() == 1)&#123; getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN); startActivity(new Intent(SplashActivity.this , .YouActivity.class)); finish(); return ; &#125; &#125; &#125;); objAnim.start(); &#125; &#125;, 2000); &#125;&#125; 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/white\" tools:context=\"com.unity3d.player.SplashActivity\"&gt;&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:visibility=\"visible\"&gt; &lt;ImageView android:id=\"@+id/splash\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:scaleType=\"fitXY\" android:src=\"@drawable/splash\" /&gt;&lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 在上面控制闪屏格式的style.xml中，可以看到闪屏的背景色设置为了白色。这里有一些常用的颜色xml：https://blog.csdn.net/sundaysunshine/article/details/53509854 除了这两处之外，还需要根据style.xml中的配置，放好闪屏图片，设置闪屏背景。 整个闪屏的原理就是创建一个动画，在动画播放完成之后，去执行一个新的activity。在补全报错的部分之后，还是有一些细节部分需要注意的。 首先是结束时间的判定。判定时机总共有两种，一种是获取动画的进度，就像这里的例子，使用(int)animation.getAnimatedFraction()进行获取一个从0~1的数，来表示目前的动画的播放进度。除此之外还可以获取播放的时间，这个函数是：getAnimatedValue()，它可以获取属性的当前值。使用这两个函数可以很方便地控制动画的时间和动作。 除此之外，在调起另一个Activity之后，我结束了这个Activity。这是因为如果使用默认的LaunchMode，在重新唤醒应用时，闪屏会再次启动，然后走完动画，应用重启。这就造成了应用无法关闭的状况，只能后台强制杀掉。解决办法就是让闪屏只执行一次。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.z16388.top/tags/Android/"}],"keywords":[]},{"title":"安卓各渠道SDK接入体验","slug":"mostsdk","date":"2019-11-12T15:00:23.000Z","updated":"2019-11-12T15:13:25.279Z","comments":true,"path":"2019/11/12/mostsdk/","link":"","permalink":"http://www.z16388.top/2019/11/12/mostsdk/","excerpt":"","text":"去年的这个时候，我在忙于接入各种SDK。接渠道SDK，是一件十分薛定谔的事情。你觉得很容易，的确很容易，但是，也很容易遇到问题。然后我就陷入了长期的自闭状态，再加上偷懒，然后博客就断更了一年。现在回头来回忆一下，去年的这个时候，接入SDK时的那些体验。 1.酷派 充值之后，服务器收不到消息，对接也没有人。 现在看来很明显，已然黄了。 2.应用宝 传说中的5000人大群只有2个技术的大渠道。每天上午问问题会施舍你两句，下午是肯定不会回答问题的，团建能团建半个月。这个渠道我是使用聚合sdk接入的。需要注意的是，接入时有测试阶段，和正式阶段之分，游戏货币名不能修改，同时还必须接入腾讯的信鸽推送SDK，否则无法过审，手动接入成本极高。 3.金立 高版本会造成初次进入闪退，主动获取权限也不行，必须低版本编译。华为手机会出现渲染错误，游戏变成紫红色。需要安装支付插件。现在也应该没有接入的必要了。 4.华为 相当棒的渠道，文档详细，对接起来体验也很不错。充值错误的时候，每一步骤，原因都会有显示。但是不支持第三方工具接入。需要安装支付插件。 5.魅族 商品id配置不明，会出现莫名的变动，很不靠谱。支付回调生效需要1天的时间，需要对商品进行映射，对接很麻烦的渠道。需要安装支付插件。 6.360 包体最大，足足有50多k的方法数，不分包就是死。 7.百度 方法数排名第二，仅次于360。高版本编译会无法使用闪屏。提审体验极差。说好的SDK不强用更，但是等到提审后告诉你不合格。 8.联想 商品id为自动生成，需要做好映射。AnySDK接入需要注意参数顺序。 9.UC 无法使用第三方工具进行接入。闪屏比较蛋疼，在sdk初始化时自动播放。首次运行时无法正常显示，时机不一定，容易和应用闪屏覆盖。 10.OPPO、VIVO 无法使用第三方工具进行接入。需要安装支付插件。 11.小七 文档描述不明确，注意对登陆回调的处理方式，注重切换账号的测试。SDK的Manifest中，最高宽高比设置为2.2。如果游戏中有对这个参数进行修改，需要进行统一。 12.拇指玩 sdk默认背景为透明，会造成有些版本的手机唤起sdk时会显示桌面为背景。或者是切换到主屏后，再回来，只有单独的sdk页面。解决方式是把style.xml中的windowIsTranslucent值置为为false。回调处理方式与其他sdk略有不同,Log与执行功能部分的代码进行了分离。目前版本，无法使用qq登陆等方式，在登陆界面仍没有去掉该入口。 其他: 在运营过程中，小米、UC、应用宝和魅族会不同频率出现无法登录的问题，属正常现象，是他们的SDK服务器抽风了，会报一些很可怕的错误，比如应用不存在，应用id无效之类的。这时候只需要稳定好用户的心态即可，没有任何解决办法。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.z16388.top/tags/Android/"}],"keywords":[]},{"title":"某微信爬虫工具多开方案","slug":"most_wechat","date":"2019-11-12T13:15:53.000Z","updated":"2019-11-12T13:28:07.569Z","comments":true,"path":"2019/11/12/most_wechat/","link":"","permalink":"http://www.z16388.top/2019/11/12/most_wechat/","excerpt":"","text":"之前因为需求找到了这个超级好用的微信爬虫工具https://github.com/striver-ing/wechat-spider，目前已经开源。工具可以很方便地实现爬取微信文章，获取点赞、评论等功能。 最近，微信针对文章历史接口做了调整：PC版限制了爬取的次数，访问间隔应该控制在8分钟以上，移动端则是在两个月前直接干掉了这个功能。文章评论则没有改变。因此，这个工具目前最好的使用方式就是多开，分别爬不同的文章，再单开一个用来爬需要爬的评论。 工具的具体使用方法在原工程中都有提到，这里就不再赘述了。 在工具的使用方法中，我们知道，作者是使用全局代理，将所有的https消息都强制走了本机的8080端口，然后通过Python的mitmproxy来截取消息内容来实现的这个工具。那么，我可以使用局部代理，将制定的微信客户端，走制定端口，即可实现工具的多开。 有了这个思路，那么我们就只需要解决两个问题： 微信的多开 多个微信走多个局部代理 这里先说一下，我们无法使用微信PC客户端自带的代理功能。因为一旦这个功能开启，微信的所有链接都将进行加密，你得到的只会是一个格式如：https://xxx.xxx.xx.xx/mmtls/xxxxxx的加密链接。 微信的多开微信多开的实现比较简单，直接使用bat脚本打开多个微信即可。需要注意的是，要以管理员模式运行。 1234567@echo offstart /d \"C:\\Program Files (x86)\\Tencent\\WeChat\\\" WeChat.exestart /d \"C:\\Program Files (x86)\\Tencent\\WeChat\\\" WeChat.exestart /d \"C:\\Program Files (x86)\\Tencent\\WeChat\\\" WeChat.exestart /d \"C:\\Program Files (x86)\\Tencent\\WeChat\\\" WeChat.exestart /d \"C:\\Program Files (x86)\\Tencent\\WeChat\\\" WeChat.exeexit 这样虽然可以打开多个微信，但是在设置局部代理时，工具无法区相同路径下的相同可执行文件。因此，我们需要把微信客户端拷贝多份，以应对后面的步骤。 1234567@echo offstart /d \"C:\\Program Files (x86)\\Tencent\\WeChat\\\" WeChat.exestart /d \"C:\\Program Files (x86)\\Tencent\\WeChatb\\\" WeChatb.exestart /d \"C:\\Program Files (x86)\\Tencent\\WeChatc\\\" WeChatc.exestart /d \"C:\\Program Files (x86)\\Tencent\\WeChatd\\\" WeChatd.exestart /d \"C:\\Program Files (x86)\\Tencent\\WeChate\\\" WeChate.exeexit 需要注意的是，这样配置之后的脚本将不一定百分百执行成功，可能只打开一个客户端。一般第二次即可执行成功。 局部代理这里，我使用了Proxifier工具，进行局部代理。这个工具很容易获取，x度上很容易就可以获取到免费破解汉化的版本。 安装之后，我们开始配置工作。 1.配置文件-&gt;代理服务器 这里地址填本机127.0.0.1，端口填你想要转发的端口，比如8080，8081，协议类型是HTTPS。你想开多少，就填多少个。 2.配置文件-&gt;代理规则 这里我们把默认的全局代理给关闭，双击条目，将“是否有效”取消勾选即可。然后添加微信的代理规则，点击添加，名称随意，应用程序浏览到微信的exe文件，目标主机清空，端口清空，然后在最下方的动作中选择你上一步配置的一个端口。那么这个路径下的客户端执行时，便会代理到这个端口下了。 微信多开之后，我们会发现多开的这几个的微信的进程名是一样的，无法进行区分。这时候可以在任务管理器中使用切换到、最小化等功能确定哪个窗口是哪个进程，转到本地文件来确定他是哪个目录下的。在开多个的时候，一定要注意区分，以防登错账号，影响爬取。 爬虫的配置文件中，我们最好使用不同的mysql数据库，以免产影响。当然，如果你修改了原工具的代码，那就另当别论了。","categories":[],"tags":[{"name":"微信","slug":"微信","permalink":"http://www.z16388.top/tags/微信/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.z16388.top/tags/爬虫/"}],"keywords":[]},{"title":"U3D问题总结（七） lua","slug":"unity7","date":"2019-10-29T15:00:07.000Z","updated":"2020-10-30T08:41:14.658Z","comments":true,"path":"2019/10/29/unity7/","link":"","permalink":"http://www.z16388.top/2019/10/29/unity7/","excerpt":"","text":"lua实现类的继承lua遍历查找某个数","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://www.z16388.top/tags/Unity/"}],"keywords":[]},{"title":"U3D问题总结（六） 优化","slug":"unity6","date":"2019-10-29T15:00:06.000Z","updated":"2020-10-30T04:31:19.171Z","comments":true,"path":"2019/10/29/unity6/","link":"","permalink":"http://www.z16388.top/2019/10/29/unity6/","excerpt":"","text":"请简述GC（垃圾回收）产生的原因，并描述如何避免（？ GC回收堆上的内存避免：1.减少new产生对象的次数2.使用公用的对象（静态成员）3.将String换为StringBuilder 如何优化内存？ 1.压缩自带类库；2.将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉；3.释放AssetBundle占用的资源；4.降低模型的片面数，降低模型的骨骼数量，降低贴图的大小；5.使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。6.代码中少产生临时变量 UNITY3d在移动设备上的一些优化资源的方法 1.使用assetbundle，实现资源分离和共享，将内存控制到200m之内，同时也可以实现资源的在线更新2.顶点数对渲染无论是cpu还是gpu都是压力最大的贡献者，降低顶点数到8万以下，fps稳定到了30帧左右3.只使用一盏动态光，不是用阴影，不使用光照探头粒子系统是cpu上的大头4.剪裁粒子系统5.合并同时出现的粒子系统6.自己实现轻量级的粒子系统animator也是一个效率奇差的地方7.把不需要跟骨骼动画和动作过渡的地方全部使用animation，控制骨骼数量在30根以下8.animator出视野不更新9.删除无意义的animator10.animator的初始化很耗时（粒子上能不能尽量不用animator）11.除主角外都不要跟骨骼运动apply root motion12.绝对禁止掉那些不带刚体带包围盒的物体（static collider ）运动NUGI的代码效率很差，基本上runtime的时候对cpu的贡献和render不相上下13每帧递归的计算finalalpha改为只有初始化和变动时计算14去掉法线计算15不要每帧计算viewsize 和windowsize16filldrawcall时构建顶点缓存使用array.copy17.代码剪裁：使用strip level ，使用.net2.0 subset18.尽量减少smooth group19.给美术定一个严格的经过科学验证的美术标准，并在U3D里面配以相应的检查工具 场景优化 1.遮挡剔除（Occlusion Culling） 不显示被遮挡住的物体2.LOD 根据相机距离远近显示不同精细程度的模型3.大场景可以调节相机可视距离4.小物体可以适当隐藏掉5.使用光照贴图 避免动态实时的进行光照计算，提高效率 UI优化 1.将同一画面图片放到同一图集中2.图片和文字尽量不要交叉，会产生多余drawcall（相同材质和纹理的UI元素是可以合并的）3.UI层级尽量不要重叠太多4.取消勾选不必要的射线检测RaycastTarget5.将动态的UI元素和静态的UI元素放在不同的Canvas中，减少canvas网格重构频率 GC优化 1.字符串使用StringBuilder而不是string，stringBuilder在创建时会自动获取一个容量存储并逐渐扩充，string每一次改变都会创建一个新的对象。2.访问物体tag的时候尽量使用Gameobject.CompareTag()，因为访问物体的tag属性会在堆上额外的分配空间3.使用对象池缓存大量创建的物体4.用for代替foreach，foreach每次迭代产生24字节垃圾内存","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://www.z16388.top/tags/Unity/"}],"keywords":[]},{"title":"U3D问题总结（五） 渲染与光照","slug":"unity5","date":"2019-10-29T15:00:05.000Z","updated":"2020-11-08T15:10:55.122Z","comments":true,"path":"2019/10/29/unity5/","link":"","permalink":"http://www.z16388.top/2019/10/29/unity5/","excerpt":"","text":"什么是渲染管道（？ 是指在显示器上为了显示出图像而经过的一系列必要操作。 渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。主要步骤有：本地坐标-&gt;视图坐标-&gt;背面裁剪-&gt;光照-&gt;裁剪-&gt;投影-&gt;视图变换-&gt;光栅化 对渲染管线的理解 渲染流水线流程：1.应用阶段（由CPU负责，输出是渲染所需要的几何信息，即渲染图元。然后发起Draw Call，进入GPU流水线）2.几何阶段（由GPU负责，处理渲染图元，这阶段中最重要的就是把顶点坐标变换屏幕空间中，交给光栅器处理这阶段输出的是屏幕空间中二维顶点坐标、每个顶点对应的深度值、着色等相关信息）3.光栅化阶段（由GPU，负责这一阶段会使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像）细节过程https://zhuanlan.zhihu.com/p/97498781 什么是DrawCall？DrawCall高了又什么影响？如何降低DrawCall？ Unity中，每次引擎准备数据并通知GPU的过程称为一次Draw Call。DrawCall越高对显卡的消耗就越大。降低DrawCall的方法： Dynamic Batching Static Batching 高级特性Shader降级为统一的低级特性的Shader。 什么是DrawCall，有什么方法可以减少DrawCall CPU通过调用绘制命令来告诉GPU开始进行一个渲染过程(一次DrawCall)。CPU方面减少DrawCall：1、使用Draw Call Batching 、Dynamic Batching动态批处理2、纹理打包成图集减少材质使用3、少用反光、阴影4、设置一个合适的Fixed Timestep5、不要使用网格碰撞器(Mesh Collider)6、大量或频繁的字符串连接操作一定要用StringBuilder7、某些可能情况，使用结构体代替类8、使用对象池重复利用空间9、尽量不要用foreach，用for10、不要直接访问GameObjcet的tag属性11、不要频繁使用GetComponent，访问一次后保留其引用12、使用OnBecameVisible()和OnBecameInVisible()，控制物体update()函数的执行减少开销13、使用内建数组，如Vector3.zero而不是new Vector3(0,0,0)14、使用ref关键字对方法的参数进行优化15、关闭所有update中的log操作16、不在update中调用GetComponent、SendMessage、FindWithTag等方法17、不在update中使用临时变量 GPU方面减少DrawCall 1、使用纹理图集代替一系列单独小贴图2、保持材质数目尽可能少3、如果使用纹理图集和共享材质，用Renderer.sharedMaterial代替Renderer.material4、使用光照纹理(lightmap)而非实时灯光5、使用LOD6、使用mobile版的shader7、尽可能减少顶点数、背面删减8、压缩图片，减少显存带宽压力 什么是material，什么是shader，二者有什么关系 材质系统定义了如何渲染物件表面信息。shader里面使用材质信息加自身操作，最终呈现物体渲染。shader是material一部分，是根据计算即时演算生成贴图的程序，叫着色器。常用处理无法用固定贴图表现的模型。material是模型的材质，包含贴图、shader、顶点、凹凸等信息。 如何在Unity3D中查看场景的面数，顶点数和Draw Call数？如何降低Draw Call数 在Game视图右上角点击Stats。降低Draw Call 的技术是Draw Call Batching这个在5.0以后在window-》Profiler下面，快捷键是cmd + 7（ctl + 7 DrawCall和SetPass Call DrawCall：meshes网格绘制应用批处理后的总数。请注意，在多次呈现对象(例如，由像素灯照明的对象)，每个在一个单独的渲染结果绘制调用。 SetPass Call：渲染改变（ passes）次数。每个改变 需要Unity运行时绑定一个新的渲染器（shader），它可能会引入 CPU 开销。 Unity3D Shader分哪几种，有什么区别 表面着色器的抽象层次比较高，它可以轻松地以简洁方式实现复杂着色。表面着色器可同时在前向渲染及延迟渲染模式下正常工作。顶点片段着色器可以非常灵活地实现需要的效果，但是需要编写更多的代码，并且很难与Unity的渲染管线完美集成。固定功能管线着色器可以作为前两种着色器的备用选择，当硬件无法运行那些酷炫Shader的时，还可以通过固定功能管线着色器来绘制出一些基本的内容。 有A和B两组物体，有什么办法能够保证A组物体永远比B组物体先渲染？ 把A组物体的渲染队列大于B物体的渲染队列，通过shader里面的渲染队列来渲染 问一个Terrain，分别贴3张，4张，5张地表贴图，渲染速度有什么区别？为什么？ 没有区别，因为不管几张贴图只渲染一次。 LOD是什么，优缺点(? LOD(Level of detail)多层次细节，是最常用的游戏优化技术。它按照模型的位置和重要程度决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。缺点是增加了内存。 MipMap是什么，作用(? MipMapping：在三维计算机图形的贴图渲染中有常用的技术，为加快渲染进度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为MipMap。 什么是LightMap LightMap:就是指在三维软件里实现打好光，然后渲染把场景各表面的光照输出到贴图上，最后又通过引擎贴到场景上，这样就使物体有了光照的感觉。 alpha blend工作原理 Alpha Blend 实现透明效果，不过只能针对某块区域进行alpha操作，透明度可设。 alpha blend 用于做半透明效果。Color = (源颜色 源系数) OP ( 目标颜色 目标系数);其中OP（混合方式）有加，减，反减，取最小，取最大 Unity的Shader中，Blend SrcAlpha OneMinusSrcAlpha这句话是什么意思 作用就是Alpha混合。公式：最终颜色 = 源颜色 x 源透明值 + 目标颜色 x（1 - 源透明值） alpha test在何时使用？能达到什么效果 Alpha Test ,中文就是透明度测试。简而言之就是V&amp;F shader中最后fragment函数输出的该点颜色值（即上一讲frag的输出half4）的alpha值与固定值进行比较。AlphaTest语句通常于Pass{}中的起始位置。Alpha Test产生的效果也很极端，要么完全透明，即看不到，要么完全不透明。 Vertex Shader是什么，怎么计算 顶点着色器是一段执行在GPU上的程序，用来取代fixed pipeline中的transformation和lighting，Vertex Shader主要操作顶点。Vertex Shader对输入顶点完成了从local space到homogeneous space（齐次空间）的变换过程，homogeneous space即projection space的下一个space。在这其间共有world transformation, view transformation和projection transformation及lighting几个过程。 写出光照计算中的diffuse（漫反射）的计算公式 diffuse = Kd x colorLight x max(N*L,0)；Kd 漫反射系数、colorLight 光的颜色、N 单位法线向量、L 由点指向光源的单位向量、其中N与L点乘，如果结果小于等于0，则漫反射为0。 12345678910111213141516171819202122232425答：漫反射光(diffuse)计算公式为：Idiffuse = Dintensity*Dcolor*N.L ; (Dintensity表示漫反射强度，Dcolor表示漫反射光颜色，N为该点的法向量，L为光源向量) 其他，3D渲染中，物体表面的光照计算公式为：I = 环境光(Iambient) + 漫反射光(Idiffuse) + 镜面高光(Ispecular); 其中，环境光(ambient)计算公式为：Iambient= Aintensity* Acolor; (Aintensity表示环境光强度，Acolor表示环境光颜色) 漫反射光(diffuse)计算公式为：Idiffuse = Dintensity*Dcolor*N.L ; (Dintensity表示漫反射强度，Dcolor表示漫反射光颜色，N为该点的法向量，L为光源向量)镜面光照(specular)计算公式为：Ispecular = Sintensity*Scolor*(R.V)n; (Sintensity表示镜面光照强度，Scolor表示镜面光颜色，R为光的反射向量，V为观察者向量)综上所得：整个光照公式为：I = Aintensity* Acolor+ Dintensity*Dcolor*N.L + Sintensity*Scolor*(R.V)n ;将一些值合并，并使用白色作为光照颜色，则上述公式可简化为：I = A + D*N.L + (R.V)n MeshRender中material和sharedmaterial的区别(? 修改sharedMaterial将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使用material替代。 简述水面倒影的渲染原理 原理就是对水面的贴图纹理进行扰动，以产生波光玲玲的效果。用shader可以通过GPU在像素级别作扰动，效果细腻，需要的顶点少，速度快 什么叫动态合批？跟静态合批有什么区别 如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要你进行额外的操作。区别：动态批处理一切都是自动的，不需要做任何操作，而且物体是可以移动的，但是限制很多。静态批处理：自由度很高，限制很少，缺点可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了。 两种阴影判断的方法、工作原理。 本影：景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域）。半影：景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域）工作原理：从光源处向物体的所有可见面投射光线，将这些面投影到场景中得到投影面，再将这些投影面与场景中的其他平面求交得出阴影多边形，保存这些阴影多边形信息，然后再按视点位置对场景进行相应处理得到所要求的视图（利用空间换时间，每次只需依据视点位置进行一次阴影计算即可，省去了一次消隐过程） Unity提供了几种光源，分别是什么 四种。平行光：Directional Light点光源：Point Light聚光灯：Spot Light区域光源：Area Light 实时点光源的优缺点是什么 可以有cookies – 带有 alpha通道的立方图(Cubemap )纹理。点光源是最耗费资源的。 GPU的工作原理 简而言之，GPU的图形（处理）流水线完成如下的工作：（并不一定是按照如下顺序） 顶点处理：这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建立起3D图形的骨架。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Vertex Shader（定点着色器）完成。 光栅化计算：显示器实际显示的图像是由像素组成的，我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。 纹理帖图：顶点单元生成的多边形只构成了3D物体的轮廓，而纹理映射（texture mapping）工作完成对多变形表面的帖图，通俗的说，就是将多边形的表面贴上相应的图片，从而生成“真实”的图形。TMU（Texture mapping unit）即是用来完成此项工作。 像素处理：这阶段（在对每个像素进行光栅化处理期间）GPU完成对像素的计算和处理，从而确定每个像素的最终属性。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Pixel Shader（像素着色器）完成。 最终输出：由ROP（光栅化引擎）最终完成像素的输出，1帧渲染完毕后，被送到显存帧缓冲区。总结：GPU的工作通俗的来说就是完成3D图形的生成，将图形映射到相应的像素点上，对每个像素进行计算确定最终颜色并完成输出。 图形学光照模型有哪些3维模型组成Mesh Mesh下面有哪些字段如向将文理贴在模型上图片向格式有那些","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://www.z16388.top/tags/Unity/"}],"keywords":[]},{"title":"U3D问题总结（四） 物理相关","slug":"unity4","date":"2019-10-29T15:00:04.000Z","updated":"2020-10-30T08:41:37.006Z","comments":true,"path":"2019/10/29/unity4/","link":"","permalink":"http://www.z16388.top/2019/10/29/unity4/","excerpt":"","text":"射线检测碰撞物的原理是 射线是3D世界中一个点向一个方向发射的一条无终点的线，在发射轨迹中与其他物体发生碰撞时，它将停止发射 。 Unity3d中的碰撞器和触发器的区别？ 碰撞器是触发器的载体，触发器是碰撞器的属性Is Trigger=false，碰撞器根据物理引擎引发碰撞，产生碰撞的效果此时调用OnCollisionEnter/Stay/Exit函数Is Trigger=true，碰撞器被物理引擎所忽略，没有碰撞效果此时调用OnTriggerEnter/Stay/Exit函数 发生碰撞的必要条件 两个物体都必须带有碰撞器（Collider）其中至少有一个物体带有刚体（Rigidbody）或者角色控制器（CharacController）必须是运动的物体带有Rigidbody脚本才能检测到碰撞 物体发生碰撞的过程有几个阶段 1.OnCollisionEnter2.OnCollisionStay3.OnCollisionExit 当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？ 穿透（碰撞检测失败）1）增大细小物体的碰撞体（不建议这样做）（2）使用射线检测，检测他们之间的距离（3）FixedUpdate频率修改，可以physics time减小（同样不建议）（4）改变物体的速度（废话）（5）将检测方式改为连续检测，rigifdbody.collisionDetectionMode =CollisionDetectionMode.Continuous;或者是动态连续检测（CollisionDetectionMode.ContinuousDynamic）（6）代码限制，加大计算量 提前计算好下一个位置 Unity3d物理引擎中，有几种施加力的方式（？ rigidbody.AddForce/AddForceAtPosition，都在rigidbody系列函数中 CharacterController和Rigdibody的区别 Rigidbody：刚体组件、用于模拟真实的物理效果、可以受到重力和其他力的作用、这个力可以直接施加、也可以来自其他刚体的碰撞CharacterController：角色控制组件，它自带一个胶囊控制器，能够受到重力的影响。移动时使用自身的Move()、SimpleMove()方法 Rigidbody具有完全真实物理的特性，Unity中物理系统最基本的一个组件，包含了常用的物理特性，而CharacterController可以说是受限的的Rigidbody，具有一定的物理效果但不是完全真实的，是Unity为了使开发者能方便的开发第一人称视角的游戏而封装的一个组件 什么叫做链条关节(？ Hinge Joint，可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力。","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://www.z16388.top/tags/Unity/"}],"keywords":[]},{"title":"U3D问题总结（三） Unity基础","slug":"unity3","date":"2019-10-29T15:00:03.000Z","updated":"2020-10-30T09:46:16.673Z","comments":true,"path":"2019/10/29/unity3/","link":"","permalink":"http://www.z16388.top/2019/10/29/unity3/","excerpt":"","text":"Unity基础Unity和Android与iOS如何交互 Unity可以导出安卓和IOS的工程。导出的工程有Unity封装的方法，可以通过发消息的方式跟Unity进行交互。其中，C#不能与OC直接进行交互，需要用C++去写。 Unity3D支持的作为脚本的语言 C#、JS、Boo Unity中用过哪些插件？具体功能 NGUI，制作2D界面 Helpshift，帮助与提示 KTPlay，游戏论坛 UniClipboard，粘贴板 Unity中常用的插件（Δ）Unity引擎使用的是左手坐标系还是右手坐标系（A） A.左手坐标系 B.右手坐标系C.可以通过ProjectSetting切换右手坐标系 D.可以通过Reference切换左手坐标系 什么是导航网格（NavMesh）（B） A.一种用于描述相机轨迹的网格 B.一种用于实现自动寻址的网格C.一种被优化过的物体网格 D.一种用于物理碰撞的网格 生命周期OnEnable、Awake、Start运行时发生的顺序，哪些可以在同一周期中重复发生 Awake-&gt;OnEnable-&gt;StartOnEnable可以在同一周期中重复发生 生命周期顺序 Awake——&gt;OnEnable–&gt;Start——&gt;Update——&gt;FixedUpdate——&gt;LateUpdate——&gt;OnGUI——&gt;OnDisable——&gt;OnDestroy Awake() 脚本唤醒，系统执行的第一个方法，用于脚本初始化，只执行一次。 Start()在Awake之后、Update之前执行，只执行一次。 Update()用于逻辑正常更新，每帧由系统自动调用一次。 FixedUpdate()固定更新。 LateUpdate()推迟更新，每帧调用，在Update之后调用。 OnGUI() 每帧可能会被绘制多次，每次对应于一个 GUI event OnDestroy()当前脚本销毁时调用。 12.以下关于 MonoBehaviour.OnGUI()的描述错误的是（D） A.如果 MonoBehaviour 没有被启用，则OnGUI函数不会被调用B.用于绘制和处理 GUI eventsC.每帧可能会被绘制多次，每次对应于一个 GUI eventD.每帧被调用一次 Addcomponent后哪个生命周期函数会被调用？ 对于AddComponent添加的脚本，其Awake，Start，OnEnable是在Add的当前帧被调用的，其中Awake，OnEnable与AddComponent处于同一调用链上，Start会在当前帧稍晚一些的时候被调用。Update则是根据Add调用时机决定何时调用：如果Add是在当前帧的Update前调用，那么新脚本的Update也会在当前帧被调用，否则会被延迟到下一帧调用。https://blog.csdn.net/qq_32821435/article/details/94760815 物理更新一般放在哪个系统函数里 FixedUpdate。update跟当前平台的帧数有关，而FixedUpdate是真实时间 Update和FixedUpdate的区别？ Update是在每次渲染新的一帧的时候会调用，FixedUpdate，是在固定的时间间隔执行，不受游戏帧率的影响。FixedUpdate的时间间隔可以在项目设置中更改，Edit-&gt;ProjectSetting-&gt;time 找到Fixedtimestep。 移动相机动作在哪个函数里，为什么在这个函数里 LateUpdate，是在所有的update结束后才调用，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是所有的update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。 关于 MonoBehaviour.LateUpdate 函数描述错误的是：（B） A.当 MonoBehaviour 类被启用后，每帧调用一次B.常被用于处理 Rigidbody 的更新C.在所有 Update 函数执行后才能被调用D.常被用于实现跟随相机效果，且目标物体的位置已经在 Update 函数中被更新 应该放在FixedUpdate 如何让已经存在的GameObject在LoadLevel后不被卸载掉1234void Awake()&#123; DontDestroyOnLoad(transform.gameObject);&#125; 脚本及编辑器命名空间 unityEngne 9.在哪个面板中可以修改物体的空间属性，如位置，朝向，大小等（B） A.Project B.Inspector C.Hierarchy D.Toolbar 如何为一个Asset 资源设定一个Label，从而能够方便准确的搜索到？（D） A.在Project窗口中选中一个Asset，右键-&gt;Create-&gt;LabelB.在Project窗口中选中一个Asset，右键-&gt;Add LabelC.在Project窗口中选中一个Asset，在Inspector窗口中点击添加Label的图标D.在Project窗口中选中一个Asset，在Inspector窗口中点击按钮“Add Label” 5.Application.loadLevel命令为（A） A.加载关卡 B.异步加载关卡 C.加载动作 D.加载动画 将图片的TextureType选项分别选为“Texture”和“Sprite”有什么区别 Sprite作为UI精灵使用，Texture作用模型贴图使用。Sprite需要2的整次幂，打包图片省资源 为什么dynamic font在unicode环境下优于static font（？ Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。使用动态字体时，Unity将不会预先生成一个与所有字体的字符纹理。当需要支持亚洲语言或者较大的字体的时候，若使用正常纹理，则字体的纹理将非常大。 OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义 当物体是否可见切换之时。可以用于只需要在物体可见时才进行的计算。 采用Input.mousePosition 来获取鼠标在屏幕上的位置，以下表达正确的是（C） A.左上角为原点（0，0），右下角为（Screen.Width, Screen.Height）B.左下角为原点（0，0），右下角为（Screen.Height, Screen.Width）C.左下角为原点（0，0），右上角为（Screen.Width, Screen.Height）D.左上角为原点（0，0），右下角为（Screen.Height, Screen.Width） 物体自身旋转使用的函数？ Transform.Rotate() 物体绕某点旋转使用函数叫什么？ transform.RotateAround() 以下选项中，将游戏对象绕Z轴逆时针旋转90度（C） A.transform.rotation = Quaternion.Euler(0,0,90)B.transform.rotation = Quaternion.Angle(0,0,90)C.transform.Rotate(new Vector3(0,0,90))D.transform.Rotate(new Vector3(90,0,0)) 游戏对象B是游戏对象A的子物体，游戏对象A经过了旋转，请写出游戏B围绕自身的Y轴进行旋转的脚本语句，以及游戏对象B围绕世界坐标的Y轴旋转的脚本语句 绕世界坐标旋转：transform.Rotate (transform.upspeedTime.deltatime);绕自身Y轴旋转：transform.Rotate (Vector.upspeedTime.deltatime); U3D中用于记录节点空间几何信息的组件名称，及其父类名称 Transform 父类是 Component 关于Vector3 的API，以下说法正确的是（BC） A.Vector3.normalize 可以获取一个三维向量的法线向量B.Vector3.magnitude 可以获取一个三维向量的长度C.Vector3.forward 与 Vector3(0,0,1)是一样的意思D.Vector3.Dot(向量A,向量B)是用来计算向量A与向量B的叉乘 以下哪个函数在游戏进入新场景后会被马上调用（B） A.MonoBehaviour.OnSceneWastLoaded()B.MonoBehaviour.OnSceneEnter()C.MonoBehaviour.OnLevelEnter()D.MonoBehaviour.OnLevelWastLoaded() 14.在Unity引擎中，Collider所指的是什么（D） A.collider 是Unity引擎中所支持的一种资源，可用作存储网格信息B.Collider 是Unity引擎中内置的一种组件，可用对网格进行渲染C.Collider 是Unity引擎中所支持的一种资源，可用作游戏对象的坐标转换D.Collider 是Unity引擎中内置的一种组件，可用作游戏对象之间的碰撞检测 下列选项中，关于Transform组件的Scale参数描述正确的是（A） A.Transform组件的Scale参数不会影响ParticleSystem产生粒子的大小B.Transform组件的Scale参数不会影响GUITexture的大小C.添加Collider组件后的GameoObject，其 Collider 组件的尺寸不受Transform组件的Scale参数影响D.添加Rigidbody组件后的物体，大小将不再受Transform组件中 Scale 参数的影响 如何销毁一个UnityEngine.Object及其子类 Destroy()方法 DestroyImmediate和Destroy的区别 DestroyImmeditate 销毁对象的时候，会立即释放资源。Destroy只是从该场景销毁，但是还在内存当中。 在编辑场景时将GameObject设置为Static有何作用 设置游戏对象为Static时，这些部分被静态物体挡住而不可见时，将会剔除（或禁用）网格对象。因此，在你的场景中的所有不会动的物体都应该标记为Static。 如何通过脚本来删除其自身对应的Gameobject（A） A.Destroy(gameObject) B.this.Destroy()C.Destroy(this) D.其他三项都可以 某个GameObject有一个名为MyScript的脚本，该脚本中有一个名为DoSomething 的函数，则如何在该Gameobject的另外一个脚本中调用该函数？（A） A.GetComponent().DoSomething()B.GetComponentC.GetComponent().Call(“DoSomething”)D.GetComponent CompareTag比直接用gameObject.tag要好简述一下对象池 对象池就存放需要被反复调用资源的一个空间，当一个对象回大量生成的时候如果每次都销毁创建会很费时间，通过对象池把暂时不用的对象放到一个池中（也就是一个集合），当下次要重新生成这个对象的时候先去池中查找一下是否有可用的对象，如果有的话就直接拿出来使用，不需要再创建，如果池中没有可用的对象，才需要重新创建，利用空间换时间来达到游戏的高速运行效果，在FPS游戏中要常被大量复制的对象包括子弹，敌人，粒子等 对象池使用什么数据结构构建频繁创建GameObject会降低程序性能为什么？怎么解决？ 频繁创建游戏对象，会增加游戏的Drawcall数，降低帧率，GPU会一直在渲染绘制。可以通过对象池来管理对象：当需要创建一个游戏对象时，先去对象池中查找一下对象池中是否存在没有被正在使用的对象，如果有的话直接使用这个对象，并把它标记为正在使用，没有话就创建一个，并把它添加到池中，然后标记为使用中。一个游戏对象使用完毕的时候，不要销毁掉，把它放在池中，标记为未使用。 如何在Unity中创建地形系统？(D) A.Terrain-&gt;Create Terrain B.Component-&gt;Create TerrainC.Asset-&gt;Create Terrain D.Windows-&gt;Create Terrain 资源相关当删除Unity工程Assets目录下地meta文件时会导致什么？为什么？ 会导致在场景中游戏对象看不到，或者报错，材质找不到资源。多人协作的时候会导致资源的重复产生。因为每个资源文件都对应一个.meta文件，这个.meta文件中的guid就是唯一标识这个资源的。材质就是通过这个guid来记录自己使用了那些资源，而且同一个资源的guid会因为不同的电脑而不同，所以当你上传了丢失了.meta文件的资源的时候，到了别人的机器上就会重新产生guid，那个这个资源就相当于垃圾了。 meta文件的作用prefab的作用 在游戏运行时实例化。Prefab相当于一个模板，对已有的素材、脚本和参数做一个基础的配置，便于以后的修改 Prefab打包的内容简化了导出操作，便于团队协同 下列叙述中有关 Prefab 说法错误的是哪一项（B） A.Prefab 是一种资源类型 B.Prefab 是一种可以反复使用的游戏对象C.Prefab 可以多次在场景进行实例 D.当一个 Prefab 添加到场景中时，也就是创建了它的一个实例 资源加载方式 1.Resources2.AssetBundle3.AssetDatabase 资源数据库 (AssetDatabase) 资源数据库 (AssetDatabase) 是允许您访问工程中的资源的 API。此外，其提供方法供您查找和加载资源，还可创建、删除和修改资源。Unity 编辑器 (Editor) 在内部使用资源数据库 (AssetDatabase) 追踪资源文件，并维护资源和引用资源的对象之间的关联。Unity 需要追踪工程文件夹发生的所有变化，如需访问或修改资源数据，您应始终使用资源数据库 (AssetDatabase) API，而非文件系统。 资源数据库 (AssetDatabase) 接口仅适用于编辑器，不可用于内置播放器。和所有其他编辑器类一样，其只适用于置于编辑器 (Editor) 文件夹中的脚本（只在主要的资源 (Assets) 文件夹中创建名为“编辑器”的文件夹（不存在该文件夹的情况下））。 什么是AssetBundle?谈谈对AssetBundle内存分配情况的理解 可以把多个游戏对象或资源二进制文件封装到AssetBundle中，提供封装与解包的方法使用很方便。 加载资源三个步骤： www/LoadFromFile/LoadFromMemory等接口加载AssetBundle本身 AssetBundle.LoadAsset()等接口从AssetBundle中加载资源 对于GameObject类资源，需要通过GameObject.Instantiate()创建Clone 黑色区域：www类本身占用内存，还保留了一份对WebStream数据的引用。使用www = null或www.dispose()释放。前者等待GC，后者立即释放。释放后WebStream引用计数会减一。 橙色区域：WebStream数据，数据真正的存储区域。AssetBundle被加载进来后，这部分内存就被分配了。包含三个内容：1、压缩后的AssetBundle本身。2、解压后的资源。3、一个解压缓冲区。www或AssetBundle对象都只是有一个结构指向了WebStream数据，从而对外部提供操作真正资源数据的方法。当WebStream数据引用为0时，系统会自动释放。为了不频繁的开辟和销毁解压Buffer，绿色Decompression解压缓冲区Unity会至少保留一份。 粉色区域：AssetBundle对象，引用WebStream数据部分，提供从WebStream数据中加载资源的接口。AssetBundle.Unload(bool unloadAllLoadedObjects)释放资源。AssetBundle.Unload(false)释放AssetBundle对象本身，可能引起WebStream释放，导致无法通过接口或依赖关系从该AssetBundle加载资源，但已加载资源可以正常使用。AssetBundle(true)不仅释放WebStream部分，所有被加载出来的资源将被释放。 红色部分：通过Instantiate()创建的GameObject所包含的资源。这些资源根据类型与AssetBundle原始资源(WebStream资源部分)有不同关系。如Texture、shader资源，通常只是使用，不会做出改动，所以仅仅是引用关系；每个GameObject是特殊的，所以是完全复制一份；Mesh和Material，则是引用+复制的关系。 动态加载资源的方式 区别 1.Resources.Load();2.AssetBundle 1.通过Resources模块，调用它的load函数：可以直接load并返回某个类型的Object，前提是要把这个资源放在Resource命名的文件夹下，Unity不关有没有场景引用，都会将其全部打入到安装包中。2.通过bundle的形式：即将资源打成 asset bundle 放在服务器或本地磁盘，然后使用WWW模块get 下来，然后从这个bundle中load某个object。 以下关于WWW.LoadFromCacheOrDownload描述正确的是（C） A.可被用于将 Text Assets 自动缓存到本地磁盘B.可被用于将 Resource 自动缓存到本地磁盘C.可被用于将 Asset Bundles 自动缓存到本地磁盘D.可被用于将任意格式的Unity资源文件自动缓存到本地磁盘 如何安全地在不同工程间安全地迁移asset数据（？ 将Assets目录和Library目录一起迁移 导出包，export Package 用unity自带的assets Server功能 或者meta功能 AssetBundle包加载流程图集打包怎么分类 1.按业务功能的预制，寻找依赖，收集所有预制引用的图片，2.如果有多个预制使用了同一张图片，我们就把它扔到common文件夹3.让图集尽量紧凑，没有太多空白，尽量让图集处于2的n次方大小 为什么Unity3d中会发生在组件上出现数据丢失的情况(? 组件上绑定的物体对象被删除了 UI与CameraUGUI的Canvas的作用 Canvas画布是承载所有UI元素的区域。所有的UI元素都必须是Canvas的子对象。如果场景中没有画布，那么我们创建任何一个UI元素，都会自动创建画布，并且将新元素置于其下。 创建Canvas：GameObject-&gt;UI-&gt;Canvas 如何实现UI界面的层级Unity3d实现2d游戏，有几种方式 使用自身的GUI 把摄像机的Projection（投影）值调整为Orthographic（正交投影），不考虑z轴 使用2d的ui插件：2DToolKit、NGUI等 为何大家都在移动设备上寻求U3D原生GUI的替代方案 不美观，OnGUI很耗费时间，效率不高，使用不方便 如何在不同分辨率下保持UI的一致性(? NGUI很好的解决了这一点，屏幕分辨率的自适应性，原理就是计算出屏幕的宽高比跟原来的预设的屏幕分辨率求出一个对比值，然后修改摄像机的size。UGUI通过锚点和中心点和分辨率也解决这个问题 ngui和ugui的区别简述NGUI中Grid和Table的作用 对Grid和Table下的子物体进行排序和定位 请简述NGUI中Panel和Anchor的作用 只要提供一个half-pixel偏移量，它可以让一个控件的位置在Windows系统上精确的显示出来（只有这个Anchor的子控件会受到影响） 如果挂载到一个对象上，那么他可以将这个对象依附到屏幕的角落或者边缘3.UIPanel用来收集和管理它下面所有widget的组件。通过widget的geometry创建实际的draw call。没有panel所有东西都不能够被渲染出来,你可以把UIPanel当做Renderer UGUI中Image和RawImage的区别 Imgae比RawImage更消耗性能Image只能使用Sprite属性的图片，但是RawImage什么样的都可以使用Image适合放一些有操作的图片，裁剪平铺旋转什么的，针对Image Type属性RawImage就放单独展示的图片就可以，性能会比Image好很多 在场景中放置多个Camera并同时处于活动状态会发生什么(？ 游戏界面可以看到很多摄像机的混合。可以用depth（深度），Layer（层）+ Culling Mask,enable = false/true来控制 照相机的Clipping Planes的作用是什么？调整Near、Fare两个值时，应该注意什么 剪裁平面 。从相机到开始渲染和停止渲染之间的距离。 将Camera组件的ClearFlags选项选成Depth only是什么意思？有何用处 如果把摄像机的ClearFlags勾选为Deapth Only,那么摄像机就会只渲染看得见的对象，把背景会完全透明，这种情况一般用在两个摄像机以上的场景中 在 Unity 中的场景中创建 Camera 时，默认情况下除了带有Transform、Camera、GUILayer、Flare Layer 组件之外，还带有以下哪种组件（C） A.Mouse Look B.FPS Input Controller C.Audio Listener D.Character Motor 以下哪组摄像机中 Normalized View Port Rect 的数值设置可以使摄像机显示的画面位于1280*720分辨率的屏幕画面右上角（D） A.X=640,Y=360,W=640,H=360 B.X=640,Y=0,W=640,H=360C.X=0,Y=0,W=0.5,H=0.5 D.X=0.5,Y=0.5,W=0.5,H=0.5 多媒体如果将一个声音剪辑文件从Project 视图拖动到 Inspector 视图或者 Scene 视图中的游戏对象上，该游戏对象会自动添加以下哪种组件（C） A.Audio Listener B.Audio Clip C.Audio Source D.Audio Reverb Zone 以下哪一个选项不属于Unity引擎所支持的视频格式文件（D） A.后缀为mov的文件 B.后缀为mpg的文件C.后缀为avi的文件 D.后缀为swf的文件 请描述游戏动画有哪几种 主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活，Quake2中使用这种动画；骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，有关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观；单一网格模型动画由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。 下列选项中有关Animator的说法错误的是？（D） A.Animator是Unity引擎中内置的组件B.任何一个具有动画状态机功能的GameObject都需要一个Anim组件C.它主要用于角色行为的设置，包括StateMachine、混合树BlendTrees以及同通过脚本控制的事件D.Animator同Animation组件的用法是相同的 Animator.CrossFade 命令作用是：（B） A.动画放大 B.动画转换 C.Update() D.OnMouseButton() Animation和Animator的区别 Animation需要通过代码手动控制动画的播放和迁移。而Animator拥有有动画状态机，可以通过动画状态机来设置动画之间的状态，并且可以为单个动画设置脚本代码来控制事件。 其他Unity3d提供了一个用于保存和读取数据的类(PlayerPrefs)，请列出保存和读取整形数据的函数 PlayerPrefs.SetInt(string, int) PlayerPrefs.GetInt(string) Unity3D是否支持写成多线程程序？如果支持的话需要注意什么 仅能从主线程中访问Unity3D的组件，对象和Unity3D系统调用支持：如果同时你要处理很多事情或者与Unity的对象互动小可以用thread,否则使用coroutine。注意：C#中有lock这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象 Unity3D的协程和C#线程之间的区别是什么？ 多线程程序同时运行多个线程 ，而在任一指定时刻只有一个协程在运行，并且这个正在运行的协同程序只在必要时才被挂起。除主线程之外的线程无法访问Unity3D的对象、组件、方法。Unity3d没有多线程的概念，不过unity也给我们提供了StartCoroutine（协同程序）和LoadLevelAsync（异步加载关卡）后台加载场景的方法。 StartCoroutine为什么叫协同程序呢，所谓协同，就是当你在StartCoroutine的函数体里处理一段代码时，利用yield语句等待执行结果，这期间不影响主程序的继续执行，可以协同工作。","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://www.z16388.top/tags/Unity/"}],"keywords":[]},{"title":"U3D问题总结（二） 线性代数与算法","slug":"unity2","date":"2019-10-29T15:00:02.000Z","updated":"2020-10-30T08:40:50.670Z","comments":true,"path":"2019/10/29/unity2/","link":"","permalink":"http://www.z16388.top/2019/10/29/unity2/","excerpt":"","text":"线性代数向量的点乘、叉乘以及归一化的意义 1.点乘描述了两个向量的相似程度，结果越大两向量越相似，还可表示投影2.叉乘得到的向量垂直于原来的两个向量3.标准化向量：用在只关系方向，不关心大小的时候 叉乘：几何意义：得到一个与这两个向量都垂直的向量，这个向量的模是以两个向量为边的平行四边形的面积在同一平面内， 结果 &gt; 0 表示 B在A的逆时针方向， 结果 &lt;0 表示B在A的顺式针方向， 结果 = 0表示B与A同向应用：计算两个向量方向的点乘：几何意义：可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影两个向量的点乘所得到的是两个向量的余弦值，也就是-1 到1之间，0表示垂直，-1表示相反，1表示相同方向。应用：计算两个向量方向的夹角 矩阵相乘的意义及注意点 用于表示线性变换：旋转、缩放、投影、平移、仿射注意矩阵的蠕变：误差的积累 简述四元数的作用，四元数对欧拉角的优点 四元数用于表示旋转相对欧拉角的优点：1.能进行增量旋转2.避免万向锁3.给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式） 算法","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://www.z16388.top/tags/Unity/"}],"keywords":[]},{"title":"U3D问题总结（一） 计算机基础与C#","slug":"unity1","date":"2019-10-29T15:00:01.000Z","updated":"2020-10-30T08:34:32.708Z","comments":true,"path":"2019/10/29/unity1/","link":"","permalink":"http://www.z16388.top/2019/10/29/unity1/","excerpt":"","text":"计算机概述序列化 定义：将对象的状态信息转换为可以存储或传输的形式的过程。与序列化相对的是反序列化，它将流转换为对象。 目的：当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，以便将来使用时都需要把对象进行序列化 对象序列化：1.把对象转换为字节序列的过程称为对象的序列化2.把字节序列恢复为对象的过程称为对象的反序列化 比如，可以序列化一个对象，然后使用HTTP通过Internet在客户端和服务器端之间传输该对象 什么是协同程序(？ A coroutine is a function that is executed partially and, presuming suitable conditions are met, will be resumed at some point in the future until its work is done. 协程是一个分部执行，遇到条件（yield return 语句）会挂起，直到条件满足才会被唤醒继续执行后面的代码。Unity在每一帧（Frame）都会去处理对象上的协程。Unity主要是在Update后去处理协程 123456789101112131415161718using UnityEngine; using System.Collections; public class CoroutineCountdown : MonoBehaviour &#123; void Start() &#123; StartCoroutine(Countdown()); &#125; IEnumerator Countdown() &#123; for(floattimer = 3; timer &gt;= 0; timer -= Time.deltaTime) Yield return 0; Debug.Log(&quot;This message appears after 3 seconds!&quot;); &#125; &#125; yield return的常见返回值及其作用：1234567yield return new WaitForSeconds(3.0f); // 等待3秒，然后继续从此处开始，常用于做定时器yield return null; // 这一帧到此暂停，下一帧再从暂停处继续，常用于循环中yield return new WaitForEndOfFrame(); // 等到这一帧的cameras和GUI渲染结束后再从此处继续，即等到这帧的末尾再往下运行。这行之后的代码还是在当前帧运行，是在下一帧开始前执行，跟return null很相似yield return new WaitForFixedUpdate(); // 在下一次执行FixedUpdate的时候继续执行这段代码，即等一次物理引擎的更新yield return www; // 等待直至异步下载完成yield break; // 直接跳出协程，对某些判定失败必须跳出的时候，比如加载AssetBundle的时候，WWW失败了，后边加载bundle没有必要了，这时候可以yield break跳出。yield return StartCoroutine(methodName); // 等待另一个协程执行完。这是把协程串联起来的关键，常用于让多个协程按顺序逐个运行 协程的开启关闭 开启： StartCoroutine(string methodName) StartCoroutine（IEnumerator method) 终止： StopCoroutine (string methodName) // 只能终止指定的协程在程序中调用StopCoroutine() 方法只能终止以字符串形式启动的协程 StopAllCoroutine() // 终止所有协程 协程的用途 1.用来延时2.用来异步加载等待3.加载WWW4.制代码在特定的时机执行。 协同程序的执行代码是什么？有何用处，有何缺点1234567891011function Start() &#123; // 协同程序WaitAndPrint在Start函数内执行,可以视同于它与Start函数同步执行. StartCoroutine(WaitAndPrint(2.0)); print (&quot;Before WaitAndPrint Finishes &quot; + Time.time );&#125;function WaitAndPrint (waitTime : float) &#123; // 暂停执行waitTime秒 yield WaitForSeconds (waitTime); print (&quot;WaitAndPrint &quot;+ Time.time );&#125; 作用：一个协同程序在执行过程中,可以在任意位置使用yield语句。yield的返回值控制何时恢复协同程序向下执行。协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。缺点：协同程序并非真线程，可能会发生堵塞。 协程的执行原理 协程函数的返回值时IEnumerator,它是一个迭代器，可以把它当成执行一个序列的某个节点的指针，它提供了两个重要的接口，分别是Current(返回当前指向的元素)和MoveNext()(将指针向后移动一个单位，如果移动成功，则返回true) yield关键词用来声明序列中的下一个值或者是一个无意义的值，如果使用yield return x(x是指一个具体的对象或者数值)的话，那么MoveNext返回为true并且Current被赋值为x,如果使用yield break使得MoveNext()返回为false 如果MoveNext函数返回为true意味着协程的执行条件被满足，则能够从当前的位置继续往下执行。否则不能从当前位置继续往下执行。 网络客户端与服务器交互方式有几种 socket通常也称作”套接字”，实现服务器和客户端之间的物理连接，并进行数据传输。主要有UDP和TCP两个协议，处于网络协议的传输层。http协议传输的主要有http协议和基于http协议的Soap协议（web service）（基于XML）。常见的方式是 http 的post 和get 请求、web service。 TCP和UDP的区别 1、连接方面区别TCP面向连接（如打电话要先拨号建立连接）。UDP是无连接回的，即发送数据之答前不需要建立连接。 2、安全方面的区别TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。UDP尽最大努力交付，即不保证可靠交付。 3、传输效率的区别TCP传输效率相对较低。UDP传输效率高，适用于对高速传输和实时性有较高的通信或广播通信。 4、连接对象数量的区别TCP连接只能是点到点、一对一的。UDP支持一对一，一对多，多对一和多对多的交互通信。 Http和Https的区别 一、传输bai信息安全性不同1.http协议：是超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。2.https协议：是具有安全性的ssl加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全。 二、连接方式不同1.http协议：http的连接很简单，是无状态的。2.https协议：是由SSL＋HTTP协议构建的可进行加密传输、身份认证的网络协议。 三、默认端口不同1.http协议：默认端口是802.https协议：默认的端口是443 四、证书申请方式不同1.http协议：免费申请。2.https协议：需要到ca申请证书，一般免费证书很少，需要交费。 面向对象面向对象的优点 易维护采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的。 质量高在设计时，可重用现有的，在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。 效率高在软件开发时，根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。 易扩展由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。 什么是里氏代换原则 里氏替换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。任何基类可以出现的地方，子类一定可以出现。（就是子类对象可以赋值给基类对象，基类对象不能赋值给子类对象） 继承和组合的区别 继承：可以使用现有类的功能，并且在无需重复编写原有类的情况下对原有类进行功能上的扩展。(is-a关系) 组合：在新类里面创建原有类的对象，重复利用已有类的功能。(has-a关系) 组 合 关 系 继 承 关 系 优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 优点：具有较好的可扩展性 缺点：支持扩展，但是往往以增加系统结构的复杂度为代价 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象 缺点：不支持动态继承。在运行时，子类无法选择不同的父类 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口 缺点：子类不能改变父类的接口 缺点：整体类不能自动获得和局部类同样的接口 优点：子类能自动继承父类的接口 缺点：创建整体类的对象时，需要创建所有局部类的对象 优点：创建子类的对象时，无须创建父类的对象 虚方法virtual抽象方法abstract 虚方法必须有实现部分，抽象方法没有提供实现部分。抽象方法是一种强制派生类覆盖的方法，否则派生类将不能被实例化 抽象方法只能在抽象类中声明，虚方法不是。如果类包含抽象方法，那么该类也是抽象的，也必须声明为抽象的 派生类必须重写抽象类中的抽象方法，虚方法则不必要 虚方法可以实现多态，而抽象方法不行 类和结构体的区别？使用环境？ 结构体是值类型，类是引用类型。结构体存储在栈中，类存储在堆中，栈的空间小但是访问快，堆的空间大但是访问速度较慢。 结构体不能继承，不能创建默认构造函数和析构函数。结构成员不能指定为 abstract、virtual 或 protected。结构体的构造函数必须为所有值赋初值。 结构体一般存储较为轻量的数据，类一般存储具有较为复杂逻辑结构的数据。 使用环境： 当堆栈的空间很有限，且有大量的逻辑对象时，创建类要比创建结构好一些； 对于点、矩形和颜色这样的轻量对象，假如要声明一个含有许多个颜色对象的数组，则CLR需要为每个对象分配内存，在这种情况下，使用结构的成本较低； 在表现抽象和多级别的对象层次时，类是最好的选择，因为结构不支持继承。 数据结构Heap与Stack有何区别(？ 1.heap是堆，stack是栈。2.stack的空间由操作系统自动分配和释放，heap的空间是手动申请和释放的，heap常用new关键字来分配。3.stack空间有限，heap的空间是很大的自由区。 栈和堆谁比较快？为什么？ 栈，原因： 栈有专门的寄存器，堆是随机内存。 栈是在一级缓存上运行的，而堆是在二级缓存上运行的。 访问栈上的数据只需一次，而访问堆上的数据需要两次，先访问栈，再访问堆。 c/c++程序运行时有堆内存与栈内存之分，请写一个语句在堆中分配一个整数：(int a = new int(4)),在栈内存中分配一个整数：（int a = 5）。值类型和引用类型有何区别 1.值类型根据声明位置不同堆和栈中都有可能存储，引用类型存储在堆中2.值类型存取速度快，引用类型存取速度慢。3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用4.值类型继承自System.ValueType，引用类型继承自System.Object 结构体和类有何区别 结构体是一种值类型，而类是引用类型。（值类型、引用类型是根据数据存储的角度来分的）就是值类型用于存储数据的值，引用类型用于存储对实际数据的引用。那么结构体就是当成值来使用的，类则通过引用来对实际数据操作 排序方式有哪些 选择排序，冒泡排序，快速排序，插入排序，希尔排序，归并排序 k层二叉树最多有 2^k - 1 个结点。## 请简述ArrayList和List的主要区别 ArrayList存在不安全类型（ArrayList会把所有插入其中的数据都当做Object来处理）装箱拆箱的操作（费时）List是接口，ArrayList是一个实现了该接口的类，可以被实例化 数组和List两者效率之间哪个好 数组： 它在内存中是连续的存储的，所以索引速度很快，而且赋值与修改元素也很简单。可以利用偏移地址访问元素，时间复杂度为O(1);删除时间复杂度为O(n)，数组没有添加数据选项。 List：基于数组，时间复杂度相同，插入为O(n)；不过在数据少量的时候跟数组差不多，数据庞大的时候效率会低于数组。 哈希表与字典 字典：内部用了Hashtable作为存储结构如果我们试图找到一个不存在的键，它将返回 / 抛出异常。它比哈希表更快，因为没有装箱和拆箱，尤其是值类型。仅公共静态成员是线程安全的。字典是一种通用类型，这意味着我们可以将其与任何数据类型一起使用（创建时，必须同时指定键和值的数据类型）。Dictionay 是 Hashtable 的类型安全实现， Keys和Values是强类型的。Dictionary遍历输出的顺序，就是加入的顺序 哈希表：如果我们尝试查找不存在的键，则返回 null。它比字典慢，因为它需要装箱和拆箱。哈希表中的所有成员都是线程安全的，哈希表不是通用类型，Hashtable 是松散类型的数据结构，我们可以添加任何类型的键和值。HashTable是经过优化的，访问下标的对象先散列过，所以内部是无序散列的 StringBuilder和String的区别 String是字符串常量。StringBuffer是字符串变量 ，线程安全。StringBuilder是字符串变量，线程不安全。String类型是个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象，如果在一个循环里面，不断的改变一个对象，就要不断的生成新的对象，所以效率很低，建议在不断更改String对象的地方不要使用String类型。StringBuilder对象在做字符串连接操作时是在原来的字符串上进行修改，改善了性能。这一点我们平时使用中也许都知道，连接操作频繁的时候，使用StringBuilder对象。 如果是处理字符串的话，用string中的方法每次都需要创建一个新的字符串对象并且分配新的内存地址，而stringBuilder是在原来的内存里对字符串进行修改，所以在字符串处理方面还是建议用stringBuilder这样比较节约内存。但是string 类的方法和功能仍然还是比stringBuilder类要强。 有一本牛津词典，现在输入一串字母组成一个单词，怎么样快速查询词典中是否有这个单词 使用树结构来存储词典的单词，以字母为顺序分别放在相应的子树中。然后根据输入将字母从左到右分级并根据树的结构依次查询。 在一段文本中，有许多”{}”和”[]”和”()”，判断这段文本中的括号是否使用正确？ 使用栈的结构进判断，将所有括号依次入栈，当一次入栈是右括号时判断之前的栈顶是否是对应的左括号，如果是说明合法，将之前的左括号和现在入栈的右括号都出栈。然后继续将新的括号依次入栈，当有一次入栈非法即可判定非法，或者知道最后全部判定合法则判定该文本合法。 设计模式https://blog.csdn.net/weixin_43122090/article/details/105462226 C在类的构造函数前加上static会报什么错?为什么? 构造函数格式为 public+类名，如果加上static会报错（静态构造函数不能有访问修饰符）原因：静态构造函数不允许访问修饰符，也不接受任何参数；无论创建多少类型的对象，静态构造函数只执行一次；运行库创建类实例或者首次访问静态成员之前，运行库调用静态构造函数；静态构造函数执行先于任何实例级别的构造函数；显然也就无法使用this和base来调用构造函数。 以下选项中，正确的是（D） A.Mathf.Round方法作用是限制 B.Mathf.Clamp方法作用是插值C.Mathf.Lerp方法作用是四舍五入 D.Mathf.Abs方法作用是取得绝对值 C#、.Net与Mono的关系？ mono是.net的一个开源跨平台工具，就类似java虚拟机，java本身不是跨平台语言，但运行在虚拟机上就能够实现了跨平台，由Xamarin提出，它是.NET框架的一个开源版本。.net是微软的一个开发平台,只能在windows下运行，而mono可以实现跨平台跑，可以运行于linux，Unix，Mac OS等。C#是微软的编程语言，开发包是.NET，就像Java之于JDK C#和C++的区别(？ C# 与C++ 比较的话，最重要的特性就是C# 是一种完全面向对象的语言，而C++ 不是，另外C# 是基于IL 中间语言和.NET Framework CLR 的，在可移植性，可维护性和强壮性都比C++ 有很大的改进。C# 的设计目标是用来开发快速稳定可扩展的应用程序，当然也可以通过Interop 和Pinvoke 完成一些底层操作 C# 是一种完全面向对象的语言。另外C# 是基于IL 中间语言和.NET Framework CLR 的，在可移植性，可维护性和强壮性都比C++ 有很大的改进。 C#与C++结构体的区别## 实现计时器的方法 Time eltatine:协程 “”与null的区别ref参数和out参数是什么？有什么区别(？ ref和out参数的效果一样，都是通过关键字找到定义在主函数里面的变量的内存地址，并通过方法体内的语法改变它的大小。不同点就是输出参数必须对参数进行初始化。ref必须初始化，out 参数必须在函数里赋值。ref参数是引用，out参数为输出参数。 C#的委托是什么？有何用处 委托类似于一种安全的指针引用，在使用它时是当做类来看待而不是一个方法，相当于对一组方法的列表的引用。用处：使用委托使程序员可以将方法引用封装在委托对象内。然后可以将该委托对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法。与C或C++中的函数指针不同，委托是面向对象，而且是类型安全的。 三种泛型委托委托delegate是什么，event关键字有什么用 delegate 委托，是C#的一种类型，持有对某个方法的引用的类，能够拥有一个签名，引用只能与签名方法相匹配。实现：1、声明一个委托对象，与传递方法具有相同参数列表和返回值类型。2、创建委托对象，将要传递的函数作为参数传入。3、在实现异步调用地方，通过上一步创建对象调用方法。 event 事件，在类中声明且生成，通过使用同一个类或其他类的委托与事件处理程序关联。包含事件的类用于发布事件，称为发布器(publisher)类；接受该事件的类称为订阅器(subscriber)类。事件使用发布-订阅模型。两者的区别：1、委托允许直接访问相应处理函数，事件只能通过公布的回调函数去调用。2、事件只能通过“+=”、“-=”方式注册和取消处理函数，委托除此之外还可以“=”直接赋值处理函数。 概述c#中代理和事件 代理就是用来定义指向方法的引用。C＃事件本质就是对消息的封装，用作对象之间的通信；发送方叫事件发送器，接收方叫事件接收器 sealed关键字用在类声明时与函数声明时的作用 sealed修饰的类为密封类，类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。 请简述private，public，protected，internal的区别 public：对任何类和成员都公开，无限制访问private：仅对该类公开protected：对该类和其派生类公开internal：只能在包含该类的程序集中访问该类 请描述接口Interface与抽象类之间的不同（？ 抽象类和接口都不能实例化。 抽象类可以有抽象的的方法和未抽象的的方法，可以通过子类来重写。抽象类主要是子类的通用结构。 常量、字段、运算符、实例构造函数、析构函数或类型、不能包含静态成员。接口不能有实现的方法。接口主要是作为规范来使用。 static和const关键字的作用 static 关键字至少有下列几个作用：（1）函数体内static 变量的作用范围为该函数体，不同于auto 变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；（2）在模块内的static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；（3）在模块内的static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；（4）在类中的static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；（5）在类中的static 成员函数属于整个类所拥有，这个函数不接收this 指针，因而只能访问类的static 成员变量。const 关键字至少有下列几个作用：（1）欲阻止一个变量被改变，可以使用const 关键字。在定义该const 变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；（3）在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；（4）对于类的成员函数，若指定其为const 类型，则表明其是一个常函数，不能修改类的成员变量（5）对于类的成员函数，有时候必须指定其返回值为const 类型，以使得其返回值不为“左值”。 C#中四种访问修饰符是哪些？各有什么区别？ 1.属性修饰符 2.存取修饰符 3.类修饰符 4.成员修饰符。属性修饰符：Serializable：按值将对象封送到远程服务器。STATread：是单线程套间的意思，是一种线程模型。MATAThread：是多线程套间的意思，也是一种线程模型。存取修饰符：public：存取不受限制。private：只有包含该成员的类可以存取。internal：只有当前工程可以存取。protected：只有包含该成员的类以及派生类可以存取。类修饰符：abstract：抽象类。指示一个类只能作为其它类的基类。sealed：密封类。指示一个类不能被继承。理所当然，密封类不能同时又是抽象类，因为抽象总是希望被继承的。成员修饰符：abstract：指示该方法或属性没有实现。sealed：密封方法。可以防止在派生类中对该方法的override（重载）。不是类的每个成员方法都可以作为密封方法密封方法，必须对基类的虚方法进行重载，提供具体的实现方法。所以，在方法的声明中，sealed修饰符总是和override修饰符同时使用。delegate：委托。用来定义一个函数指针。C#中的事件驱动是基于delegate + event的。const：指定该成员的值只读不允许修改。event：声明一个事件。extern：指示方法在外部实现。override：重写。对由基类继承成员的新实现。readonly：指示一个域只能在声明时以及相同类的内部被赋值。static：指示一个成员属于类型本身，而不是属于特定的对象。即在定义后可不经实例化，就可使用。virtual：指示一个方法或存取器的实现可以在继承类中被覆盖。new：在派生类中隐藏指定的基类成员，从而实现重写的功能。 若要隐藏继承类的成员，请使用相同名称在派生类中声明该成员，并用 new 修饰符修饰它。 已知strcpy函数的原型是：char strcpy(char strDest,const char strSrc); 1.不调用库函数，实现strcpy函数。2.解释为什么要返回char 12345678char * strcpy(char * strDest,const char * strSrc)&#123; if ((strDest==NULL)||(strSrc==NULL)) throw &quot;Invalid argument(s)&quot;; char * strDestCopy=strDest; while ((*strDest++=*strSrc++)!=&apos;\\0&apos;); return strDestCopy;&#125;","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://www.z16388.top/tags/Unity/"}],"keywords":[]},{"title":"生成Java版Anysdk的aar","slug":"anysdk","date":"2018-11-10T11:46:31.000Z","updated":"2018-11-10T12:35:18.277Z","comments":true,"path":"2018/11/10/anysdk/","link":"","permalink":"http://www.z16388.top/2018/11/10/anysdk/","excerpt":"","text":"&emsp;&emsp;在接入Anysdk的时候，我选择了Java的框架。虽然使用Unity版本的会更加方便，直接拖进去就完成了安装步骤，但是不利于控制项目dex文件的大小，不得不进行分包。但是官方提供的是Eclipse的版本，如果想要更好的使用，我们必须把这些东西生成为aar。 &emsp;&emsp;首先，在Android Studio的工程中新建一个library，给的文件拷贝到相应的目录下。需要注意的是，res需要拷贝到src/main/res里。 &emsp;&emsp;如果直接打包的话，我们会发现lib下的armeabi-v7a没有参与打包，缺了so文件怎么能行。这时候，需要在library下的build.gradle中进行配置。 &emsp;&emsp;在buildTypes同级的地方，增加这些代码： 12345sourceSets &#123; main &#123; jniLibs.srcDirs = ['libs'] &#125;&#125; &emsp;&emsp;这里指定了，“在libs目录下寻找so文件”。配置好之后，按照anysdk的文档写好java代码，配好manifest，就可以生成anysdk的aar了。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.z16388.top/tags/Android/"},{"name":"Anysdk","slug":"Anysdk","permalink":"http://www.z16388.top/tags/Anysdk/"},{"name":"Unity","slug":"Unity","permalink":"http://www.z16388.top/tags/Unity/"}],"keywords":[]},{"title":"Android逆向笔记","slug":"android-d","date":"2018-11-10T10:32:08.000Z","updated":"2018-11-10T12:12:42.811Z","comments":true,"path":"2018/11/10/android-d/","link":"","permalink":"http://www.z16388.top/2018/11/10/android-d/","excerpt":"","text":"&emsp;&emsp;这几周，一直在倒腾安卓apk相关的东西，前面那一篇命令行修改apk工具就是倒腾的一个中间产物。但是命令行工具还是有它的局限性，随着作死的幅度越来越大已经无法满足我的需求了，便改用python来实现这个工具。大家可以参考这个项目来进行修改https://github.com/z16388/cs_game_lib。后面还有一些扩展的代码没有暂时加入到项目中，打算完善之后提交上去。这篇还会继续更新，可以参考后面的代码结合项目达到你的目的。 关于Apk&emsp;&emsp;apk就是一个zip，可以直接解压进行修改，这也是我前一篇中修改apk的方式。但是它不是普通的zip，需要一个签名，否则无法进行安装。但是如果直接进行解压，它里面会有一些二进制化的东西，不方便修改。这时候，我们可以使用apktool进行解包，这样得到的都是文本化的内容了。除此之外，解包比解压能得到更多的res信息，而且不需要我们手动删除签名文件夹。 Apktool&emsp;&emsp;Apktool是一个jar文件，官网是https://ibotpeaches.github.io/Apktool/。可以参考它的文档进行使用，但是会发现，命令行会变得很奇怪，而且是开了一个新的窗口，我们后面命令行的代码不会顺利执行，就很难受。后来发现，它的命令其实是执行同目录下的一个bat脚本文件，而且是加了参数的。所以，在使用apktool时候，我比较推荐直接调用jar,以解包为例。 1java -jar -Duser.language=zh_cn -Dfile.encoding=UTF-8 apktool.jar d [file name] -o [decode path] &emsp;&emsp;我们常用的命令其实就是解包和打包： 12apktool d xxx.apkapktool b xxx &emsp;&emsp;打包之后，是没有META-INF文件夹的，可以直接签名。关于签名相关的内容可以参考：命令行修改apk工具。 APK解包后的结构&emsp;&emsp;解包后的APK目录是会变的，如果进行了打包，那么回在该目录下生成一个build目录。但是基础的会有下面这些： assest lib original res smali unknown &emsp;&emsp;除此之外，还有文本化的manifest文件。 &emsp;&emsp;想要修改app安装后的名称，可以去res/values/strings.xml，找到app_ame的字段进行修改。 &emsp;&emsp;想要修改权限可以直接修改manifest文件。 &emsp;&emsp;但是想要修改包名就不是那么简单的事情了，需要反编译smali文件成java，修改目录和包名在反编译回去。这个骚操作还是在计划中，暂时没有实现。 &emsp;&emsp;需要注意的是，如果使用Python原生的xml库区修改安卓的xml的时候，会改变xml文件的名空间。原先满页的android名空间变成了奇怪的ag0。这个问题我还在寻找解决方案。如果完成了，那么关于权限和应用名的修改就可以实现自动化了。 &emsp;&emsp;解包的代码如下，可以替换上面github项目中的解压代码。 12345678910111213141516171819202122#coding=utf-8 import os,os.pathfrom shutil import rmtree def decode_apk(filename, decode_folder): if os.path.exists(decode_folder): rmtree(decode_folder) print \"删除已存在的文件夹\"+decode_folder print \"开始解包\"+filename+\"-&gt;\"+decode_folder apktool_command = \"java -jar -Duser.language=zh_cn -Dfile.encoding=UTF8 apktool.jar d \" + filename + \" -o \" + decode_folder os.system(apktool_command) print \"解包成功\"+filename+\"-&gt;\"+decode_folderdef build_apk(folder, apk_out): if os.access(apk_out,os.R_OK): print \"删除已存在的\"+apk_out os.remove(apk_out) print \"打包中\"+apk_out apktool_command = \"java -jar -Duser.language=zh_cn -Dfile.encoding=UTF8 apktool.jar b \" + folder + \" -o \" + apk_out os.system(apktool_command) print \"打包成功\"+apk_out &emsp;&emsp;脚本需要和apktool.jar在同一目录下，否则命令中需要指定路径。 关于签名&emsp;&emsp;打包后签名的方法，在这一篇里已经提到了命令行修改apk工具。 &emsp;&emsp;需要注意的是，keystore文件是使用eclipse生成的签名文件，算，如果你的应用是使用Android Studio生成的签名，那将是jks文件。(这可是个不错的番号啊…) &emsp;&emsp;生成jks文件：在Build菜单中，找到Generate Signed Apk选项，在弹出的窗口中选择Create new，填写相关内容，即可创建签名文件。 &emsp;&emsp;如果非要使用keystore，可以使用keytool进行转换，jks文件经过p12文件中转可以转换成keystore文件，代码： 12keytool -importkeystore -srckeystore xxx.jks -srcstoretype JKS -deststoretype PKCS12 -destkeystore xxx.p12keytool -v -importkeystore -srckeystore xxx.p12 -srcstoretype PKCS12 -destkeystore xxx.keystore -deststoretype JKS &emsp;&emsp;除此之外，还可以使用keytool直接生成keystore签名。 1keytool -genkeypair -alias serverkey -keypass 111111 -storepass 111111 -dname &quot;C=CN,ST=GD,L=SZ,O=vihoo,OU=dev,CN=vihoo.com&quot; -keyalg RSA -keysize 2048 -validity 3650 -keystore server.keystore","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.z16388.top/tags/Android/"},{"name":"Python","slug":"Python","permalink":"http://www.z16388.top/tags/Python/"}],"keywords":[]},{"title":"关于新版(28, 9.0)Android的坑","slug":"androidversionkeng","date":"2018-11-10T09:34:38.000Z","updated":"2018-11-10T10:16:30.012Z","comments":true,"path":"2018/11/10/androidversionkeng/","link":"","permalink":"http://www.z16388.top/2018/11/10/androidversionkeng/","excerpt":"","text":"Android 9.0&emsp;&emsp;前几天出包就出现了一个非常痛心的事情。发现使用刚发售的，搭载安卓9.0系统的手机无法进行热更的。这就很难受了。各种去查，发现是在10月31日晚上，SDK突然更新了，增加了新的版本28，也就是安卓9.0。 &emsp;&emsp;Unity和安卓9.0的矛盾是，网络相关的东西会受到影响。目前知道的还有Unity的后台统计也是无法使用的，当时清了整个后台，一天多都是白白的，一个Bug都没有，难受。 &emsp;&emsp;解决方法就是到sdk目录中把28给删了，最高版本使用27。然后打出的包解包看一下manifest，确认版本是27，以防止不兼容安卓9.0。这个在传到谷歌商店中构建版本时也是可以确认的。 Android 9.0&emsp;&emsp;在接某第三方sdk的时候遇到了另一个问题，发现他们的sdk在8.0的系统里无法使用。logcat之后发现是他们使用了一个无法在全屏模式下使用的属性。这其实是一个8.0.0版本的bug，在8.1版本中得到了修复，我也用手边的诺基亚7升级了系统，验证了这一点。 &emsp;&emsp;然后他们在第二天就更新了sdk版本，可喜可贺，可喜可贺~","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.z16388.top/tags/Android/"}],"keywords":[]},{"title":"命令行修改apk工具","slug":"cmdapk","date":"2018-10-21T06:24:25.000Z","updated":"2018-11-10T10:32:59.008Z","comments":true,"path":"2018/10/21/cmdapk/","link":"","permalink":"http://www.z16388.top/2018/10/21/cmdapk/","excerpt":"","text":"概述&emsp;&emsp;在前一段时间的工作中，我得到了一个新的任务，写一个命令行工具，修改apk中的某个文件，再进行重新打包。这个过程实际上十分简单：首先，apk文件就是一个zip文件，但是在安装的时候安卓系统会校验签名，因此我们需要对重新打包的apk进行签名。下面是实现这个工具的重难点和具体思路： 命令行数组&emsp;&emsp;如果想要生成一批apk，他们中需要修改的位置都是相同的，只有写入的文本不同。那么，第一时间我们会想到字符串数组。但是在命令行中是没有数组的，有的文章采用本地文件逐行读取的方法，但我们也可以使用下面的方法来对数组进行模拟: 参考资料：https://www.yiibai.com/batch_script/batch_script_arrays.html 1234567@echo offset a[0]=1 set a[1]=2 set a[2]=3 echo The first element of the array is %a[0]% echo The second element of the array is %a[1]% echo The third element of the array is %a[2]% 批处理压缩与解压缩&emsp;&emsp;在windows环境中，我们不能方便地像隔壁那样，直接调用zip和unzip命令进行压缩和解压，需要下载相应的程序来帮助我们完成这一过程。下载地址：http://stahlworks.com/dev/index.php?tool=zipunzip &emsp;&emsp;下载完两个exe文件之后，我们将它放在与脚本相同目录下或者是C:/Windows目录下，推荐后者，然后就可以使用压缩与解压缩命令了。 1zip -r fileName.apk ./* &emsp;&emsp;这里的命令是将当前目录压缩为指定名称的apk文件，其中参数-r为递归压缩子目录下所有文件。不加的话只会得到一个空的文件夹。这里需要注意的是，在打包apk的时候，我们需要cd到解压好的文件目录下进行压缩，否则会出现压缩好之后的apk因为打开后是一个文件夹，不是标准apk目录结构的情况而无法进行安装。 1unzip -o -d /path fileName.apk &emsp;&emsp;这里的命令是将指定apk解压到指定的目录中，-o是不提示覆盖，-d是指定路径。 关于apk签名&emsp;&emsp;我们可以通过下面的方法对apk的签名进行查看：解压出位于META-INF位置下的CERT.RSA文件，使用命令查看: 1keytool -printcert -file [file path] &emsp;&emsp;想要对apk重新签名，需要删除apk中原先的签名文件。有博客说删掉两个文件就行，但是会出现错误。jarsigner: java.lang.SecurityException:SHA1 digest error for META-INF/CERT.RSA根据stack overflow上某个老哥给的答案：https://stackoverflow.com/questions/37513084/jarsigner-java-lang-securityexceptionsha1-digest-error-for-meta-inf-cert-rsa-a我们需要删除整个META-INF文件进行 &emsp;&emsp;apk的重新签名需要项目的证书文件，后缀名为：.keystores，命令为： 1jarsigner -verbose -keystore [keystore path] -signedjar [out apk name].apk [current apk name].apk [alias name] -storepass [password] &emsp;&emsp;这里需要填写的参数分别是证书文件的路径、签名后apk名及路径、签名前apk名及路径，别名，密码。 &emsp;&emsp;签名完毕后，还可以对生成的apk进行验证。 1jarsigner -verify [out apk name].apk &emsp;&emsp;至此，整个工具的重点就介绍完毕了。 工具&emsp;&emsp;在很多文章中，有人会推荐使用apktool的工具进行上面的一些工作，这里非常不推荐。apktool是一个java写的工具，在解包和打包过程结束后，会自动关闭当前的命令行。解包打包签名，可能就需要有三个脚本了，给工具的制作造成了很大的不便。 &emsp;&emsp;下面是工具的代码： 12345678910111213141516171819202122232425262728@echo offsetlocal enabledelayedexpansionrem 拖入apk并获取其路径和文件名echo 请拖入需要处理的apkset /p input=set apkUrl=for /f &quot;delims=&quot; %%i in (&apos;dir /b %input%&apos;) do (set apkUrl=!apkUrl!%%i)set fileName=%apkUrl:.apk=%rem 解包并删除签名if exist output rmdir /s/q outputmd outputcd outputmd %fileName%unzip -o -d %fileName% %input%rmdir /s/q %fileName%\\META-INFrem 修改文件打包并签名for do ([这里填写修改操作]cd !fileName!zip -r [your file name].apk ./*cd..jarsigner -verbose -keystore [keystore path] -signedjar [out apk name].apk [current apk name].apk [alias name] -storepass [password])pause &emsp;&emsp;在这里我使用了for循环获取了解压后的文件夹名的方法，实现起来可能显得会比较扭曲。但是如果在事先不确定拖入文件名，并且打出的包对原文件名有需求的话，就得用这种方法去取了。除此之外，在进行签名的时候，签名前和签名后文件名可以是同一个，这样就不会出现新的apk，而是在原有未签名apk的基础上进行签名。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.z16388.top/tags/Android/"},{"name":"安卓","slug":"安卓","permalink":"http://www.z16388.top/tags/安卓/"}],"keywords":[]},{"title":"乐理笔记","slug":"music","date":"2018-06-26T14:03:05.000Z","updated":"2018-06-26T14:17:03.528Z","comments":true,"path":"2018/06/26/music/","link":"","permalink":"http://www.z16388.top/2018/06/26/music/","excerpt":"","text":"基础知识调式&emsp;&emsp;调式分为升号调与降号调，升号调中的黑键用升号表示，降号调中的黑键用降号表示。 升号调 降号调 G、D、A、E、B、F#、C# F、Bb、Eb、Ab、Db、Gb、Cb &emsp;&emsp;调子中的7个音，下面从左往右，越往右越不稳定： 稳定音 不稳定音 1 5 3 6 2 4 7 &emsp;&emsp;不稳定音总是倾向于稳定音的，他们的倾向分别为： 12341←23←45←67→i 音程&emsp;&emsp;音程表 半音数 音程 0 纯一度 1 小二度 2 大二度 3 小三度 4 大三度 5 纯四度 6 增四/减五度 7 纯五度 8 小六度 9 大六度 10 小七度 11 大七度 12 纯八度 &emsp;&emsp;","categories":[],"tags":[{"name":"音乐","slug":"音乐","permalink":"http://www.z16388.top/tags/音乐/"}],"keywords":[]},{"title":"关于最终幻想14演奏系统的解决方案","slug":"midiff","date":"2018-06-17T10:16:20.000Z","updated":"2018-06-18T04:06:03.543Z","comments":true,"path":"2018/06/17/midiff/","link":"","permalink":"http://www.z16388.top/2018/06/17/midiff/","excerpt":"","text":"MIDI键盘映射 目前键盘映射不能使用组合键，4.3版本更新之后可使用。 下载安装&emsp;&emsp;最终幻想14更新了4.20版本。在这个版本中，诗人的演奏系统做出了一定的更改，小键盘党的我直接报警了。最后我决定放弃这个“邪门歪道”，直接使用电钢琴进行映射，实现演奏功能。 &emsp;&emsp;在这里，使用到了一个MIDI键盘映射软件：Bome’s Midi Translator。 官方网站：https://www.bome.com/products/miditranslator &emsp;&emsp;需要注意的是，Pro版本需要59刀的价格。这里，在下载的时候选择精简版。 硬件设备&emsp;&emsp;首先介绍一下我所使用的硬件设备。键盘是吟飞的电钢琴，MIDI连接线是淘宝来的便宜货，连输入输出都标反了。在键盘的选择上，并没有太大的要求。因为游戏的演奏功能上只有三个八度。即使是淘宝上买来的手卷钢琴，也是可以使用的。 软件配置&emsp;&emsp;在完成软件的安装之后，不能直接打开软件，需要给予管理员权限。 &emsp;&emsp;关于MIDI的输入输出端口，软件的文档有下面的内容： 1234567Define MIDI Ports Next, specify the MIDI input and output ports you will be using. The MIDI OUT ports will be the ports to which translated MIDI messages are sent to. The MIDI IN port will be used as the source of MIDI data, typically connecting with an external MIDI device, e.g. via USB or a MIDI interface on a sound card. Select the appropriate MIDI input source(s) by checking it. You can use a virtual MIDI port here if you are setting up a translator for a software sequencer or other audio application that interfaces with MIDI. Check the virtual MIDI port as the output device and then select it as the MIDI input port in your 3rd party application in order to have Bome MIDI Translator control it. Use the alias “Bome Virtual Port 1” (in italics ) insteadof the direct device. &emsp;&emsp;把输入端口设置为你的MIDI设备。需要注意的是，MIDI端口只能有一个应用去占用。像我为了测试MIDI设备是否能够使用，打开了Cubase，软件就提示了无法设置该端口的问题。设置完端口之后，将后面的状态设置为启用。这时候很明显可以看到，左下角输入的端口在闪光。 &emsp;&emsp;之后是输出端口。原文中提到，如果想要使用MIDI映射，就要把输出端口设置为软件提供的一个虚拟端口。如果是Pro版本，需要在设置里，选择选项“Bome Virtual Port 1”即可。除此之外，还要像ASIO声卡一样设置跳线。在这里，将你设备的端口跳到“Bome Virtual Port 1”。跳线设置完之后，会看到输出端口的指示灯也会闪。我们使用的基础班只要将输出端口设置为空即可。 快捷键设置&emsp;&emsp;这里的设置分为三步。 &emsp;&emsp;第一步是指定映射名。这里我使用简谱表示唱名，#和字母b分别表示升降调，符号+和-分别表示升降八度。 &emsp;&emsp;第二步是键盘抓取。勾上抓取，然后按MIDI上相应的键，截取。PRO版还有按压时间这一属性，这里忽略掉。 &emsp;&emsp;最后一步是设置映射的按键。 小键盘按键替换&emsp;&emsp;在这个版本中，无法将演奏按钮设置为小键盘，这让我这种小键盘党十分头疼。这里使用AutoHotKey脚本，解决这个问题。 &emsp;&emsp;需要注意的是，脚本生成的可执行文件无法兼容win7以上系统。这里要设置兼容性为win7,并给予管理员权限。 &emsp;&emsp;脚本如下： 1234567Numpad1::qNumpad2::wNumpad3::eNumpad4::rNumpad5::tNumpad6::yNumpad7::u &emsp;&emsp;脚本需要使用AutoHotKey进行编译。下载地址：https://www.autohotkey.com/ &emsp;&emsp;也可以使用我编译好的可执行程序：https://pan.baidu.com/s/1nmDNgbDi3lcZXMVttSU_Mw","categories":[],"tags":[{"name":"MIDI","slug":"MIDI","permalink":"http://www.z16388.top/tags/MIDI/"},{"name":"AutoHotkey","slug":"AutoHotkey","permalink":"http://www.z16388.top/tags/AutoHotkey/"},{"name":"游戏","slug":"游戏","permalink":"http://www.z16388.top/tags/游戏/"},{"name":"音乐","slug":"音乐","permalink":"http://www.z16388.top/tags/音乐/"}],"keywords":[]},{"title":"系统导引修改","slug":"daoyin","date":"2018-03-13T06:11:43.000Z","updated":"2018-03-13T06:23:24.039Z","comments":true,"path":"2018/03/13/daoyin/","link":"","permalink":"http://www.z16388.top/2018/03/13/daoyin/","excerpt":"","text":"&emsp;&emsp;寒假的时候给电脑换了个系统，出现了原系统导引没有删除的问题。因为是不同的系统，所以还是比较容易能够分辨的。 右键“此电脑”-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;启动和故障恢复-&gt;设置-&gt;默认操作系统 &emsp;&emsp;在这里可以根据需求进行更改，修改多系统选择时间，还是默认进入哪一个。但是Win10的兼容性不是很好，我的外置声卡驱动，还有音频编辑软件都无法正常安装与使用，我便在开学时换回了win8.1。但是问题出现了，两个win8.1难以分辨，而且留着一个没用的导引也十分没有必要。下面就是删除多余导引的方法。（不需要其他软件） 运行命令提示符（管理员权限）输入命令easybcd查看导引当前的导引会标记为current，并且会有系统盘的路径信息，复制想要删除的导引的标识符，就是用大括号括起来的一长串。执行bcdedit /delete {标识符}完成删除","categories":[],"tags":[{"name":"系统","slug":"系统","permalink":"http://www.z16388.top/tags/系统/"}],"keywords":[]},{"title":"【ACM教程】2.6 文件操作","slug":"【ACM教程】2-6文件操作","date":"2018-03-06T05:57:13.000Z","updated":"2018-03-13T08:47:12.521Z","comments":true,"path":"2018/03/06/【ACM教程】2-6文件操作/","link":"","permalink":"http://www.z16388.top/2018/03/06/【ACM教程】2-6文件操作/","excerpt":"","text":"第六节 文件操作&emsp;&emsp;在算法类竞赛的过程中，还需要我们掌握文件操作。 &emsp;&emsp;在去年的蓝桥杯省赛中，第一道题需要处理大量的数据。如果每次都要进行大量的数据输入操作，会花费很多时间。这个时候，把数据存放到文本文档中去，再使用文件操作读取数据，进行计算，能够节省大量的时间。 &emsp;&emsp;除此之外，在调试程序时，也可以将测试数据保存在文件中读取，可以省去每次编译时，数据输入的时间。 &emsp;&emsp;C语言使用文件指针来进行文件的读写。 &emsp;&emsp;首先是创建文件指针： 1FILE *fin; &emsp;&emsp;这里的FILE一定要大写，用于存放文件的变量一定是指针类型。 &emsp;&emsp;接下来要对文件指针初始化： 1fin = fopen(\"xx.txt\",\"w\"); &emsp;&emsp;这里的fopen()函数拥有两个参数，一个是用于读写的用户名，另一个就是读写的参数，这个参数由以下几种字母组成： r(read): 只读w(write): 只写a(append): 追加t(text): 文本文件，可省略不写b(binary): 二进制文件+: 读和写 &emsp;&emsp;我们通常使用w创建输出和输出两个文档，然后将输入文档改为r即可。 &emsp;&emsp;下面是一个简单的A+B问题的文件操作实现： 12345678910111213141516#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; FILE *fin,*fout; int a,b,res; fin = fopen(\"in.txt\",\"r\"); fout = fopen(\"out.txt\",\"w\"); fscanf(fin,\"%d %d\",&amp;a,&amp;b); res = a+b; fprintf(fout,\"%d\\n\",res); fclose(fin); fclose(fout); return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.z16388.top/tags/动态规划/"}],"keywords":[]},{"title":"Lua学习笔记","slug":"Luanote","date":"2018-02-25T03:32:12.000Z","updated":"2018-03-15T09:22:34.303Z","comments":true,"path":"2018/02/25/Luanote/","link":"","permalink":"http://www.z16388.top/2018/02/25/Luanote/","excerpt":"","text":"&emsp;&emsp;学习资料地址：http://www.runoob.com/lua/lua-tutorial.html 环境安装与使用安装环境&emsp;&emsp;在Windows环境下，使用SciTE来运行Lua程序。 &emsp;&emsp;项目GitHub地址：https://github.com/rjpcomputing/luaforwindows/releases &emsp;&emsp;上面的官方下载无法保证下载速度，我使用的是菜鸟教程分流的下载地址：http://static.runoob.com/download/LuaForWindows_v5.1.4-46.exe 开始编程&emsp;&emsp;和Python一样，Lua也有交互式的编程方式。在命令行中输入lua或者lua -i启用。 &emsp;&emsp;同时也可以使用脚本式编程，就是将代码存放在一个lua文件中，命令行执行lua xxx.lua即可。 &emsp;&emsp;需要注意的是，交互式编程状态下不能使用lua命令，会出现下面的错误，这一点我也是犯了好多次： 1stdin:1: &apos;=&apos; expected near &apos;hello&apos; &emsp;&emsp;教程中没有提到怎样退出lua环境 。os.exit()退出。 基础知识注释&emsp;&emsp;单行注释: 1-- &emsp;&emsp;多行注释： 1234--[[XXXXXX]]-- 输入输出1print(\"hello world!\") 数据类型与变量变量概述&emsp;&emsp;Lua有三种变量类型：全局变量，局部变量和表中的域。默认情况下，变量都是全局变量，函数里面没有做特殊声明的变量也都是全局变量。全局变量不需要声明，直接赋值即创建了这个全局变量。如果访问了一个没有创建的变量，会返回一个nil。同样，如果想要删除一个变量，直接赋值nil即可。 12345&gt; print(b)nil&gt; b=10&gt; print(b)10 &emsp;&emsp;如果想要一个局部变量，需要使用local显式声明： 1local b = 5 赋值语句&emsp;&emsp;赋值时改变一个变量的值和改变表域的最基本方法。同大多数编程语言类似，Lua使用从右到左的赋值方式。除此之外，还能够实现多个变量同时赋值： 1a, b = 10, 2*x &emsp;&emsp;上面的语句在功能上，等同于： 12a = 10b = 2*x &emsp;&emsp;在对多个变量进行赋值时，Lua采用的计算方式是先计算右侧的值，再进行赋值的操作。所以再Lua中，实现两个变量值的交换只需要一行代码： 1x, y = y, x &emsp;&emsp;除此之外，当变量的个数和数值的个数不一致时，Lua会遵循这个策略： 当 变量个数 &gt; 值的个数 时，右侧没有指定值的变量赋值为nil 当 变量个数 &lt; 值的个数 时，右侧多余的值会被忽略掉。 &emsp;&emsp;所以比较容易出现的错误是，在对多个变量进行相同赋值时： 1234a, b, c = 0print(a,b,c) --&gt; 0 nil nila, b, c = 0, 0, 0print(a,b,c) --&gt; 0 0 0 &emsp;&emsp;多赋值语句，除了用在上面的值交换的过程中之外，还常用于记录函数的多个返回值。Lua中，函数可以有多个返回值。如果想要将函数f()的两个返回值存放到全局变量a和b中去，可以使用下面的语句： 1a, b = f() &emsp;&emsp;上面的语句，实现了将函数的第一个返回值给a，第二个给b。 &emsp;&emsp;虽然Lua定义全局变量比较方便，但是应当尽可能地使用局部变量。因为局部变量的访问时间要比全局变量更快，同时也避免了变量命名的冲突。 数据类型概述&emsp;&emsp;以下是常见的集中变量类型。 数据类型 描述 nil 无效值，没有赋值的变量都会返回nil boolean 布尔 number 双精度浮点型 string 字符串，用单引号或双引号括起来 function 由C或Lua编写的函数 userdata *表示任意存储在变量中的C数据结构 thread *表示执行的独立线路，用于执行协同程序 table *Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。 &emsp;&emsp;可以使用type函数测试给定变量或常量的类型： 1234567print(type(\"Hello world\")) --&gt; stringprint(type(10.4*3)) --&gt; numberprint(type(print)) --&gt; functionprint(type(type)) --&gt; functionprint(type(true)) --&gt; booleanprint(type(nil)) --&gt; nilprint(type(type(X))) --&gt; string nil（空）&emsp;&emsp;nil类型表示没有任何有效值，只有一个值，nil。打印一个没有赋值的变量会输出nil。对于全局变量和table变量，nil可以起到删除的作用。全局变量或者 table表里的变量赋一个nil值，等同于将他们删除。 &emsp;&emsp;nil在比较时，需要使用双引号括起来。 1234567&gt; type(X)nil&gt; type(X)==nilfalse&gt; type(X)==\"nil\"true&gt; boolean（布尔）&emsp;&emsp;Lua的布尔值与其他语言有一个显著的区别，它将false和nil看作假，其他的值，包括0，都为真。长时间使用其他编程语言的人可能会很难反应过来。 &emsp;&emsp;除此之外，在进行逻辑判断时也和其他语言有很多不同。进行或、与运算时，如0 or false的值就为0，10 and 20返回值就为20。 number（数字）&emsp;&emsp;Lua默认只有一种number类型，即双精度浮点型。 string（字符串）&emsp;&emsp;字符串由一对单引号或者双引号括起来。 1string1 = \"this is string1\" &emsp;&emsp;也可以使用两个方括号[[]]来表示一块字符串。 12345678html = [[&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"http://www.z16388.com/\"&gt;崎径 其镜&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]] &emsp;&emsp;运行时，Lua会自动在string和number之间进行格式转换。 1234print(\"10\"+ 1) --&gt; 11print(\"10 + 1\") --&gt; 10 + 1print(\"hello\"+ 1) -- 报错 (无法转换 \"hello\")print(10 .. 20) --&gt; 1020 &emsp;&emsp;在一个数字后写..时应该加空格，防止被错误解释。 &emsp;&emsp;可以使用两点..来连接两个字符串： 1234&gt; print(\"a\" .. 'b')ab&gt; print(157 .. 428)157428 &emsp;&emsp;可以使用#来计算字符串的长度： 12345&gt; len = \"www.z16388.top\"&gt; print(#len)14&gt; print(#\"www.z16388.top\")14 table（表）&emsp;&emsp;表是一个关联数组，可以创建空表，也可以在创建的时候初始化： 12local tbl1 = &#123;&#125;local tbl2 = &#123;\"apple\", \"pear\", \"orange\", \"grape\"&#125; &emsp;&emsp;数组的索引可以是数字或者字符串： 12a[key] = 22a[2] = 11 &emsp;&emsp;需要注意的是，与其他语言不同，Lua默认初始索引是从1开始的！！！！ 1234local tbl = &#123;\"apple\", \"pear\", \"orange\", \"grape\"&#125;for key, val in pairs(tbl) do print(\"Key\", key)end &emsp;&emsp;程序的运行结果是： 1234Key 1Key 2Key 3Key 4 &emsp;&emsp;对table的索引除了使用国际惯例[]之外，还可以使用.进行操作。需要注意的是，使用点号来索引时，索引的关键字不能为数字。 123456&gt; site = &#123;&#125;&gt; site[\"key\"] = \"www.z16388.top\"&gt; print(site[\"key\"])www.z16388.top&gt; print(site.key)www.z16388.top &emsp;&emsp;最后，table不会固定长度,没有被赋值的部分，返回值都为nil。如果直接使用for循环进行遍历，循环会在遇到nil值时终止，可能无法实现对整个数组的遍历。（如果其中有空值的话）具体的解决方法在table部分给出。 function（函数）&emsp;&emsp;在Lua中，函数被看作第一类值，函数可以存在变量里。 12345678910function factorial1(n) if n == 0 then return 1 else return n * factorial1(n - 1) endendprint(factorial1(5))factorial2 = factorial1print(factorial2(5)) &emsp;&emsp;可以以匿名函数的方式，通过参数传递。函数之所以有名字，就是为了方便进行调用。而只使用一次的函数，则可以不起名字，也就是匿名函数。 12345678910111213function testFun(tab,fun) for k ,v in pairs(tab) do print(fun(k,v)); endendtab=&#123;key1=\"val1\",key2=\"val2\"&#125;testFun(tab,function(key,val)--匿名函数 return key..\"=\"..valend); 循环与流程控制循环语句while循环&emsp;&emsp;条件为true时会重复执行循环体的语句。 1234while(condition)do statementsend for循环&emsp;&emsp;for循环是可以制定循环体执行次数的循环语句。Lua中的for循环需要相当地注意，分为两大类： 数值for循环123for var=exp1,exp2,exp3 do &lt;执行体&gt; end &emsp;&emsp;exp1为初值，exp2为终值，exp3为步长。若exp3不指定，值默认为1。需要注意的是，表达式中三个参数的值都会在循环开始前一次性求值，以后不再进行求值。 &emsp;&emsp;参数 泛型for循环&emsp;&emsp;泛型for循环，通过一个迭代器来遍历所有的值，与C++类似。 123for i,v in ipairs(a) do print(v) end &emsp;&emsp;其中，i是索引，v是索引对应的元素的值，ipairs是Lua提供的一个迭代器函数，用来迭代数组。它的参数a就是数组名。下面是一个对数组进行泛型for循环输出的例子。 1234days = &#123;\"Suanday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"&#125; for i,v in ipairs(days) do print(v) end repeat … until循环&emsp;&emsp;即do … while，重复执行循环体到循环条件为真时。 123repeat statementsuntil( condition ) break语句&emsp;&emsp;Lua支持break语句。 流程控制&emsp;&emsp;if语句的格式： 1234if(布尔表达式)then --[ 在布尔表达式为 true 时执行的语句 --]end &emsp;&emsp;if … else 语句格式： 123456if(布尔表达式)then --[ 布尔表达式为 true 时执行该语句块 --]else --[ 布尔表达式为 false 时执行该语句块 --]end &emsp;&emsp;需要注意的是，Lua中0也为真值，只有false和nil为假。 函数定义&emsp;&emsp;Lua中，函数的标准格式如下： 1234optional_function_scope function function_name( argument1, argument2, argument3..., argumentn) function_body return result_params_comma_separatedend optional_function_scope这个参数是可选的，表示函数是全局的还是局部的。默认为全局函数，设置为局部函数需要加关键字local function_name函数名 argument函数的参数，用逗号隔开，也可以不带参数 function_body函数体 result_params_comma_separated返回值，可以有多个。 &emsp;&emsp;函数可以作为参数。 多返回值&emsp;&emsp;Lua中的函数可以有多个返回值。 1return res1,res2; 可变参数&emsp;&emsp;Lua中的函数可以接受可变数目的参数，用三点…来代表多个参数。计算平均值的程序，可以这样写： 1234567891011function average(...) result = 0 local arg=&#123;...&#125; for i,v in ipairs(arg) do result = result + v end print(\"总共传入 \" .. #arg .. \" 个数\") return result/#argendprint(\"平均值为\",average(10,5,3,4,5,6)) &emsp;&emsp;在新的版本里，#不能用于返回数组元素的个数了，而是需要使用： 1select(\"#\",...) 运算符算数运算符&emsp;&emsp;常用的算术运算符与其他语言类似。需要注意的是，Lua里没有整数，所以如果想要取整操作，必须要进行取整操作： 1x = math.ceil(x) &emsp;&emsp;需要注意的是，这里的取整仍然是向上取整。也就是说，无论小数部分有多小，取整的结果都是要比原数的整数部分大1。 &emsp;&emsp;除此之外，常用的操作应该还有数据精度的控制： 1string.format(\"%.2f\",dt) 关系运算符 符号 含义 == 等于 ~= 不等 &gt;= 大于等于 &lt;= 小于等于 &gt; 大于 &lt; 小于 逻辑运算符 符号 含义 and 与 or 或 not 非 其他运算符 符号 含义 .. 连结两个字符串 # 返回字符串或表的长度 &emsp;&emsp;#运算符，获取的表的长度实际上获取的是表最大的索引值。 12345678910111213tab1 = &#123;\"1\",\"2\"&#125;print(\"tab1长度\"..#tab1)tab2 = &#123;key1=\"1\",\"2\"&#125;print(\"tab2长度\"..#tab2)tab3 = &#123;&#125;tab3[1]=\"1\"tab3[2]=\"2\"tab3[4]=\"4\"print(\"tab3长度\"..#tab3)tab1长度2tab2长度1tab3长度4 &emsp;&emsp;但是当下表的值，大小相差超过1的时候，就会停止计算。 1234567tab3=&#123;&#125;tab3[1]=\"1\"tab3[2]=\"2\"tab3[5]=\"5\"print(\"tab3的长度\",#tab3)tab3的长度 2 运算符优先级&emsp;&emsp;在原口诀的基础上，字符串连接运算符的优先级在算数运算符和关系运算符之间。 字符串形式&emsp;&emsp;共有三种类型 单引号括起来 双引号括起来 [[]]括起来 常用方法 方法 用途 uper(str) 全部转为大写字母 lower(str) 全部转为小写字母 len(str) 计算长度 gsub(str,str1,str2,num) 将str中的str1，替换为str2，替换num个，num可以省略 find(str,str1,[init, [end]]) 在str中搜索str1，返回其位置。如果不存在返回nil。第三个参数为索引 &emsp;&emsp;字符串翻转 12&gt; string.reverse(\"Lua\")auL &emsp;&emsp;字符串格式化，和C的输出类似 12&gt; string.format(\"the value is:%d\",4)the value is:4 &emsp;&emsp;char()函数，将整数按照ASCII码转换成对应的符号；byte(str,num)将第num个字幕转换为ASCII码，默认是第一个。 123456&gt; string.char(97,98,99,100)abcd&gt; string.byte(\"ABCD\",4)68&gt; string.byte(\"ABCD\")65 &emsp;&emsp;rep(string,n)将字符串复制n次。 12&gt; string.rep(\"abcd\",2)abcdabcd &emsp;&emsp;..可以用于连接字符串： 12&gt; print(\"FF\"..\"14\")FF14 &emsp;&emsp;原课程笔记中提到了两个比较有用的程序。一个是将阿拉伯数字转换成大写的中文数字，另一个是移除一个字符串中的汉字字符和符号。 12345678910local function NumToCN(num) local size = #tostring(num) local CN = \"\" local StrCN = &#123;\"一\",\"二\",\"三\",\"四\",\"五\",\"六\",\"七\",\"八\",\"九\"&#125; for i = 1 , size do CN = CN .. StrCN[tonumber(string.sub(tostring(num), i , i))] end return CNendprint(NumToCN(56665)) 12345678910111213141516function StrSplit(inputstr, sep) if sep == nil then sep = \"%s\" end local t=&#123;&#125; local i=1 for str in string.gmatch(inputstr, \"([^\"..sep..\"]+)\") do t[i] = str i = i + 1 end return tendlocal a = \"23245023496830,汉字。。。。\"local b = \":\"b = StrSplit(a,\",\")print(b[1]) 数组概念&emsp;&emsp;数组就是同一类型数据，按照一定顺序排列的集合。数组可以是一维的，也可以是多维的。 &emsp;&emsp;Lua中的数组的索引键值可以使用整数表示,数组的大小是不固定的。 一维数组&emsp;&emsp;一维数组是最简单的数组，逻辑结构是线性表。一维数组可以使用for循环输出数组中的元素： 12345array = &#123;\"Hello\", \"World!\"&#125;for i= 0, 2 do print(array[i])end &emsp;&emsp;Lua的索引默认从1开始，可以指定从0甚至从负数开始，索引指定的位置没有数值返回nil。 123456789array = &#123;&#125;for i= -2, 2 do array[i] = i *2endfor i = -2,2 do print(array[i])end 多维数组&emsp;&emsp;多维数组分为两种。数组中包含数组，或者是一维数组的索引键对应一个数组。 &emsp;&emsp;三行三列多维数组： 123456789101112131415-- 初始化数组array = &#123;&#125;for i=1,3 do array[i] = &#123;&#125; for j=1,3 do array[i][j] = i*j endend-- 访问数组for i=1,3 do for j=1,3 do print(array[i][j]) endend &emsp;&emsp;不同索引键的三行三列阵列多维数组： 12345678910111213141516-- 初始化数组array = &#123;&#125;maxRows = 3maxColumns = 3for row=1,maxRows do for col=1,maxColumns do array[row*maxColumns +col] = row*col endend-- 访问数组for row=1,maxRows do for col=1,maxColumns do print(array[row*maxColumns +col]) endend 迭代器概念&emsp;&emsp;迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。 泛型for迭代器&emsp;&emsp;泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。泛型 for 迭代器提供了集合的 key/value 对，语法格式如下： 123for k, v in pairs(t) do print(k, v)end &emsp;&emsp;对于一个表来说，使用泛型for迭代器，用通俗直白的话来讲，k就是索引，v是索引对应的值，t则是这个表的表名。下面是一个实例： 12345array = &#123;\"Lua\", \"Tutorial\"&#125;for key,value in ipairs(array) do print(key, value)end &emsp;&emsp;上面的代码输出结果为： 1 Lua2 Tutorial &emsp;&emsp; 其他常用的几种遍历方式&emsp;&emsp;第一种，按照key的hash值排列的顺序遍历。 123for key, value in pairs(tbtest) do XXX end &emsp;&emsp;第二种，要求Key是连续的，从1开始的数字。ipairs只会从1开始按连续的key顺序遍历到key不连续为止。 123for key, value in ipairs(tbtest) do XXX end &emsp;&emsp;第三种，必须存在1这个key，而且是从1开始依次加一的顺序，找到一个不是1的就不再进行遍历。 123for i=1, #(tbtest) do XXX end","categories":[],"tags":[{"name":"Lua","slug":"Lua","permalink":"http://www.z16388.top/tags/Lua/"}],"keywords":[]},{"title":"Markdown编辑器Smark","slug":"smark","date":"2018-01-17T04:54:11.000Z","updated":"2018-01-17T05:06:03.245Z","comments":true,"path":"2018/01/17/smark/","link":"","permalink":"http://www.z16388.top/2018/01/17/smark/","excerpt":"","text":"&emsp;&emsp;寒假到了，毕设也做完了，回到家之后我就更换了电脑，重做了系统。经过了漫长的系统更新以及某个臃肿的IDE的安装之后，到家第二天的中午终于能够使用我的老笔记本电脑了。在开始C#学习的时候，想要开一个博客文章记录一下学习的内容的时候。发现在安装之前使用过的MarkdownPad的时候，出现了异常，研究半天也没有研究好，只得去寻找其他的Markdown编辑器。 &emsp;&emsp;我找到了一款名为Smark的编辑器。这是一个开源的编辑器，虽然三年没有更新，但是作为一款Markdown文本编辑器它还是很中规中矩的。 &emsp;&emsp;首先是安装部分。原项目的地址在https://gitee.com/elerao/Smark相关的一些介绍可以查看项目的具体信息。文中出现的链接部分失效，相关的下载内容有雷锋转移到了http://pan.baidu.com/s/1pJnrX5x。 &emsp;&emsp;我在解压后直接就能使用，不同平台和其他异常情况参见原项目的内容介绍，下面将一些使用的注意事项。 默认情况下，编辑栏在右侧，习惯之后反而觉得很方便。 没有实时渲染的功能，只能够渲染已经保存的内容。其实这个我觉得应该是一个优势，因为我经常会有写东西写一半忘了保存的时候，这个小缺陷能够随时提醒你要进行保存。没有保存的行在编辑器中会有灰色的背景标记，比较明显。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://www.z16388.top/tags/markdown/"}],"keywords":[]},{"title":"评论系统Valine的使用","slug":"valine","date":"2018-01-10T14:02:29.000Z","updated":"2018-01-10T14:26:26.872Z","comments":true,"path":"2018/01/10/valine/","link":"","permalink":"http://www.z16388.top/2018/01/10/valine/","excerpt":"","text":"&emsp;&emsp;Valine是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 &emsp;&emsp;由于某些原因，博客的一些评论系统被查水表了。忙于考研的原因，一直没有更新评论系统。今天给博客更新了一下主题，也使用了新的评论系统。 &emsp;&emsp;进入https://leancloud.cn，点击免费试用，注册账号。根据Valine创建好应用，配置好各种参数即可使用。 &emsp;&emsp;值得一提的是，头像参数最好设置为‘’，信息参数最好设置为用户名与邮箱。 &emsp;&emsp;头像信息在https://cn.gravatar.com/进行设置。 Gravatar是一图像跟随著您到访过的网站，当您在博客中留言或发表文章，它将会出现在您的名称旁。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"}],"keywords":[]},{"title":"免备案又免费的域名转发","slug":"urlchange","date":"2018-01-10T13:47:18.000Z","updated":"2018-01-11T03:40:41.463Z","comments":true,"path":"2018/01/10/urlchange/","link":"","permalink":"http://www.z16388.top/2018/01/10/urlchange/","excerpt":"","text":"&emsp;&emsp;由于.win域名的不稳定，无法备案，无法被搜索引擎收录等问题，我将博客的域名换为同样廉价的.top域名。然而Github Pages只支持一个域名的绑定，这就使我之前的域名变得无法使用。但是我通过各种渠道去宣传，使用这个域名已经很久了，更换起来也比较麻烦。因此，只能维持.win域名，明进行显式的域名转发。 &emsp;&emsp;万网的域名转发转功能有两个条件，一是必须是万网的域名，二是域名要进行备案。Github Pages无法进行备案，因此不能直接使用万网的解析。 &emsp;&emsp;经过测试，米发的域名转发功能最方便。https://www.mfpad.com/ &emsp;&emsp;注册账号，添加域名，然后将域名解析到米发分配的CNAME即可。当然，@和www都要进行一次记录。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"},{"name":"域名","slug":"域名","permalink":"http://www.z16388.top/tags/域名/"}],"keywords":[]},{"title":"QT笔记-基础篇","slug":"qt","date":"2017-07-12T07:46:28.000Z","updated":"2017-07-12T15:26:41.906Z","comments":true,"path":"2017/07/12/qt/","link":"","permalink":"http://www.z16388.top/2017/07/12/qt/","excerpt":"","text":"基础部分修改某个控件显示的文字（优先级比属性高）123ui-&gt;pushButton-&gt;setText(tr(\"新的\"));//在软件中应避免直接出现中文字符串，应该使用tr()函数包含//这段代码如果用于控件的初始化，应当写在构造函数中 弹出警告对话框 需要使用头文件QMessageBox 123QMessageBox::warning(this, tr(\"警告！\"), tr(\"用户名或密码错误！\"), QMessageBox::Yes); &emsp;&emsp;从上面的例子我们可以看出这个函数的参数分别为：父窗口、对话框标题、对话框的显示内容、对话框中的按钮。也就是说，上面这段代码实现的是弹出一个提示密码输入错误的，带有一个Yes按钮的警告对话框。 &emsp;&emsp; 注：需要使用头文件 #include 登陆窗口的创建步骤 在项目视图中，右键-&gt;添加文件-&gt;QT-&gt;QT设计师界面类 在创建好的登陆窗口中新建一个按钮，切换成“控件和槽编辑模式”，拖动按钮，放开鼠标后，会弹出配置连接对话框。将pushButton的clicked()信号和LoginDlg的accept()槽关联起来。其中，accept()槽的功能是：将对话框关闭并返回QDialog::Accepted标识。 修改main函数：12345678910111213141516#include \"mainwindow.h\"#include &lt;QApplication&gt;#include \"logindlg.h\" // 增加登陆窗口的头文件int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; LoginDlg dlg; // 声明 if(dlg.exec() == QDialog::Accepted) // 利用Accepted返回值判断按钮是否被按下 &#123; w.show(); // 如果被按下，显示主窗口 return a.exec(); // 程序一直执行，直到主窗口关闭 &#125; else return 0; // 如果没有被按下，则不会进入主窗口，整个程序结束运行&#125; &emsp;&emsp;在上面的代码中，我们首先创建了LoginDlg类的对象dlg，然后让dlg运行，即执行exec()函数，然后判断它的返回值。如果用户按下了按钮，那么返回值应该是Accepted，这个时候就会显示主窗口，并正常执行程序；否则，结束程序。 &emsp;&emsp;另外，在平时写程序的时候，我们需要控制Accepted返回值，可以使用accept()函数。以点击登陆按钮直接进入为例：1234void LoginDialog::on_loginBtn_clicked()&#123; accept();&#125; 密码输入框&emsp;&emsp;首先，新建一个文本条。然后在这个文本条所在的窗口的构造函数中将它的EchoMode属性更改为密码条就行了。例子如下：1ui-&gt;pswEdit-&gt;setEchoMode(QLineEdit::Password); 去除输入中的空格&emsp;&emsp;使用函数trimmed() 清除文本条、光标定位12ui-&gt;usrLineEdit-&gt;clear();ui-&gt;usrLineEdit-&gt;setFocus(); 创建新窗口之后、原窗口不消失的窗口 对一个按钮右键-&gt;”转到槽”； 选择“clicked()”信号，确定，然后自动转到当前窗口代码编辑模式中的on_pushButton_clicked()函数处； 补充函数体：（需要添加头文件#include ）12345void MainWindow::on_pushButton_clicked()&#123; QDialog *dlg = new QDialog(this); dlg-&gt;show(); &#125; &emsp;&emsp;在上面的代码中实现了创建一个对话框对象，然后让它显示出来，创建时指定的this参数表明这个对话框的父窗口是MainWindow。 &emsp;&emsp;这种方法，会让我们每按一次按钮，都会生成一个新的对话框。但是在这个过程中，不会造成内存泄漏或者是内存耗尽，这得益于QT的对象机制，保证了不会造成内存泄漏，而且不需要使用delete语句。 &emsp;&emsp;在日常使用的过程中，我们可以在mainwindow.h文件中先定义一个对话框对象，并在构造函数中进行创建，再在这里使用。 创建一个退出按钮 单击设计模式下方的信号和槽编辑器（Signals &amp; Slots Editor）中的绿色加法号添加关联； 发送者为按钮，信号为clicked()，接受者为当前窗口，操为close()。 QT Creator常用命令Ctrl+滚轮：控制字体大小 Ctrl+1~6：切换左侧边栏，如常用的Ctrl+2(编辑)、Ctrl+3(设计) Ctrl+R：编译 F3：控件编辑模式 F4：信号和槽编辑模式 参考文档API和文档 QT开源社区 教程目录","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"http://www.z16388.top/tags/QT/"}],"keywords":[]},{"title":"数学模型中的Huntington除数法","slug":"Huntington","date":"2017-05-19T14:36:44.000Z","updated":"2017-05-22T10:42:40.359Z","comments":true,"path":"2017/05/19/Huntington/","link":"","permalink":"http://www.z16388.top/2017/05/19/Huntington/","excerpt":"","text":"本篇博客请结合《数学模型（第四版）》，姜启源版教材第八章第四节内容阅读。 &emsp;&emsp;在处理席位分析问题时，常使用Huntington除数法来进行处理。在书中279~281的学习中，我们了解到了怎样去比较一个分配结果的不公平度，以及一个较惯例分配法更加公平的“Q值法”。那么，下面我将介绍一种处理这类问题的通用方法，Huntington除数法。 &emsp;&emsp;Edward Vermilye Huntington(1874~1952)，1922年获得哈佛大学博士学位。20世纪20年代，他对这个问题做了具体的研究，提出了一系列的席位分配方法。之前介绍过的“Q值法”，也作为其中的一种情况，包含在内。 &emsp;&emsp;假设共有m方分配N个席位，第i方的人数记为pi,ni表示第i方分配的席位数，且均为非负整数。 Huntington除数法 除数&emsp;d(n) 不公平度的度量指标(假定pi/ni&gt;pj/nj) 最大除数法(GD) n+1 (nj-pi)/pj-ni 主要分数法(MF) n+1/2 (nj/pj)-(ni-pi) 相等比例法(EP) sqrt(n(n+1)) (njpi)/(nipj)-1 调和平均法(HM) 2n(n+1)/(2n+1) pi/ni-pj/nj 最小除数法(SD) n nj-nipj/pi &emsp;&emsp;下面是这个方法的思路：首先，我们对每一方都分配一个席位，然后利用选定的衡量指标，计算出每一方的不公平度。给最大的那一组，分配一个席位，然后继续计算，直到将所有席位分配完毕。一般情况下，在使用Huntington除数法时，通常在各方自动分得1席的基础上在做分配，除非在各方人数悬殊且席位数较少的时候。 &emsp;&emsp;由于在计算的过程中，采用了每增加1席计算一次的方式，因此不会出现席位悖论和人口悖论。 &emsp;&emsp;下面是C语言写的Huntington算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int w;FILE *fin=fopen(\"in.txt\",\"r\");double dn(int n)&#123; switch(w) &#123; case 1:return n+1.0; case 2:return n+0.5; case 3:return sqrt(n*(n+1.0)); case 4:return 2*n*(n+1.0)/(2*n+1); case 5:return n; default:return 0; &#125;&#125;void Huntington()&#123; int s,flag=0,bh=1; double p[6],pd[6]; int n[6]; double max_pd; fscanf(fin,\"%d\",&amp;s); for(int i=1;i&lt;=5;i++) &#123; fscanf(fin,\"%lf\",&amp;p[i]); &#125; for(int i=1;i&lt;=5;i++) &#123; n[i]=1; &#125; while(n[1]+n[2]+n[3]+n[4]+n[5]!=s) &#123; flag=1; for(int i=1;i&lt;=5;i++) &#123; pd[i] = p[i]/dn(n[i]); &#125; max_pd = p[1]/dn(n[1]); for(int i=2;i&lt;=5;i++) &#123; if(pd[i]&gt;max_pd) &#123; flag = i,max_pd = pd[i]; &#125; &#125; n[flag]++; cout&lt;&lt;\"第\"&lt;&lt;bh++&lt;&lt;\"次：\"&lt;&lt;endl; for(int i=1;i&lt;=5;i++) cout&lt;&lt;\"p/di=\"&lt;&lt;pd[i]&lt;&lt;\" n=\"&lt;&lt;n[i]&lt;&lt;endl; cout&lt;&lt;\"--------------------\"&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125;void printList()&#123; cout&lt;&lt;\"#请选择需要模拟的权重函数#\"&lt;&lt;endl; cout&lt;&lt;\"1.最大除数法(GD)\"&lt;&lt;endl; cout&lt;&lt;\"2.主要分数法(MF)\"&lt;&lt;endl; cout&lt;&lt;\"3.相等比例法(EP)\"&lt;&lt;endl; cout&lt;&lt;\"4.调和平均法(HM)\"&lt;&lt;endl; cout&lt;&lt;\"5.最小除数法(SD)\"&lt;&lt;endl; cout&lt;&lt;\"--------------------\"&lt;&lt;endl; cout&lt;&lt;\"退出请输入0\"&lt;&lt;endl;&#125;void select()&#123; printList(); while(cin&gt;&gt;w) &#123; switch (w) &#123; case 1:case 2:case 3:case 4:case 5: Huntington(); select(); break; case 0:fclose(fin);exit(0); default: cout&lt;&lt;\"输入错误，请重新输入\"&lt;&lt;endl; cout&lt;&lt;\"--------------------\"&lt;&lt;endl; select(); &#125; &#125;&#125;int main()&#123; select(); fclose(fin); return 0;&#125; &emsp;&emsp;GD法偏向于人数多的组，SD法偏向于人数少的组。Huntington推荐偏向适中的EP法，也就是“Q值法”，该方法在1930年后一直在被美国国会众议员席位分配中采用。","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.z16388.top/tags/数学/"},{"name":"数学模型","slug":"数学模型","permalink":"http://www.z16388.top/tags/数学模型/"}],"keywords":[]},{"title":"VS调试时提示找不到msvcr80d.dll解决方案","slug":"vs1","date":"2017-04-15T02:18:53.000Z","updated":"2017-04-15T02:30:57.722Z","comments":true,"path":"2017/04/15/vs1/","link":"","permalink":"http://www.z16388.top/2017/04/15/vs1/","excerpt":"","text":"&emsp;&emsp;在学校的很多课程中，需要使用到Visual Studio。在编写程序进行调试的时候，经常会出现报错“找不到msvcr80d.dll”的情况，让人很头疼。 &emsp;&emsp;这个是由于调试类型和硬盘的格式造成的。在学校机房的环境里，可以进行一下的步骤解决问题： 项目 -&gt; [项目名] 属性 -&gt; 配置属性 -&gt; 清单工具 -&gt; 常规 -&gt; 将“使用FAT解决办法”的属性设置为“是”。 进行设置之后，保存，执行: 生成 -&gt; 重新生成解决方案 重新调试","categories":[],"tags":[{"name":"Visual-Studio","slug":"Visual-Studio","permalink":"http://www.z16388.top/tags/Visual-Studio/"}],"keywords":[]},{"title":"dfs专项练习","slug":"dfs","date":"2017-03-30T10:52:27.000Z","updated":"2018-01-10T13:39:57.471Z","comments":true,"path":"2017/03/30/dfs/","link":"","permalink":"http://www.z16388.top/2017/03/30/dfs/","excerpt":"","text":"poj1664:放苹果 hdu1016:素数环问题 hdu2553:N皇后问题 hdu1584:蜘蛛牌 hdu1181:变形课","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】3.8从全排列到深度优先搜索dfs算法","slug":"【ACM教程】3-8从全排列到深度优先搜索dfs算法","date":"2017-03-22T08:37:34.000Z","updated":"2018-01-10T12:18:33.065Z","comments":true,"path":"2017/03/22/【ACM教程】3-8从全排列到深度优先搜索dfs算法/","link":"","permalink":"http://www.z16388.top/2017/03/22/【ACM教程】3-8从全排列到深度优先搜索dfs算法/","excerpt":"","text":"第八节 从全排列到深度优先搜索算法全排列&emsp;&emsp;什么是全排列？就是一组数据所有可能的排列顺序。如果使用暴力枚举的方法，需要对每一个位置都进行一次循环，如果有n个数据则需要循环n次，而且还要加上对重复序列的判断。 &emsp;&emsp;可喜的是，在STL中有两个函数可以帮我们实现字典序的全排列。他们分别是：next_permutation()prev_permutation()，参数是数据的开始和结束地址。举个例子，比如一个字符数组：a,b,c，它的下一个序列就是a,c,b。在处理全排列问题的时候，使用比较方便。这两个函数在算法头文件中。 &emsp;&emsp;由于这两个函数是根据字典序来给出下一个全排列，如果想要得出所有的全排列，则需要首先对序列进行排序。 &emsp;&emsp;蓝桥杯中很多题目可以使用这种方法来解决，以第七届蓝桥杯的第三题为例： B DEFA + —— + ——— = 10 C GHI这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。比如：6+8/3+952/714 就是一种解法，5+3/1+972/486 是另一种解法。这个算式一共有多少种解法？注意：你提交应该是个整数，不要填写任何多余的内容或说明性文字。 &emsp;&emsp;代码如下： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]; int i; int sum[4]; int ans; for(i=1;i&lt;=9;++i)&#123; a[i]=i; &#125; ans=0; do&#123; sum[0]=a[1]*a[3]*(a[7]*100+a[8]*10+a[9]); sum[1]=a[2]*(a[7]*100+a[8]*10+a[9]); sum[2]=(a[4]*100+a[5]*10+a[6])*a[3]; sum[3]=10*a[3]*(a[7]*100+a[8]*10+a[9]); if(sum[0]+sum[1]+sum[2]==sum[3])&#123; ++ans; &#125; &#125;while(next_permutation(a+1,a+1+9)); printf(\"%d\\n\",ans); return 0;&#125; 深度优先搜索dfs算法&emsp;&emsp;突然想要感叹一句：终于要讲到dfs算法了。为什么要发出这样的感叹呢，因为从这里开始，我们真正要接触到算法的内容了。之前的学习都可以说是小打小闹，到这里再是正主。 &emsp;&emsp;事实上，深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。dfs算法是算法学习过程中的重中之重，因为全排列是个一维的过程，为了便于大家的理解，我就从它开始吧。 &emsp;&emsp;有a、b、c三个盒子，以及1，2，3三只球。我们将球放到盒子里，每个盒子只能放一个球，求一共有几种放法。如果形象地形容这个全排列的过程，将会是这个样子：首先按照字典序顺序放球，也就是在a盒子中放1号球，b盒子中放2号球，c盒子中放3号球。再向后走就没有盒子了，同时我们手中也没有剩余球了。这个时候，往回走，寻找有没有其他的放球顺序。先回到c盒子前拿出3号球，再到b盒子前拿出2号球。这时候，又产生了一种排列方式：把3号球放到b盒子中，2号球放到c盒子中。接下来以此类推，产生剩余的序列。 &emsp;&emsp;那么，我们把上面的过程用程序来模拟一下。首先是第一种放置方法，先按照升序将球放好： 123for(int i=1;i&lt;=n;i++) &#123; a[step] = i;&#125; &emsp;&emsp;这里的数组a表示盒子的序列，变量step表示我们正处在第step个盒子的前面。a[step]=i的意思就是将第i个球放到第step个盒子里。但是需要注意的是，球一旦放进一个盒子里，就不能放在另一个盒子里了。这时候，我们需要记录一下。 123456for(int i;i&lt;=n;i++) &#123; if(book[i]==0) &#123; //book[i]==0表示球还在我们手上 a[step]=i; book[i]=1; //标记i号球已经放到盒子里了 &#125;&#125; &emsp;&emsp;那么，我们既然在第step个盒子里放球了，后面就要继续向后放了。很明显，这是一个递归的过程。我们将要写的过程封装到函数里，将这个函数命名为dfs。然后在里面处理第step+1个盒子。 12345678910void dfs(int step) &#123; for(int i;i&lt;=n;i++) &#123; if(book[i]==0) &#123; a[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125;&#125; &emsp;&emsp;细心的同学可能已经注意到了，除了除以step+1个盒子之外，我们还另外加了一行代码book[i]=0，为什么要加上这一句呢？我们想一下，递归放完所有的球之后，我们是不是在回来的过程中要将这个球从盒子里拿出来呀。如果没有这个操作，这将会对接下来的放置造成障碍。 &emsp;&emsp;在之前的学习中，我们都知道，递归必须要有一个停止条件。转换到这个问题中就是：我们应该在什么时候将计算完毕的全排列输出出来呢？答案是处理到第n+1个盒子时。在前面的“故事背景”中，我们在走到第四个盒子的位置时，发现这个地方没有盒子，就往回走了。这个时候就是要输出的时候。代码如下： 1234567891011121314151617void dfs(int step) &#123; if(step==n+1) &#123; for(int i=1;i&lt;=n;i++) &#123; printf(\"%d\",a[i]); &#125; printf(\"\\n\"); return; //返回前一步 &#125; for(int i;i&lt;=n;i++) &#123; if(book[i]==0) &#123; a[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125;&#125; &emsp;&emsp;整个过程我们模拟完毕了，整理得到完整的代码： 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int a[10],book[10],n;void dfs(int step) &#123; if(step==n+1) &#123; for(int i=1;i&lt;=n;i++) &#123; printf(\"%d\",a[i]); &#125; printf(\"\\n\"); return; //返回前一步 &#125; for(int i;i&lt;=n;i++) &#123; if(book[i]==0) &#123; a[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125;&#125;int main() &#123; scanf(\"%d\",&amp;n); dfs(1); return 0;&#125; &emsp;&emsp;这个问题虽然简单，但是包含了dfs的基本模型。理解dfs算法的关键在于理解“当下应该如何去做”。至于“下一步应该怎么做”是和当下的操作一样的。我们在处理第step个盒子和step+1个盒子的时候，都采用的是一样的操作。因此，我们可以整理出dfs的基本模型： 1234567void dfs(int step) &#123; 判断边界 尝试所有的可能 for(int i=1;i&lt;=n;i++) &#123; 继续下一步 dfs(step+1) &#125; 返回&#125; &emsp;&emsp;我们以一道题目为例，第七届蓝桥杯的第七题，剪邮票： 如【图1.jpg】, 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连）比如，【图2.jpg】，【图3.jpg】中，粉红色所示部分就是合格的剪取。请你计算，一共有多少种不同的剪取方法。请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 图1 图2 图3 &emsp;&emsp;我们先看一下一位同学错误的解法吧：http://blog.csdn.net/star92014/article/details/50942239 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;int a[5]=&#123;0,&#125;;int check()&#123; int flag[5]=&#123;0,&#125;; flag[0]=1; int check[5]=&#123;0,&#125;; int i,j;rep: for(i=0;i&lt;5;i++)&#123; if(flag[i]&amp;&amp;check[i]==0)&#123; check[i]=1; for(j=0;j&lt;5;j++)&#123; if(j==i)continue; if(a[j]==a[i]+1||a[j]==a[i]-1 ||a[j]==a[i]-4||a[j]==a[i]+4)&#123; flag[j]=1; &#125; &#125; &#125; &#125; for(i=0;i&lt;5;i++)&#123; if(flag[i]&amp;&amp;check[i]==0)goto rep; &#125; int count=0; for(i=0;i&lt;5;i++)&#123; if(flag[i])count++; &#125; if(count==5)return 1; else return 0;&#125;int main()&#123; int count=0; for(a[0]=1;a[0]&lt;13;a[0]++)&#123; for(a[1]=a[0]+1;a[1]&lt;13;a[1]++)&#123; // if(a[1]==a[0])continue; for(a[2]=a[1]+1;a[2]&lt;13;a[2]++)&#123; // if(a[2]==a[0]||a[2]==a[1])continue; for(a[3]=a[2]+1;a[3]&lt;13;a[3]++)&#123; // if(a[3]==a[0]||a[3]==a[1]||a[3]==a[2])continue; for(a[4]=a[3]+1;a[4]&lt;13;a[4]++)&#123; //if(a[4]==a[0]||a[4]==a[1]||a[4]==a[2]||a[4]==a[3])continue; if(check())&#123; printf(\"%d %d %d %d %d\\n\",a[0],a[1],a[2],a[3],a[4]); count++; &#125; &#125; &#125; &#125; &#125; &#125; printf(\"%d\",count); return 0;&#125; &emsp;&emsp;代码质量不说，这位同学得到的答案是202，是错误的。那么问题出在了哪里呢？是序列的重复问题。比如12345和12354。为了避免这种情况，我们除了增加判断条件之外，还可以从数据上入手，将序列改为{1,2,3,4,6,7,8,9,11,12,13,14};这样，在判断换行之后的左右侧元素时，就会有失效的元素，避免了重复。下面是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int dir[4] = &#123;1,-1,5,-5&#125;;int temp1[12] = &#123;1,2,3,4,6,7,8,9,11,12,13,14&#125;;int temp2[5];int vis[5];int ans = 0;void dfs(int u)&#123; for(int i=0 ;i&lt;4 ;i++)&#123; int t = temp2[u]+dir[i]; if(t&gt;=1&amp;&amp;t&lt;=14)&#123; for(int j=0 ;j&lt;5 ;j++) if(t==temp2[j]&amp;&amp;!vis[j])&#123; vis[j]=1; dfs(j); &#125; &#125; &#125;&#125;int main()&#123; for(int a=0 ;a&lt;12 ;a++)&#123; for(int b=a+1 ;b&lt;12 ;b++)&#123; for(int c=b+1 ;c&lt;12 ;c++)&#123; for(int d=c+1 ;d&lt;12 ;d++)&#123; for(int e=d+1 ;e&lt;12 ;e++)&#123; temp2[0]=temp1[a]; temp2[1]=temp1[b]; temp2[2]=temp1[c]; temp2[3]=temp1[d]; temp2[4]=temp1[e]; //初始化访问标记数组 memset(vis,0,sizeof(vis)); vis[0]=1; dfs(0); //连通性判断 int flag = 1; for(int i=0 ;i&lt;5 ;i++)&#123; if(vis[i]==0)&#123; flag = 0; &#125; &#125; if(flag)ans++; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125; &emsp;&emsp;DFS专项练习：http://www.z16388.top/2017/03/30/dfs/","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】2.5数学简单问题","slug":"【ACM教程】2-5数学简单问题","date":"2017-03-22T07:25:01.000Z","updated":"2017-04-13T13:25:15.894Z","comments":true,"path":"2017/03/22/【ACM教程】2-5数学简单问题/","link":"","permalink":"http://www.z16388.top/2017/03/22/【ACM教程】2-5数学简单问题/","excerpt":"","text":"第五节 数学简单问题&emsp;&emsp;竞赛中的很多题目会考到数学相关的知识，在这一节，我们会挑出一些简单的问题集中讲解。 最大公约数/最小公倍数&emsp;&emsp;首先我们要介绍一个算法，欧几里德算法。欧几里得是著名的古希腊数学家，被称为“几何学之父”，代表作为《几何原本》。 &emsp;&emsp;欧几里得算法又称辗转相除算法，定理如下：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。（最大公约数缩写为gcd）在这里就不作证明了，直接给出代码： 123456789int gcd(int a,int b) //最大公约数&#123; if(b==0) return a; else return gcd(b,a%b);&#125;int lcm(int a,int b) //最小公倍数&#123; return a/gcd(a,b)*b;&#125; 判断素数&emsp;&emsp;什么是素数呢？素数是大于等于2的，只有1和他本身能够整除他的数。要去判断一个数n是否是素数，只要从2到sqrt(n)依次判断即可，代码如下： 1234567int su(int b)&#123; for(int i=2;i&lt;=(int)sqrt(b);i++) &#123; if(b%i==0) return 0; &#125; return 1;&#125; 排列组合打表12345678910int c[N][N];void com() &#123; memset(c,0,sizeof(c)); for(int i=1;i&lt;N;i++) &#123; c[i][0]=c[i][i]=1; for(int j=1;j&lt;i;j++) &#123; c[i][j]=c[i-1][j]+c[i-1][j-1]; &#125; &#125;&#125; 快速幂&emsp;&emsp;求a的b次幂，我们可以直接使用for循环去做。但是当b很大的时候，就会花费很多时间，这时候需要使用快速幂算法。 &emsp;&emsp;下面我们就以求a^11为例，介绍一下快速幂算法。 将11转化为二进制——1011 分解：11=1*2^3+0*2^2+1*2^1+1*2^0 将a^11转化为a^(2^3)*a^(2^1)*a^(2^0) &emsp;&emsp;代码如下： 123456789int Fast(int x,int n) &#123; int tem=x,ans=1; while(n) &#123; if(n%2==1) ans*=tem; tem*=tem; n&gt;&gt;=1; &#125; return ans;&#125; 快速幂取模&emsp;&emsp;公式：a*b%c=((a%c)*b)%c&emsp;&emsp;(a+b)%c=(a%c+b%c)%c 123456789int pow(int a,int x) &#123; int ans=1,temp=a%p; while(x) &#123; if(x&amp;1) ans=((long long)ans*temp)%p; temp=((long long)temp*temp)%p; x&gt;&gt;=1; &#125; return ans;&#125; 十进制转换为x进制1234567891011121314string trans(int num,int base) &#123; string str; while(num&gt;0) &#123; if(num%base&lt;10) &#123; str+=num%base+'0'; &#125; else &#123; str+=num%base-10+'A'; &#125; num=num/base; &#125; reverse(str.begin(),str.end()); return str;&#125; 常用的数学公式等差数列求和公式： Sn=n*a1+n(n-1)d/2Sn=n(a1+an)/2 等比数列求和公式： Sn=a1(1-q^n)/(1-q)","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"第六届蓝桥杯C/C++省赛B组题目详解","slug":"lanqiao6","date":"2017-03-21T11:57:34.000Z","updated":"2017-04-13T13:25:15.864Z","comments":true,"path":"2017/03/21/lanqiao6/","link":"","permalink":"http://www.z16388.top/2017/03/21/lanqiao6/","excerpt":"","text":"第一题 奖券数目 有些人很迷信数字，比如带“4”的数字，认为和“死”谐音，就觉得不吉利。虽然这些说法纯属无稽之谈，但有时还要迎合大众的需求。某抽奖活动的奖券号码是5位数（10000-99999），要求其中不要出现带“4”的号码，主办单位请你计算一下，如果任何两张奖券不重号，最多可发出奖券多少张。请提交该数字（一个整数），不要写任何多余的内容或说明性文字。 &emsp;&emsp;这道题虽然可以使用穷举法去做，但是其实是一道“稿纸题”。分析每一位上面数的可能性，直接使用8*9*9*9*9即可计算出来。最终答案为：52488 第二题 星系炸弹 在X星系的广袤空间中漂浮着许多X星人造“炸弹”，用来作为宇宙中的路标。每个炸弹都可以设定多少天之后爆炸。比如：阿尔法炸弹2015年1月1日放置，定时为15天，则它在2015年1月16日爆炸。有一个贝塔炸弹，2014年11月9日放置，定时为1000天，请你计算它爆炸的准确日期。请填写该日期，格式为yyyy-mm-dd 即4位年份2位月份2位日期。比如：2015-02-19 &emsp;&emsp;这是一道简单的日期计算问题。掌握好每个月的天数，然后计算。当然，也可以是一道稿纸题。 &emsp;&emsp;最终答案为：2017-08-05 第三题 三羊献瑞 观察下面的加法算式： 祥 瑞生 辉 三羊 献 瑞-——————三 羊 生 瑞 气其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字。请你填写“三羊献瑞”所代表的4位数字（答案唯一），不要填写任何多余内容。 &emsp;&emsp;经典的蓝桥题目，直接暴力枚举就可以。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123;/* int xiang,rui,sheng,hui; int san,yang,xian,rui; int san,yang,sheng,rui,qi;*/ int xiang,rui,sheng,hui; int san,yang,xian; int qi; int a,b,c; for(xiang=1;xiang&lt;=9;++xiang)&#123; for(rui=0;rui&lt;=9;++rui)&#123; if(rui==xiang)continue; for(sheng=0;sheng&lt;=9;++sheng)&#123; if(sheng==xiang||sheng==rui)continue; for(hui=0;hui&lt;=9;++hui)&#123; if(hui==xiang||hui==rui||hui==sheng)continue; for(san=1;san&lt;=9;++san)&#123; if(san==xiang||san==rui||san==sheng||san==hui)continue; for(yang=0;yang&lt;=9;++yang)&#123; if(yang==xiang||yang==rui||yang==sheng||yang==hui||yang==san)continue; for(xian=0;xian&lt;=9;++xian)&#123; if(xian==xiang||xian==rui||xian==sheng||xian==hui||xian==san||xian==yang)continue; for(qi=0;qi&lt;=9;++qi)&#123; if(qi==xiang||qi==rui||qi==sheng||qi==hui||qi==san||qi==yang||qi==xian)continue; a=xiang*1000+rui*100+sheng*10+hui; b=san*1000+yang*100+xian*10+rui; c=san*10000+yang*1000+sheng*100+rui*10+qi; if(a+b==c)&#123; //printf(\"%d+%d=%d\\n\",a,b,c); printf(\"%d %d %d %d\\n\",san,yang,xian,rui); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; return 0;&#125; 第四题 格子中输出 格子中输出StringInGrid函数会在一个指定大小的格子中打印指定的字符串。要求字符串在水平、垂直两个方向上都居中。如果字符串太长，就截断。如果不能恰好居中，可以稍稍偏左或者偏上一点。下面的程序实现这个逻辑，请填写划线部分缺少的代码。对于题目中数据，应该输出：+——————+|&emsp;&emsp;&emsp;&emsp;&emsp;|| abcd1234 ||&emsp;&emsp;&emsp;&emsp;&emsp;||&emsp;&emsp;&emsp;&emsp;&emsp;|+——————+ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;void StringInGrid(int width, int height, const char* s)&#123; int i,k; char buf[1000]; strcpy(buf, s); if(strlen(s)&gt;width-2) buf[width-2]=0; printf(\"+\"); for(i=0;i&lt;width-2;i++) printf(\"-\"); printf(\"+\\n\"); for(k=1; k&lt;(height-1)/2;k++)&#123; printf(\"|\"); for(i=0;i&lt;width-2;i++) printf(\" \"); printf(\"|\\n\"); &#125; printf(\"|\"); printf(\"%*s%s%*s\",_____________________________________________); //填空 printf(\"|\\n\"); for(k=(height-1)/2+1; k&lt;height-1; k++)&#123; printf(\"|\"); for(i=0;i&lt;width-2;i++) printf(\" \"); printf(\"|\\n\"); &#125; printf(\"+\"); for(i=0;i&lt;width-2;i++) printf(\"-\"); printf(\"+\\n\"); &#125;int main()&#123; StringInGrid(20,6,\"abcd1234\"); return 0;&#125; 答案是： 1(width-strlen(buf)-2)/2,\"\",buf,(width-strlen(buf)-2+1)/2,\"\" &emsp;&emsp;C语言语法考题，太过于变态，基本没有做出来的。这道题不必深究。 第五题 九数组分数 九数组分数1,2,3…9 这九个数字组成一个分数，其值恰好为1/3，如何组法？下面的程序实现了该功能，请填写划线部分缺失的代码。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;void test(int x[])&#123; int a = x[0]*1000 + x[1]*100 + x[2]*10 + x[3]; int b = x[4]*10000 + x[5]*1000 + x[6]*100 + x[7]*10 + x[8]; if(a*3==b) printf(\"%d / %d\\n\", a, b);&#125;void f(int x[], int k)&#123; int i,t; if(k&gt;=9)&#123; test(x); return; &#125; for(i=k; i&lt;9; i++)&#123; &#123;t=x[k]; x[k]=x[i]; x[i]=t;&#125; f(x,k+1); _____________________________________________ // 填空处 &#125;&#125; int main()&#123; int x[] = &#123;1,2,3,4,5,6,7,8,9&#125;; f(x,0); return 0;&#125; &emsp;&emsp;水题，答案： 1&#123;t=x[k]; x[k]=x[i]; x[i]=t;&#125; 第六题 加法变乘法 我们都知道：1+2+3+… + 49 = 1225现在要求你把其中两个不相邻的加号变成乘号，使得结果为2015比如：1+2+3+…+10*11+12+…+27*28+29+…+49 =2015就是符合要求的答案。请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int i,j; int a,b; for(i=1;i&lt;=49;++i)&#123; for(j=i+2;j&lt;=49;++j)&#123; a=1225-(i+i+1)-(j+j+1); b=2015-(i*(i+1))-(j*(j+1)); if(a==b)&#123; printf(\"i=%d,j=%d\\n\",i,j); &#125; &#125; &#125; return 0;&#125; &emsp;&emsp;暴力枚举，枚举所有的可能的两个位置，用1225和2015分别减去这两个位置的值，看看是否相等。 第七题 牌型种数 小明被劫持到X赌城，被迫与其他3人玩牌。一副扑克牌（去掉大小王牌，共52张），均匀发给4个人，每个人13张。这时，小明脑子里突然冒出一个问题：如果不考虑花色，只考虑点数，也不考虑自己得到的牌的先后顺序，自己手里能拿到的初始牌型组合一共有多少种呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,aJ,aQ,aK; int sum=0; for(a1=0;a1&lt;=4;++a1)&#123; for(a2=0;a2&lt;=4;++a2)&#123; for(a3=0;a3&lt;=4;++a3)&#123; for(a4=0;a4&lt;=4;++a4)&#123; for(a5=0;a5&lt;=4;++a5)&#123; for(a6=0;a6&lt;=4;++a6)&#123; for(a7=0;a7&lt;=4;++a7)&#123; for(a8=0;a8&lt;=4;++a8)&#123; for(a9=0;a9&lt;=4;++a9)&#123; for(a10=0;a10&lt;=4;++a10)&#123; for(aJ=0;aJ&lt;=4;++aJ)&#123; for(aQ=0;aQ&lt;=4;++aQ)&#123; for(aK=0;aK&lt;=4;++aK)&#123; if(a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+aJ+aQ+aK==13)&#123; ++sum; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\",sum); return 0;&#125; &emsp;&emsp;当然，我们也可以用dfs来解决这道题。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int sum;void dfs(int cur,int tol)&#123; if(tol&gt;13) return; if(cur==14)&#123;//13种牌都拿完了 if(tol==13)&#123;//手里13张牌了 ++sum; &#125; return; &#125; int i; for(i=0;i&lt;=4;++i)&#123; dfs(cur+1,tol+i); &#125;&#125;int main()&#123; sum=0; dfs(1,0);//从第1张牌开始选，当前手中有0张 printf(\"%d\\n\",sum); return 0;&#125; 第八题 移动距离 X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3…当排满一行时，从下一行相邻的楼往反方向排号。比如：当小区排号宽度为6时，开始情形如下： 1 2 3 4 5 612 11 10 9 8 713 14 15 …..我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动）输入为3个整数w m n，空格分开，都在1到10000范围内w为排号宽度，m,n为待计算的楼号。要求输出一个整数，表示m n两楼间最短移动距离。例如：用户输入：6 8 2则，程序应该输出：4再例如：用户输入：4 7 20则，程序应该输出：5资源约定：峰值内存消耗","categories":[],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://www.z16388.top/tags/蓝桥杯/"}],"keywords":[]},{"title":"GJB5369考点笔记","slug":"GJB5369考点笔记","date":"2017-03-18T02:35:42.000Z","updated":"2017-04-13T13:25:20.921Z","comments":true,"path":"2017/03/18/GJB5369考点笔记/","link":"","permalink":"http://www.z16388.top/2017/03/18/GJB5369考点笔记/","excerpt":"","text":"启用规则 禁止使用嵌套的注释 建议不适用单行的注释“//” 禁止使用不适合的循环变量类型（循环变量类型应为int） 循环变量必须是局部声明的 谨慎使用无限循环语句 避免在循环中使用break语句 谨慎使用无法控制的循环条件 禁止对指针变量使用强制类型转换赋值 谨慎使用其他类型变量给指针赋值 避免使用不必要的类型转换 枚举元素的初始化必须完整 结构体变量初始化的类型必须一致 结构体变量初始化的嵌套结构必须与定义的相一致 变量使用前必须被赋过值 禁止对实数类型的量做是否相等的比较 禁止逻辑判别的表达式不是逻辑表达式 switch语句中的表达式禁止是逻辑表达式 建议逻辑表达式采用显式的表达 禁止枚举类型中的元素名与已有的变量名同名 禁止局部变量与全局变量同名 禁止形参名与全局变量名同名 禁止形参名与类型或标识符同名 禁止在内部块中重定义已有的变量名 禁止复杂表达式中使用volatile类型的变量 在源程序中谨慎使用非标准字符 禁止使用预处理操作符#和## 过程名禁止被重用 禁止过程或函数中的参数表为空 禁止在同一个宏中使用多个#或## 禁止定义不像函数的宏 禁止在宏中包含不允许的项 禁止重新定义保留字 字符型变量必须明确定义是有符号还是无符号 禁止对一个名字重新定义 用typedef自定义的类型禁止被重定义 禁止在同一个文件中有#if而没有#endif 禁止数组没有边界限定 标号名禁止被重用 禁止在#include&lt;&gt;中使用绝对的路径名 禁止结构体声明不完整 禁止结构体定义中含有空域 禁止声明多重标号 在过程声明中必须对参数说明 禁止过程参数只有类型没有标识符 禁止在过程参数表中使用省略号 禁止重新定义使用C或C++的关键字 建议使用typedef在统一的变量声明头文件中对基本的变量类型重新定义 避免将过程定义为参数 过程中避免使用过多的参数，建议不要超过20个 在结构体定义中谨慎使用位域 禁止在块中使用#define或#undef 谨慎使用#pragma 谨慎使用联合(union)的声明 在结构体中谨慎使用无名位域 main必须定义为int main(void)或int main(int,char*[])的形式 循环体必须用大括号括起来 then/else中的语句必须用大括号括起来 逻辑表达式的连接必须使用括号 禁止在头文件前有可执行的代码 宏参数必须用括号括起来 嵌入汇编程序的过程必须是纯汇编程序 头文件名禁止使用“‘”,”、”,”\\”和”#”等字符 禁止字符串中单独使用”\\”，字符串的终止必须使用”\\0” 建议一个文件中的程序总行不超过200行 建议一个过程或函数中的程序总行不超过200行 禁止条件判别成立时相应分支无可执行语句 在if…else if语句中必须使用else分支 禁止条件判别的else分支无可执行语句 在switch语句中必须使用default语句 禁止使用空switch语句 禁止switch语句中只包含defau语句 禁止switch的case语句不是由break终止 禁止switch的case语句中无任何可执行语句 禁止将参数指针赋值给过程指针 禁止将指针的指针超过两级 禁止将过程声明为指针类型 谨慎使用指针的逻辑比较 谨慎对指针进行代数运算 禁止直接从过程中跳出 禁止使用goto语句 避免使用setimp/longimp 禁止在非赋值表达式中出现赋值操作符 禁止对常数值做逻辑非的运算 禁止对有符号类型使用位运算 禁止对枚举类型的越限使用 禁止在逻辑表达式中使用赋值操作福 禁止赋值操作符与“&amp;&amp;”，“||”连用 禁止位操作符带有布尔型的操作数 禁止位操作符作用于布尔值 数组的使用必须保证不会出现越界 禁止对有符号的类型进行位运算 对变量进行位运算必须保证不会产生溢出 禁止给无符号变量赋负值 有符号类型的长度必须大于等于两位 位的定义必须是由符号整数或无符号整数 禁止给变量赋的值与变量的类型不一致 赋值类型必须匹配 避免使用逗号操作符 谨防长度操作符sizeof的副作用 谨慎使用不同类型变量的混合运算 避免由于设计的原因导致某些代码不能执行 主过程所在的文件中禁止有未被该文件中任何过程调用的子过程 static类型的过程在所在的文件中必须被调用 禁止使用被禁用的过程、函数、文件或名称 禁止用一个表达式中调用多个相关函数 禁止void类型的变量作为参数进行传递 禁止实参和形参类型不一致 避免过程参数在过程调用中未被使用 避免以非调用方式使用函数 谨慎使用abort，exit等函数 禁止单独使用小写字母”i”或大写字母”O”作为变量名 禁止三字母词的使用 使用八进制数必须加以注释 避免使用”+=”或”-=”操作符 谨慎使用”++”或”–”操作符 避免使用continue语句 谨慎使用三重表达式 避免使用不起作用的语句 避免使用空语句 谨慎使用寄存器变量 避免使用老的参数表的定义形式 函数必须有返回语句 禁止void类型的过程中的return语句带有返回值 有返回值的函数中，return必须带有返回值 函数返回类型必须一致","categories":[],"tags":[{"name":"GJB5369","slug":"GJB5369","permalink":"http://www.z16388.top/tags/GJB5369/"},{"name":"软件测试","slug":"软件测试","permalink":"http://www.z16388.top/tags/软件测试/"}],"keywords":[]},{"title":"【ACM教程】5.3单源最短路径Dijkstra算法","slug":"【ACM教程】5-3单源最短路径Dijkstra算法","date":"2017-03-15T08:46:18.000Z","updated":"2017-04-13T13:25:15.931Z","comments":true,"path":"2017/03/15/【ACM教程】5-3单源最短路径Dijkstra算法/","link":"","permalink":"http://www.z16388.top/2017/03/15/【ACM教程】5-3单源最短路径Dijkstra算法/","excerpt":"","text":"第三节 单源最短路径Dijkstra算法&emsp;&emsp;最短路径的问题在生活中是十分常见的。不仅仅是表面上的路程计算，网络中的数据传输什么的都能用到最短路径算法。我们在求最短路问题时，常用两种算法。Dijkstra单源最短路径算法和全源最短路径Floyd算法。首先对Dijkstra算法进行学习。 &emsp;&emsp;Dijkstra算法用于计算一个点到其他所有节点的最短路径，是比较有代表性的最短路径算法。数学的很多学科中，都会接触到。它的思路是：把所有的顶点分为两组，一组是已经知道最短路径的，然后从未知最短路径并与之相邻的顶点中选出一个最短的放进已知组里，直到将所有的点放入已知组，找到最短路。 &emsp;&emsp;举个例子，以下图为例，求A到F的最短路。 &emsp;&emsp;首先，已知点是A，然后我们去找和他相邻的，距离最短的点。这时我们看到C点距离A点是3，比B的6要短，所以我们将C点放入已知集合；然后看A、C相邻的点，最短的路径是C到B，所以把B点放入已知集合。就这样一直做下去，直到将所有点放入已知点集合为止。我们将上面的过程，记录在表格里。 步骤 已知点集 B C D E F 1 A 6 3 00 00 00 2 A、C 5 6 7 00 3 A、C、B 6 7 00 4 A、C、B、D 7 9 5 A、C、B、D、E 9 &emsp;&emsp;通过上面的步骤，我们将A到F的最短路找到了：A-C-D-F。除此之外，A到所有点的最短路我们都能够找到。那么，下面我们考虑用程序来实现这个过程。 1234567891011121314151617181920212223242526272829#define INF 0x0f0f0f0f //用INF来代替正无穷（+OO）#define N 1100int low[N]; //low[i]数组存放A号节点到已知集合中i号节点的最短距离int vis[N]; //vis[i] = 1表示i号节点已经在已知集合中，否则反之int cost[N][N],n;//cost[i][j]表示i节点到j节点的直接距离void Dijkstra(int start)&#123; int edge,k; for(int i = 1;i&lt;=n;i++)&#123;//这里是要初始化low[]数组和vis[]数组 low[i] = cost[start][i]; vis[i] = 0; &#125; vis[start] = 1; low[start] = 0; for(int i = 1;i&lt;=n-1;i++)&#123; edge = INF;//edge是已知集合到未知集合的最短边 for(int j = 1;j&lt;=n;j++)&#123;//这里是要找到一条最短边:编号k,边长edge if(vis[j]==0&amp;&amp;edge&gt;low[j])&#123; edge = low[j]; k = j; &#125; &#125; vis[k] = 1; for(int j = 1;j&lt;=n;j++)&#123;//更新得到的新节点k号节点发出去的边 if(vis[j]==0&amp;&amp;low[j] &gt; low[k] + cost[k][j])&#123; low[j] = low[k] + cost[k][j]; &#125; &#125; &#125;&#125; &emsp;&emsp;上面是Dijkstra算法的C语言实现，大家可以将其作为模板记录下来，以后可以直接使用。我们就以上图为例，练习一下Dijkstra算法的使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define INF 0x0f0f0f0f#define N 1100int low[N];int vis[N];int cost[N][N],n;void Dijkstra(int start)&#123; int edge,k; for(int i = 1;i&lt;=n;i++)&#123; low[i] = cost[start][i]; vis[i] = 0; &#125; vis[start] = 1; low[start] = 0; for(int i = 1;i&lt;=n-1;i++)&#123; edge = INF; for(int j = 1;j&lt;=n;j++)&#123; if(vis[j]==0&amp;&amp;edge&gt;low[j])&#123; edge = low[j]; k = j; &#125; &#125; vis[k] = 1; for(int j = 1;j&lt;=n;j++)&#123; if(vis[j]==0&amp;&amp;low[j] &gt; low[k] + cost[k][j])&#123; low[j] = low[k] + cost[k][j]; &#125; &#125; &#125;&#125;int main() &#123; memset(cost,INF,sizeof(cost)); n=6; cost[1][2]=6,cost[1][3]=3; cost[2][3]=2,cost[2][4]=5; cost[3][4]=3,cost[3][5]=4; cost[4][5]=2,cost[4][6]=3; cost[5][6]=5; Dijkstra(1); printf(\"%d\\n\",low[n]); return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】4.2动态规划初体验","slug":"【ACM教程】4-2动态规划初体验","date":"2017-03-14T12:42:34.000Z","updated":"2017-04-13T13:25:15.916Z","comments":true,"path":"2017/03/14/【ACM教程】4-2动态规划初体验/","link":"","permalink":"http://www.z16388.top/2017/03/14/【ACM教程】4-2动态规划初体验/","excerpt":"","text":"第二节 动态规划初体验&emsp;&emsp;在完成了动态规划概念的理解之后，我们来拿一道简单的题目理解一下问题的解决过程。 &emsp;&emsp;斐波那契数列F(n)。当n=1、2时，F(2)=F(1)=1;其他情况F(n)=F(n-1)+F(n-2)。我们发现，这是一个递归的过程，根据前面所学知识，不难写程序： 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int F(int n)&#123; if(n&lt;3) return 1; else return F(n-2)+F(n-1);&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); printf(\"%d\",F(1)); for(int i=2;i&lt;=n;i++) &#123; printf(\" %d\",F(i)); &#125; printf(\"\\n\"); return 0;&#125; &emsp;&emsp;但是，如果把这道题用在一道题目里，可能会造成超时。因为我们在每次运算中，都要把之前的所有情况都要再计算一遍，这会造成很多浪费。如果我们把每次运算的结果存放在数组里，那么在计算F(n)时，我们只需要在存放的结果中把需要的找出来，进行计算，在存进去。下面是改进的函数F：(假设n&lt;=1000) 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define N 1010using namespace std;int A[N];int F(int n)&#123; if(n&lt;3) return 1; if(A[n]) return A[n]; else return A[n]=F(n-1)+F(n-2);&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); memset(A,0,sizeof(A)); printf(\"%d\",F(1)); for(int i=2;i&lt;=n;i++) &#123; printf(\" %d\",F(i)); &#125; printf(\"\\n\"); return 0;&#125; &emsp;&emsp;当状态转移方程太过于复杂的时候，我们可以使用打表的方法——把所有的可能计算一遍，存在数组里。根据输入直接给出结果，实现方法如下： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;iostream&gt;#define N 1010using namespace std;long long A[N];void F()&#123; A[1]=1; A[2]=1; for(int i=3;i&lt;=1000;i++) &#123; A[i]=A[i-2]+A[i-1]; &#125;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); F(); printf(\"%d\",A[1]); for(int i=2;i&lt;=n;i++) printf(\" %d\",A[i]); printf(\"\\n\"); return 0;&#125; &emsp;&emsp;这是动态规划中的枚举法，比较暴力。水题可以尝试使用这种方法去做，但是比赛的时候，oj系统会有防止打表的机制。因此，这种方法最好不要去使用。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.z16388.top/tags/动态规划/"}],"keywords":[]},{"title":"【ACM教程】4.3下降非降子序列问题","slug":"【ACM教程】4-3下降非降子序列问题","date":"2017-03-07T12:04:26.000Z","updated":"2018-01-10T12:41:32.669Z","comments":true,"path":"2017/03/07/【ACM教程】4-3下降非降子序列问题/","link":"","permalink":"http://www.z16388.top/2017/03/07/【ACM教程】4-3下降非降子序列问题/","excerpt":"","text":"第三节 下降/非降子序列问题&emsp;&emsp;这种题目在ACM竞赛中，通常作为“水题”出现。但是水题不水，不了解动态规划的还是AC不了这种类型。我们将会在这一节中，学习解决这种类型题。 模型抽象&emsp;&emsp;子序列问题分为下降子序列问题和非降子序列问题，解决方法类似： 最长非降子序列问题：在一个无序序列a[1],a[2],…,a[n]中，找到一个最长的子序列满足： &emsp;a[i]&lt;=a[j]&lt;=…&lt;=a[m] &emsp;i&lt;j&lt;…&lt;m 最长下降子序列问题：在一个无序序列a[1],a[2],…,a[n]中，找到一个最长的子序列满足： a[i]&gt;a[j]&gt;…&gt;a[m] i&gt;j&gt;…&gt;m &emsp;&emsp;我们从动态规划的三要素入手，来分析这种问题是否能使用动态规划来解决：如果要找到一个长度为k的子序列，那么我们需要一个长度为k-1的满足条件的的序列，再判断第k个元素是否满足条件，这显然满足最优子结构。在考虑第i个元素时，只需要看前面的i-1个，满足无后效性。因此这类题目可以使用动态规划来解决。 &emsp;&emsp;下面我们来做一道经典的题目：hdu1257：最少拦截系统 &emsp;&emsp; 12","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.z16388.top/tags/动态规划/"}],"keywords":[]},{"title":"【ACM教程】4.1动态规划简介","slug":"【ACM教程】4-1动态规划简介","date":"2017-03-06T12:05:18.000Z","updated":"2017-04-13T13:25:15.909Z","comments":true,"path":"2017/03/06/【ACM教程】4-1动态规划简介/","link":"","permalink":"http://www.z16388.top/2017/03/06/【ACM教程】4-1动态规划简介/","excerpt":"","text":"第一节 动态规划简介基本概念&emsp;&emsp;动态规划（DP）是运筹学的一个分支，是求解决策过程最优化的数学方法。它将多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。在现实生活中，我们经常会使用到动态规划。例如求最短路径、库存管理、排序、装载等问题，用动态规划方法比用其他方法更加简便。 &emsp;&emsp;动态规划主要用于求解以时间划分阶段的动态过程问题。但是在一些与时间无关的问题中，我们可以人为地引入时间因素，把它视为多阶段决策过程，也可以使用动态规划来求解。 基本思想&emsp;&emsp;动态规划算法经常用于求解具有某种最优性的问题中。在这类问题里，可能会有很多的可行解。每个解都对应一个值，我们希望得到具有最优解的值。动态规划算法的思路与分治法类似，其具体的思想也是将问题分割成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 &emsp;&emsp;在使用分治法的过程中，有些子问题可能计算了多次。如果我们能够保存已经解决的子问题的答案，在需要的时候直接拿出来，这样就会节省很多时间。我们可以使用一个表来存放我们计算的子问题的结果，无论这个问题在以后是否会用到，只要它被计算过，我们就将它存入表格中。这就是动态规划的基本思想。 相关术语与性质&emsp;&emsp;首先，我们来介绍动态规划的三要素——阶段、状态和决策。 &emsp;&emsp;阶段：把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。 &emsp;&emsp;状态：状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。过程的状态通常可以用一个或一组数来描述，称为状态变量。一般，状态是离散的，但有时为了方便也将状态取成连续的。 &emsp;&emsp;决策：一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史。 &emsp;&emsp;在介绍决策时，我们提到了一个很重要的性质——无后效性。这是动态规划算法的的基本准则： &emsp;&emsp;我们要求状态具有下面的性质：如果给定某一阶段的状态，则在这一阶段以后过程中的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了；换句话说，过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性。 &emsp;&emsp;状态转移方程：给定k阶段状态变量x(k)的值后，如果这一阶段的决策变量一经确定，第k+1阶段的状态变量x(k+1)也就完全确定，即x(k+1)的值随x(k)和第k阶段的决策u(k)的值变化而变化，那么可以把这一关系看成(x(k)，u(k))与x(k+1)确定的对应关系，我们来用x(k+1)=Tk(x(k),u(k))表示。它展示了从k阶段到k+1阶段的状态转移规律，我们称之为状态转移方程。 &emsp;&emsp;由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合。允许策略集合中达到最优效果的策略称为最优策略。 &emsp;&emsp;最优化原理:作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略”。一个问题满足最优化原理也称其拥有最优子结构性质。最优性原理实际上是要求问题的最优策略的子策略也是最优。 理解&emsp;&emsp;综合前面的概念，如果我们把动态规划求解问题的过程比作工厂的生产线，那么阶段就是生产某个商品的不同环节，状态就是工件当前的状态，决策就是对工件进行的操作。之前对工件进行的操作只是在当时起效，我们可以在后面的过程中对它进行进一步的加工。不同阶段是对前面产品的一个小小的总结，由一个个过程，最终构成了最终的生产线。 &emsp;&emsp;一个状态经过一个决策变成了另外的一个状态，这个过程就是状态转移。而用来描述状态转移的方程就是状态转移方程。 适用范围&emsp;&emsp;虽然动态规划很强大，但是它并不是万能的，只能够解决多阶段决策最优化问题。一般在题目中，出现让你求最优解的就要考虑使用动态规划了。但是需要满足一下两个条件。 最优子结构（最优化原理） 无后效性 &emsp;&emsp;一个最优解，它的子问题的解也是最优解，我们就称这个问题具有最优子结构。那无后效性呢？就是在状态i求解时需要用到状态j，而求解j的时候需要k…当求解状态N的时候，需要用到i。那么这个时候就形成了一个环，无法求解了。 解题方法&emsp;&emsp;在判断题目可以使用动态规划解决之后，我们可以使用以下几种方法进行解题： 模型匹配法我们首先要考虑的就是这个方法了。分析题目，如果这个题目是我们之后讲到的模型，就可以直接套用； 三要素法确定题目中的三要素，从比较明显的入手，尝试解题； 规律法多计算出几组数据，试寻找他们之间的联系，建立方程； 边界条件法找到问题的边界条件，分析边界条件和与之邻接状态之间的联系。 放宽约束和增加约束对问题修改，增加或删除一些条件，以便于解题。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.z16388.top/tags/动态规划/"}],"keywords":[]},{"title":"【ACM教程】5.2图的存储方式","slug":"【ACM教程】5-2图的存储方式","date":"2017-03-06T11:03:14.000Z","updated":"2018-01-10T12:38:55.731Z","comments":true,"path":"2017/03/06/【ACM教程】5-2图的存储方式/","link":"","permalink":"http://www.z16388.top/2017/03/06/【ACM教程】5-2图的存储方式/","excerpt":"","text":"第二节 图的存储方式链表&emsp;&emsp;我们在第三章对数据结构的简单了解中学习了，图和树可以使用链表来进行存储。参考第六节 数据结构基础（2）树、二叉树和图。虽然链表能够很方便地，在逻辑上对图进行定义和运算，但是我们知道，在比赛中我们的时间是有限的。如果花大量的时间去构建一个模型，然后针对这个模型的各种运算进行编写会耗费大量的时间。这个时候，我们就需要一个简单的数学模型，来处理这些数据。 图的矩阵表示&emsp;&emsp;在数学上，我们经常用矩阵来表示一个图。我们知道，图是由它们的顶点和他们之间的邻接关系来唯一确定的。这个时候我们只需要两个矩阵，一个用来存放他们的定点，另一个来存放他们之间的关系。 &emsp;&emsp;举个例子：在上一节中，我们接触到了一个非常经典的七桥问题的图。 &emsp;&emsp;图中的三个点我们分别命名为： AB &emsp;&emsp;&emsp;DC &emsp;&emsp;这时，我们可以用一个矩阵V来表示这个图中的点。V={A,B,C,D}那怎么来表示他们之间的联系呢？我们用另一个矩阵M，如果两个点之间是相连的，我们就让m^ij=m^ji=1。如果它们之间没有联系，则m^ij=m^ji=inf。那么，M= A B C D A 0 1 inf 1 B 1 0 1 1 C inf 1 0 1 D 1 1 1 0 &emsp;&emsp;如果这是个有向图，我们可以根据行和列来确定出发和到达的定点；如果这是个对路径长度有要求的图，就比如在计算最短路径的时候，我们可以将矩阵中的数据改为两个点之间的距离。 &emsp;&emsp;在编程的时候，我们可以使用数组来存放这样的矩阵。既方便计算，也能够精确表示。在今后的学习中，我们大多数时候都会使用这种方法来表示和运算。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】5.1图论的基本概念","slug":"【ACM教程】5-1图论的基本概念","date":"2017-03-06T10:25:05.000Z","updated":"2017-04-13T13:25:15.930Z","comments":true,"path":"2017/03/06/【ACM教程】5-1图论的基本概念/","link":"","permalink":"http://www.z16388.top/2017/03/06/【ACM教程】5-1图论的基本概念/","excerpt":"","text":"第一节 图论的基本概念&emsp;&emsp;在前面的学习中，我们简单地接触到了树、图等图论知识的基础概念，在这一章中，我们将对图论做系统的研究。图论相关的知识是ACM中比较重要的一部分，在日常的软件设计中，也较为常用。 图论的历史&emsp;&emsp;图论是一门应用十分广泛、内容非常丰富的数学学科，也是近几十年来较为活跃的数学分支之一。它的起源很早，瑞士数学家欧拉在1736年解决了当时颇为有名的一个数学问题，即哥尼斯堡七桥问题，从而使他成为了图论的创始人。 &emsp;&emsp;七桥问题呢，就是在一个城市的中间，有一条河，河中有两个小岛。在两岸和小岛之间呢，有七座桥。我们需要找到一个路径，使得我们从这四块陆地的其中一个开始，通过每一座桥，并恰好回到起点。 &emsp;&emsp;欧拉为了解决七桥问题，将这个问题转化为了一个数学问题。他认为这种走法是否存在，与岛的形状、大小、以及桥的长短等因素都没有关系，重要的是陆地之间是否有桥联通。因此他用点表示陆地，线表示陆地间的桥梁，就得出了七桥问题的示意图。欧拉在1736年证明了这个路径是不存在的，并进行了进一步的推广得出了一个判别法则—，用于判别给定一个图是否可以走遍。 &emsp;&emsp;除此之外，我们在高中曾经学习过基尔霍夫电压定律。基尔霍夫在1847年运用图论解决了电路理论中求解联立方程组问题，并引入了“树”的概念，可惜在当时并没有受到重视。1857年，凯莱在研究饱和碳氢化合物时，发现了一族重要的图，称其为树，并利用树来计算其同分异构体的数目。 &emsp;&emsp;20世纪后，图论的应用渗透到了其他的很多领域，在计算机网络、博弈论等方面起到了重要的作用。它是组合数学的一个分支，和数值分析、拓扑学等有着密切的联系。比如对于基础的图论来说，它不需要有高深复杂的数学工具，只需要一些集合、二元关系与线性代数知识，结合一般的逻辑推理来解决问题。 图论简介&emsp;&emsp;这里我们讨论的图论并不是几何学上的图形，而是客观世界中，某些具体事物间相互联系的一个数学抽象。用点来表示事物，用边来表示关系。这种由定点及连接这些点的所有边组成的就是我们图论中的图。其中的点我们称为顶点，线称之为边。当边具有方向性时，图是有向图。（否则为无向图） &emsp;&emsp;图在研究现实问题时会经常使用到，比如在地图上找到一条能够最快到达目的地的线路。这都是我们今后将要学习的内容。 &emsp;&emsp;从一个顶点出发，如果存在一个路径，能够回到该顶点，我们称之为圈。没有圈的连通图称为树，树是特殊的图。在解决问题时，我们有时候需要将图转化为它的“生成树”再对问题进行处理。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"第七届蓝桥杯C/C++省赛B组题目详解","slug":"lanqiao7","date":"2017-02-21T11:36:29.000Z","updated":"2017-04-13T13:25:15.870Z","comments":true,"path":"2017/02/21/lanqiao7/","link":"","permalink":"http://www.z16388.top/2017/02/21/lanqiao7/","excerpt":"","text":"第一题 煤球数目 有一堆煤球，堆成三角棱锥形。具体：第一层放1个，第二层3个（排列成三角形），第三层6个（排列成三角形），第四层10个（排列成三角形），….如果一共有100层，共有多少个煤球？请填表示煤球总数目的数字。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 &emsp;&emsp;经过简单的分析，我们可以发现：第n层(n&gt;=2)的煤球个数为该层层数与上一层煤球数之和。所以易写出程序：1234567891011121314#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int c,last=0,res=0; for(c=1;c&lt;=100;c++) &#123; last=c+last; res+=last; &#125; printf(\"%d\\n\",res); return 0;&#125; &emsp;&emsp;最终结果为：171700. 第二题 生日蜡烛 某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。现在算起来，他一共吹熄了236根蜡烛。请问，他从多少岁开始过生日party的？请填写他开始过生日party的年龄数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 &emsp;&emsp;对于这样的填空题目，不需要考虑代码的时间复杂度，直接暴力求解即可（就算在草稿纸上计算也很容易算出来），类似于之前讲过的百钱百鸡问题。这道题目的解决代码如下：12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int start,year,l; for(start=1;start&lt;=236;start++) for(year=start;year&lt;=236;year++) &#123; int sum=0; for(l=start;l&lt;=year;l++)&#123; sum+=l; if(sum==236) &#123; printf(\"%d\\n\",start); return 0; &#125; &#125; &#125; return 0;&#125; &emsp;&emsp;最终结果为26. 第三题 凑算式 B DEFA + —— + ——— = 10 C GHI这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。比如：6+8/3+952/714 就是一种解法，5+3/1+972/486 是另一种解法。这个算式一共有多少种解法？注意：你提交应该是个整数，不要填写任何多余的内容或说明性文字。 &emsp;&emsp;这道题也可以使用暴力枚举的方法：12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c,d,e,f,g,h,i,res=0; double sum; for(a=1;a&lt;=9;a++) for(b=1;b&lt;=9;b++) &#123; if(a==b) continue; for(c=1;c&lt;=9;c++) &#123; if(c==a||c==b) continue; for(d=1;d&lt;=9;d++) &#123; if(d==a||d==b||d==c) continue; for(e=1;e&lt;=9;e++) &#123; if(e==a||e==b||e==c||e==d) continue; for(f=1;f&lt;=9;f++) &#123; if(f==a||f==b||f==c||f==d||f==e) continue; for(g=1;g&lt;=9;g++) &#123; if(g==a||g==b||g==c||g==d||g==e||g==f) continue; for(h=1;h&lt;=9;h++) &#123; if(h==a||h==b||h==c||h==d||h==e||h==f||h==g) continue; for(i=1;i&lt;=9;i++) &#123; if(i==a||i==b||i==c||i==d||i==e||i==f||i==g||i==h) continue; sum=a+(b*1.0)/c+(d*100.0+e*10.0+f)/(g*100.0+h*10.0+i); if(sum==10.0) res++; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\",res); return 0;&#125; &emsp;&emsp;最终结果为29。 &emsp;&emsp;在做这种需要对大规模变量进行枚举的题目时（每年蓝桥杯都会出现几道类似的题目），大家应当注意尽量减少循环次数。就像上面的代码，有很多跳出循环的操作。这样会很快得出结果，否则的话可能会花费很多的宝贵时间。 &emsp;&emsp;后来呢，我在网上看到了一种更加好的解法，学习了之后和大家分享一下。首先，原作者对这道题目的算式进行了通分，这样做的好处就是避免了数据类型的不同，使题目中只出现了int型一种。做法是在等式两边都乘以C*GHI这样每一项就都是整数了。 &emsp;&emsp;第二步，使用全排列函数。下面是这道题的简便算法的代码：1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]; int i; int sum[4]; int ans; for(i=1;i&lt;=9;++i)&#123; a[i]=i; &#125; ans=0; do&#123; sum[0]=a[1]*a[3]*(a[7]*100+a[8]*10+a[9]); sum[1]=a[2]*(a[7]*100+a[8]*10+a[9]); sum[2]=(a[4]*100+a[5]*10+a[6])*a[3]; sum[3]=10*a[3]*(a[7]*100+a[8]*10+a[9]); if(sum[0]+sum[1]+sum[2]==sum[3])&#123; ++ans; &#125; &#125;while(next_permutation(a+1,a+1+9)); printf(\"%d\\n\",ans); return 0;&#125; 第四题 快速排序 排序在各种场合经常被用到。快速排序是十分常用的高效率的算法。其思想是：先选一个“标尺”，用它把整个队列过一遍筛子，以保证：其左边的元素都不大于它，其右边的元素都不小于它。这样，排序问题就被分割为两个子区间。再分别对子区间排序就可以了。下面的代码是一种实现，请分析并填写划线部分缺少的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;void swap(int a[], int i, int j)&#123;int t = a[i];a[i] = a[j];a[j] = t;&#125;int partition(int a[], int p, int r)&#123;int i = p;int j = r + 1;int x = a[p];while(1)&#123;while(i&lt;r &amp;&amp; a[++i]&lt;x);while(a[--j]&gt;x);if(i&gt;=j) break;swap(a,i,j);&#125;______________________;return j;&#125;void quicksort(int a[], int p, int r)&#123;if(p&lt;r)&#123;int q = partition(a,p,r);quicksort(a,p,q-1);quicksort(a,q+1,r);&#125;&#125;int main()&#123;int i;int a[] = &#123;5,13,6,24,2,8,19,27,6,12,1,17&#125;;int N = 12;quicksort(a, 0, N-1);for(i=0; i&lt;N; i++) printf(\"%d \", a[i]);printf(\"/n\");return 0;&#125; 注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。 &emsp;&emsp;这道题目我在【ACM教程】3.7排序（一）中有过介绍，需要对快速排序有一定程度的理解不难得出需要填的内容为swap(a,p,j)。 第五题 抽签 X星球要派出一个5人组成的观察团前往W星。其中：A国最多可以派出4人。B国最多可以派出2人。C国最多可以派出2人。….那么最终派往W星的观察团会有多少种国别的不同组合呢？下面的程序解决了这个问题。数组a[] 中既是每个国家可以派出的最多的名额。程序执行结果为：DEFFFCEFFFCDFFFCDEFFCCFFFCCEFFCCDFFCCDEFBEFFFBDFFFBDEFFBCFFFBCEFFBCDFFBCDEF….(以下省略，总共101行) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#define N 6#define M 5#define BUF 1024void f(int a[], int k, int m, char b[])&#123;int i,j;if(k==N)&#123; b[M] = 0;if(m==0) printf(\"%s/n\",b);return;&#125;for(i=0; i&lt;=a[k]; i++)&#123;for(j=0; j&lt;i; j++) b[M-m+j] = k+'A';______________________; //填空位置&#125;&#125;int main()&#123;int a= &#123;4,2,2,1,1,3&#125;;char b[BUF];f(a,0,M,b);return 0;&#125; 仔细阅读代码，填写划线部分缺少的内容。注意：不要填写任何已有内容或说明性文字。 &emsp;&emsp;这道题目最容易出问题的地方在于对函数参数的把握，在循环次数控制等。我们可以很容易看出来，函数f()是一个递归的过程。其中，在已经给出的代码中已经有了跳出递归的条件，也就是说，需要我们补全的是递归的过程方程。 &emsp;&emsp;我们看，函数f共有4个参数。第一个参数是数组a[]，表示的是每个国家最多派的人数。而且在函数的内部没有对数组的操作，因此第一个参数不变；第二个参数是一个整型变量k，观察函数的内部，k为数组a[]的下标变量。因此k为当前操作的国家编号；第三个参数是整形变量m，观察到在主函数中传入的是派遣人数M。那么每派出几个人，下次传进去的参数都要减去相应的人数；第四个参数是一个字符数组b[]，用来存放每一次的结果。经过上面的分析，可以确定需要补填的内容为： 1f(a,k+1,m-j,b) 第六题 方格填数 如下的10个格子&emsp;+–+–+–+ | | | |+–+–+–+–+| | | | |+–+–+–+–+| | | |+–+–+–+（4*3的长方形，左上角和右下角分别缺少一个方格）填入0~9的数字。要求：连续的两个数字不能相邻。（左右、上下、对角都算相邻）一共有多少种可能的填数方案？请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 &emsp;&emsp;这道题目又是可以使用暴力枚举做出来的，去年比赛的时候想的太复杂了，没做出来，也是非常后悔。但是最好还是使用dfs，深度优先搜索算法去做。在这里，像前面那道题那样，利用全排列函数，再写一个判断用的函数判断数字是否连续就行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int a[10];/* 0 1 23 4 5 67 8 9*/bool judge()&#123; if(abs(a[0]-a[1])==1||abs(a[0]-a[5])==1||abs(a[0]-a[4])==1||abs(a[0]-a[3])==1)&#123; return false; &#125; if(abs(a[1]-a[2])==1||abs(a[1]-a[6])==1||abs(a[1]-a[5])==1||abs(a[1]-a[4])==1)&#123; return false; &#125; if(abs(a[2]-a[6])==1||abs(a[2]-a[5])==1)&#123; return false; &#125; if(abs(a[3]-a[4])==1||abs(a[3]-a[8])==1||abs(a[3]-a[7])==1)&#123; return false; &#125; if(abs(a[4]-a[5])==1||abs(a[4]-a[9])==1||abs(a[4]-a[8])==1||abs(a[4]-a[7])==1)&#123; return false; &#125; if(abs(a[5]-a[6])==1||abs(a[5]-a[9])==1||abs(a[5]-a[8])==1)&#123; return false; &#125; if(abs(a[6]-a[9])==1)&#123; return false; &#125; if(abs(a[7]-a[8])==1)&#123; return false; &#125; if(abs(a[8]-a[9])==1)&#123; return false; &#125; return true;&#125;int main()&#123; int i; int sum; for(i=0;i&lt;10;++i)&#123; a[i]=i; &#125; sum=0; do&#123; if(judge())&#123; ++sum; &#125; &#125;while(next_permutation(a,a+10)); printf(\"%d\\n\",sum); return 0;&#125; 第七题 剪邮票 如【图1.jpg】, 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连）比如，【图2.jpg】，【图3.jpg】中，粉红色所示部分就是合格的剪取。请你计算，一共有多少种不同的剪取方法。请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 图1 图2 图3 &emsp;&emsp;这道题需要使用dfs去做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int dir[4] = &#123;1,-1,5,-5&#125;;int temp1[12] = &#123;1,2,3,4,6,7,8,9,11,12,13,14&#125;;int temp2[5];int vis[5];int ans = 0;void dfs(int u)&#123; for(int i=0 ;i&lt;4 ;i++)&#123; int t = temp2[u]+dir[i]; if(t&gt;=1&amp;&amp;t&lt;=14)&#123; for(int j=0 ;j&lt;5 ;j++) if(t==temp2[j]&amp;&amp;!vis[j])&#123; vis[j]=1; dfs(j); &#125; &#125; &#125;&#125;int main()&#123; for(int a=0 ;a&lt;12 ;a++)&#123; for(int b=a+1 ;b&lt;12 ;b++)&#123; for(int c=b+1 ;c&lt;12 ;c++)&#123; for(int d=c+1 ;d&lt;12 ;d++)&#123; for(int e=d+1 ;e&lt;12 ;e++)&#123; temp2[0]=temp1[a]; temp2[1]=temp1[b]; temp2[2]=temp1[c]; temp2[3]=temp1[d]; temp2[4]=temp1[e]; //初始化访问标记数组 memset(vis,0,sizeof(vis)); vis[0]=1; dfs(0); //连通性判断 int flag = 1; for(int i=0 ;i&lt;5 ;i++)&#123; if(vis[i]==0)&#123; flag = 0; &#125; &#125; if(flag)ans++; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125; 第八题 四平方和&emsp;&emsp;每年的最后三道题都是大题。大题是得省一的关键。能够保证前面的正确率的同时，如果能够A一道大题省一就基本没有问题了。 四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多4个正整数的平方和。如果把0包括进去，就正好可以表示为4个数的平方和。比如：5 = 0^2 + 0^2 + 1^2 + 2^27 = 1^2 + 1^2 + 1^2 + 2^2（^符号表示乘方的意思）对于一个给定的正整数，可能存在多种平方和的表示法。要求你对4个数排序：0 &lt;= a &lt;= b &lt;= c &lt;= d并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法程序输入为一个正整数N (N&lt;5000000)要求输出4个非负整数，按从小到大排序，中间用空格分开例如，输入：5则程序应该输出：0 0 1 2再例如，输入：12则程序应该输出：0 2 2 2再例如，输入：773535则程序应该输出：1 1 267 838资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 3000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。 &emsp;&emsp;这道题可以通过枚举法暴力求解： 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAXN 2300int flag=0;int main()&#123; int n; scanf(\"%d\",&amp;n); for(int i=0;i&lt;MAXN;i++)&#123; if(i*i&lt;=n) for(int j=i;j&lt;MAXN;j++)&#123; if(i*i+j*j&lt;=n) for(int k=j;k&lt;MAXN;k++)&#123; int l=(int)sqrt(n-i*i-j*j-k*k); if(i*i+j*j+k*k+l*l==n)&#123; printf(\"%d %d %d %d\",i,j,k,l); return 0; &#125; &#125; &#125; &#125; return 0;&#125; 第九题 交换瓶子 有N个瓶子，编号 1 ~ N，放在架子上。比如有5个瓶子：2 1 3 5 4要求每次拿起2个瓶子，交换它们的位置。经过若干次后，使得瓶子的序号为：1 2 3 4 5对于这么简单的情况，显然，至少需要交换2次就可以复位。如果瓶子更多呢？你可以通过编程来解决。输入格式为两行：第一行: 一个正整数N（N&lt;10000）, 表示瓶子的数目第二行：N个正整数，用空格分开，表示瓶子目前的排列情况。输出数据为一行一个正整数，表示至少交换多少次，才能完成排序。例如，输入：53 1 2 5 4程序应该输出：3再例如，输入：55 4 3 2 1程序应该输出：2资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。 第十题 最大比例 最大比例X星球的某个大奖赛设了M级奖励。每个级别的奖金是一个正整数。并且，相邻的两个级别间的比例是个固定值。也就是说：所有级别的奖金数构成了一个等比数列。比如：16,24,36,54其等比值为：3/2现在，我们随机调查了一些获奖者的奖金数。请你据此推算可能的最大的等比值。输入格式：第一行为数字N，表示接下的一行包含N个正整数第二行N个正整数Xi(Xi","categories":[],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://www.z16388.top/tags/蓝桥杯/"}],"keywords":[]},{"title":"VPS笔记","slug":"VPS笔记","date":"2017-01-22T13:28:47.000Z","updated":"2017-04-13T13:25:15.881Z","comments":true,"path":"2017/01/22/VPS笔记/","link":"","permalink":"http://www.z16388.top/2017/01/22/VPS笔记/","excerpt":"","text":"&emsp;&emsp;登录： 1ssh root@ip &emsp;&emsp;安装可视化管理面板AMH 登录 运行脚本 1wget http://amysql.com/file/AMH/4.2/amh.sh; chmod 775 amh.sh; ./amh.sh 2&gt;&amp;1 | tee amh.log; 根据安装步骤提醒键入相应内容，完成安装 使用ip和配置的端口进行访问，例如http://ip:8888 &emsp;&emsp;ShadowsocksR一键安装脚本安装123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 卸载1./shadowsocksR.sh uninstall 其他操作12345678启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status配置文件路径：/etc/shadowsocks.json日志文件路径：/var/log/shadowsocks.log代码安装目录：/usr/local/shadowsocks","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://www.z16388.top/tags/VPS/"}],"keywords":[]},{"title":"【ACM教程】3.7排序（一）","slug":"【ACM教程】3-7排序（一）","date":"2017-01-18T03:25:23.000Z","updated":"2017-04-13T13:25:15.901Z","comments":true,"path":"2017/01/18/【ACM教程】3-7排序（一）/","link":"","permalink":"http://www.z16388.top/2017/01/18/【ACM教程】3-7排序（一）/","excerpt":"","text":"第七节 排序（一）&emsp;&emsp;我们在写程序的时候，经常需要去进行排序这种操作。在面对大量数据进行排序的时候，我们可能需要花费很多的时间和资源。因此，优化排序算法是我们在优化程序中的一个重要步骤。在我们前面的学习中，我们已经接触到了C++的STL中sort()函数。那么，在无法使用STL的情况或者是需要一些特殊的要求的排序，我们就需要对排序算法进行手撸。因此，掌握各种常见的排序方法极为重要。接下来，我们将会从冒泡排序开始，系统地对常见的排序算法进行练习。 冒泡排序（Bubble Sort）&emsp;&emsp;我们早在学习C语言的时候，就已经接触到这种排序方法了，是一种非常简便的排序方法。我们依次比较相邻的两个元素，以达到排序的目的。冒泡排序的运作方式如下： 重复走访所要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们相互交换如果这个数列一共有n个元素，我们需要进行n-1组比较，每一组需要进行n-i次比较 &emsp;&emsp;下面是冒泡排序的C语言代码： 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int a[15]; int n=10,i,j,t; for(i=0;i&lt;n;i++) a[i]=10-i; for(i=1;i&lt;n;i++) for(j=0;j&lt;n-i;j++) //这里可以记作i+j=n; sif(a[j]&gt;a[j+1]) &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; for(i=0;i&lt;n;i++) printf(\"%d \",a[i]); printf(\"\\n\"); return 0;&#125; &emsp;&emsp;冒泡排序是一种常用的排序方法，但是它的时间复杂度为O(n^2)，在做题时不推荐使用。 快速排序（Quick Sort）&emsp;&emsp;快速排序是对冒泡排序的一种改进，它的基本思想和冒泡排序类似： 通过一趟排序将序列分成两部分保证左侧部分的数据都比右侧的小再分别对两侧进行排序 &emsp;&emsp;快速排序是排序算法中的优等生，它的时间复杂度为O(logn)，但是要到达了最不理想的状态，也就是针对一个完全反序的数列进行排序。这个时候，它就变成了冒泡排序，时间复杂度为O(n^2)。在去年的蓝桥杯比赛中，就成为了一道代码填空题，题目是这样的： 排序在各种场合经常被用到。 快速排序是十分常用的高效率的算法。 其思想是：先选一个“标尺”， 用它把整个队列过一遍筛子， 以保证：其左边的元素都不大于它，其右边的元素都不小于它。 这样，排序问题就被分割为两个子区间。 再分别对子区间排序就可以了。 下面的代码是一种实现，请分析并填写划线部分缺少的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;void swap(int a[], int i, int j)&#123; int t = a[i]; a[i] = a[j]; a[j] = t;&#125;int partition(int a[], int p, int r)&#123; int i = p; int j = r + 1; int x = a[p]; while(1)&#123; while(i&lt;r &amp;&amp; a[++i]&lt;x); while(a[--j]&gt;x); if(i&gt;=j) break; swap(a,i,j); &#125;______________________;return j;&#125;void quicksort(int a[], int p, int r)&#123; if(p&lt;r)&#123; int q = partition(a,p,r); quicksort(a,p,q-1); quicksort(a,q+1,r); &#125;&#125;int main()&#123; int i; int a[] = &#123;5,13,6,24,2,8,19,27,6,12,1,17&#125;; int N = 12; quicksort(a, 0, N-1); for(i=0; i&lt;N; i++) printf(\"%d \", a[i]); printf(\"/n\"); return 0;&#125; 注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。 &emsp;&emsp;这里的答案是swap(a,p,j)，我们就以上面的例子来简单地描述一下快速排序。首先我们看，这个程序中有四个函数，swap()函数实现的是值交换，main()是声明了一个数组，然后对他进行快速排序然后打印出来，我们就不多说了。现在我们来看一下quicksort这个函数。这个函数就是用来实现我们在前面描述过的“分别对两个子区间进行快速排序”这个过程，也比较简单。比较让人头疼就是要我们填空的这个partition()函数。 &emsp;&emsp;下面就让我们来回忆一下快速排序的方法。快速排序就是找一个标尺（一般是一段序列的第一个），比他大的放在他左边，比他小的放在他右边。那么程序上是怎么实现的呢？ &emsp;&emsp;我们需要在程序中定义两个指针，分别从序列的两端出发，左侧的指针向右寻找比标尺大的数据，右侧的指针向左寻找比标尺小的数据，但是在实现上，有两种方法。第一种：先从右侧出发，找到第一个比标尺小的数据，将其和标尺交换位置。然后从左侧出发，找到第一个比标尺大的数据，交换位置，直到两标尺相遇。但是这种方法会频繁地使用赋值操作，那么还有一种改进思路：我们让标尺在a[0]的位置不动，将a[1]作为左侧指针的出发点。两指针分别从左右出发，找到相应的数据之后对两个数据交换位置，直到两个指针相遇。之后再把标尺放在正确的位置上，完成排序。而这个正确的位置呢，就是两指针相遇的位置。 &emsp;&emsp;在partition()函数中，有三个参数，第一个参数i,j,x。i作为low指针，j作为high指针，而x即是标尺。我们看在函数中，i初始化为标尺的位置后，在下面的while循环里，使用的是++i。这就保证了标尺是不移动的，也就是说这个程序使用的是第二种思路。仔细阅读代码，我们可以发现，函数中缺少的正是最后一步——将标尺移动到正确的位置。所以需要补填的代码是swap(a,p,j)。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"hdu1326,hdu2088","slug":"hdu1326-hdu2088","date":"2016-11-16T12:06:16.000Z","updated":"2017-04-13T13:25:20.911Z","comments":true,"path":"2016/11/16/hdu1326-hdu2088/","link":"","permalink":"http://www.z16388.top/2016/11/16/hdu1326-hdu2088/","excerpt":"","text":"&emsp;&emsp;这两道是同一道题，只是区别在输出格式。 &emsp;&emsp;算出需要移动的方块个数（相差平均数的总个数）即可，需要注意的是每两个输出之间有一个空行。 &emsp;&emsp;2088就比较套路，最后一组输出没有空行。 hdu1326 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 55int a[N];using namespace std;int main()&#123; int n,flag=0,ave,sum; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; ave=0,sum=0; memset(a,0,sizeof(a)); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); ave+=a[i]; &#125; ave/=n; for(int i=1;i&lt;=n;i++) &#123; if(a[i]&lt;ave) &#123; sum+=ave-a[i]; &#125; &#125; printf(\"Set #%d\\n\",++flag); printf(\"The minimum number of moves is %d.\\n\\n\",sum); &#125; return 0;&#125; hdu 2088 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 55int a[N];using namespace std;int main()&#123; int n,ave,sum,flag=0; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; ave=0,sum=0; if(flag++) printf(\"\\n\"); memset(a,0,sizeof(a)); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); ave+=a[i]; &#125; ave/=n; for(int i=1;i&lt;=n;i++) &#123; if(a[i]&lt;ave) &#123; sum+=ave-a[i]; &#125; &#125; printf(\"%d\\n\",sum); &#125; return 0;&#125;","categories":[],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://www.z16388.top/tags/hdu/"},{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"}],"keywords":[]},{"title":"hdu1720 A+B Coming","slug":"hdu1720","date":"2016-11-16T11:32:29.000Z","updated":"2017-04-13T13:25:20.904Z","comments":true,"path":"2016/11/16/hdu1720/","link":"","permalink":"http://www.z16388.top/2016/11/16/hdu1720/","excerpt":"","text":"&emsp;&emsp;这是一道简单的输入输出问题，把输入当做十六进制，计算和并按照十进制输出即可。 &emsp;&emsp;以下是C和C++两种做法： 1234567891011#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; while(scanf(\"%x%x\",&amp;a,&amp;b)!=EOF) &#123; printf(\"%d\\n\",a+b); &#125; return 0;&#125; 123456789101112#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() &#123; int a,b; while(cin&gt;&gt;hex&gt;&gt;a&gt;&gt;b) &#123; cout&lt;&lt;a+b&lt;&lt;endl; &#125; return 0; &#125;","categories":[],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://www.z16388.top/tags/hdu/"},{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"}],"keywords":[]},{"title":"【ACM教程】3.6数据结构基础（2）树、二叉树和图","slug":"【ACM教程】3-6数据结构基础（2）树、二叉树和图","date":"2016-11-16T06:49:28.000Z","updated":"2017-04-13T13:25:15.900Z","comments":true,"path":"2016/11/16/【ACM教程】3-6数据结构基础（2）树、二叉树和图/","link":"","permalink":"http://www.z16388.top/2016/11/16/【ACM教程】3-6数据结构基础（2）树、二叉树和图/","excerpt":"","text":"第六节 数据结构基础（2）树、二叉树和图&emsp;&emsp;我们之前讲了数据结构中的几个线性结构，链表、栈还有队列。那么如果想要一个能表示多个元素之间关系的数据结构，就要使用我们的树形结构和图了。在ACM和蓝桥杯的比赛中，有关树和图的题目是百分百出现的。 树&emsp;&emsp;树形结构是一类非常重要的非线性数据结构，其中以树和二叉树最为常用。树结构在客观世界中广泛存在，比如我们日常生活中常见的组织结构图： &emsp;&emsp;树是n个结点的有限集合，在任意一棵非空的树中： 有且仅有一个特定的，称为根（Root）的结点 当n&gt;1时，其余结点可分别为m（m&gt;0）个互不相交的有限集合T1,T2,…,Tm，其中每一个集合本身又是一棵树，并且称为根的子树 &emsp;&emsp;以上就是一棵树的定义。 &emsp;&emsp;结点的子树称为它的“孩子”，相应地，该节点称为“双亲”。同一个双亲的孩子称为“兄弟”。孩子的数量称为“度”。 &emsp;&emsp;规定根为第一层，它的孩子为第二层，以此类推。树中最大的层数称为树的深度或高度。 &emsp;&emsp;森林：m（m&gt;0）课互不相交的树的集合。 二叉树&emsp;&emsp;二叉树的定义和性质&emsp;&emsp;在讨论一般树的存储结构及操作之前，我们首先研究一种名为二叉树的抽象数据结构类型。 &emsp;&emsp;二叉树是另一种树形结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点）。并且，二叉树的子树左右之分，其次序不能任意颠倒。 &emsp;&emsp;下面是二叉树的一些性质： 在二叉树的第i层上至多有2^(i-1)个结点（i&gt;=1）；可以使用数学归纳法来证明 深度为k的二叉树至多有2^k-1个结点（k&gt;=1）；由第一个性质推导 对任何一棵二叉树T，若其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。 … &emsp;&emsp;二叉树的存储结构&emsp;&emsp;二叉树的概念和性质不是我们研究的主要问题，我们来看一下二叉树的存储结构。二叉树可以使用顺序存储结构和链式存储结构，这里我们先讲一下顺序存储结构。 &emsp;&emsp;我们规定，用一组地址连续的存储单元，自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存放在一维数组下表为i（i-1）的分量中。对于一般的二叉树，则应该将其每个节点与完全二叉树相对照，存放在一维数组中。其中0表示不存在此结点。（想想我们之前讲过的memset函数） &emsp;&emsp;链式存储可以使用拥有两个指针域或者三个指针域的链表来表示，这里要看我们对这个二叉树的操作需求。如果需要返回访问根节点，则需要三个指针域。结合下面的内容，理解一下。 &emsp;&emsp;lchild&emsp;&emsp;data&emsp;&emsp;rchild&emsp;&emsp;lchild&emsp;&emsp;data&emsp;&emsp;parent&emsp;&emsp;rchild &emsp;&emsp;二叉树的遍历和线索二叉树&emsp;&emsp;在二叉树的一些应用中，我们常常要求在树种查找具有某种特征的结点，或者对树中全部结点做统一处理，我们就要对二叉树进行遍历。遍历就是按照某条搜索路径巡访树中的每个节点，就比如我们要输出的时候。对于一个线性结构，比如说数组，我们进行遍历就很方便，但是二叉树就比较复杂了。下面我们介绍三种操作方法： 先序遍历： 访问根节点 先序遍历左子树 先序遍历右子树 中序遍历： 中序遍历左子树 访问根节点 中序遍历右子树 后序遍历： 后序遍历左子树 后序遍历右子树 访问根节点 &emsp;&emsp;我们知道，二叉树的遍历是以一定的规则将其排列成一个线性结构，但是当以二叉链表作为存储结构时，我们只能找到结点的左右孩子信息，而不能找到结点在任一序列中的前驱和后继。这种信息只有在动态的过程中才能够得到。那么想要保存的话，我们需要在每个节点上再加两个指针域用来存放结点的前驱和后继的信息。 &emsp;&emsp;lchild&emsp;&emsp;LTag&emsp;&emsp;data&emsp;&emsp;RTag&emsp;&emsp;rchild &emsp;&emsp;以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索二叉链表，对某种次序遍历使其变成线索二叉树的过程叫做线索化。 图&emsp;&emsp;图的定义&emsp;&emsp;图是较线性表和树更为复杂的数据结构。在图结构中，结点之间的关系是任意的——图中任意两个元素都有可能相关。图中的数据元素称为定点（Vertex），VR是表示两个点之间的关系的集合,是VR中的元素，表示的是从v到w的的一条弧（Arc）。v为初始点（弧尾），w为终端点（弧头），此时的图称为有向图。如果对任意的都有，则用无序队（v,w）来代替这个有序对，表示v和w之间的一条边，此时的图为无向图。 &emsp;&emsp;有关图的问题还有很多，在数学上，我们专门有一门研究图的学科，叫做图论，这也将是接下来我们的研究对象。在今后的学习中，我们可能会接触到以下内容： &emsp;&emsp;图的存储方法&emsp;&emsp;图的遍历&emsp;&emsp;&emsp;&emsp;深度优先搜索（dfs）&emsp;&emsp;&emsp;&emsp;广度优先搜索（bfs）&emsp;&emsp;图的连通性&emsp;&emsp;克鲁斯卡尔算法 &emsp;&emsp;最短路径&emsp;&emsp;&emsp;&emsp;单源最短路径&emsp;&emsp;迪杰斯特拉算法 &emsp;&emsp;&emsp;&emsp;多源最短路径&emsp;&emsp;普里姆算法","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】3.5常用C++容器vector,set和map","slug":"【ACM教程】3-5常用C++容器vector,set和map","date":"2016-11-13T11:44:37.000Z","updated":"2017-04-13T13:25:15.899Z","comments":true,"path":"2016/11/13/【ACM教程】3-5常用C++容器vector,set和map/","link":"","permalink":"http://www.z16388.top/2016/11/13/【ACM教程】3-5常用C++容器vector,set和map/","excerpt":"","text":"第五节 常用C++容器vector，set和map&emsp;&emsp;上一节我们介绍了一些简单的数据结构，大家只要理解概念就可以了，为下面的概念和模型打下基础。这一节，我们讲一讲C++中一些常用的容器。就像之前的list，stack一样，能给我们写程序带来很大的帮助。 vector&emsp;&emsp;动态数组（vector）是比较常用的容器之一，它的用法和数组类似，但是大小不确定。在我们对它的值进行更改的时候，它的大小也会变化。它的声明方法和数组类似： 1vector&lt;int&gt; v; &emsp;&emsp;push_back()可以在结尾添加元素： 123v.push_back(1);v.push_back(2);v.push_back(3); &emsp;&emsp;vector可以和数组一样通过下标来访问。下标也是从0开始的： 1print(\"%d %d %d\\n\",v[0],v[1],v[2]); &emsp;&emsp;v.begin()和v.end()返回的是两个指针，分别指向vector的第一个元素和最后一个元素。 &emsp;&emsp;和我们之前讲过的list一样，vector也可以使用迭代器： 1234vector&lt;int&gt; v; vector&lt;int&gt;::iterator it; for(it=v.begin();it!=v.end();it++) printf(\"%d \",*it); &emsp;&emsp;我们来做一道练习题吧，hdu2561，思路很简单，我们用vector来存放数据，sort()排序之后输出。在输出完一组数据之后，我们应该使用clear()来清空容器。AC代码如下： 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int c,n,t; vector&lt;int&gt; v; scanf(\"%d\",&amp;c); while(c--) &#123; scanf(\"%d\",&amp;n); while(n--) &#123; scanf(\"%d\",&amp;t); v.push_back(t); &#125; sort(v.begin(),v.end()); printf(\"%d\\n\",v[1]); v.clear(); &#125; return 0;&#125; &emsp;&emsp;除此之外，还有一些常用的函数： front() back() 返回首尾元素的引用。empty() 是否为空size() 元素的个数pop_back() 删除容器中最后一个元素clear() 删除所有元素erase(iterator it) 删除迭代器指向的的元素 set&emsp;&emsp;set被称为集合类，存放的元素会按照大小自动排序，但是不能有重复的元素。如果想要存放重复的元素，应该使用multiset。 &emsp;&emsp;声明、初始化和迭代器等： 12345678set&lt;int&gt; set01; set&lt;int&gt;::iterator it; set01.insert(3); set01.insert(1); set01.insert(1); for(it01=set.begin();it!=set.end();it++) printf(\"%d \",*it); return 0; &emsp;&emsp;正如它的名字，在处理集合之类的问题的时候我们可以使用。可以看这道题：hdu1412。同一个set存储连个数据，不仅实现了相同元素的排除还排好了序。在输出一组结果之后，应该使用clear()来清空容器。下面是AC代码： 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main()&#123; int i,n,m,t; set&lt;int&gt; st; set&lt;int&gt;::iterator it; while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF) &#123; for(i=0;i&lt;n+m;i++) &#123; scanf(\"%d\",&amp;t); st.insert(t); &#125; for(it=st.begin();it!=st.end();) &#123; printf(\"%d\",*it); printf(\"%c\",(++it)==st.end()?'\\n':' '); &#125; st.clear(); &#125; return 0;&#125; empty() 是否为空size() 元素的个数erase(iterator it) 删除迭代器指向的的元素 map&emsp;&emsp;map称为映射，元素成对出现。，前面的称为关键字，后面是关键字对应的值。映射中的元素会按照key的大小自动排序。map是单映射，key和value是一对一的关系。如果想要实现多映射就要使用multimap。 &emsp;&emsp;声明、初始化 1234567map&lt;int,string&gt; map01; pair&lt;int,string&gt;p1(1,\"这是1\"); pair&lt;int,string&gt;p2(2,\"这是2\"); pair&lt;int,string&gt;p3(3,\"这是3\"); map01.insert(p1); map01.insert(p2); map01.insert(p3); &emsp;&emsp;除此之外，我们还可以使用赋值的方法来进行初始化，但是仅限于单映射。 123map01[5]=25;map01[3]=9;map01[4]=16; &emsp;&emsp;begin()和end()返回的是两个指针，分别指向map的第一个元素和最后一个元素。如果需要访问映射中的元素，需要使用迭代器： 1234567map&lt;int,int&gt; map01; map&lt;int,int&gt;::iterator it01; map01[5]=25; map01[3]=9; map01[3]=10; for(it01=map01.begin();it01!=map01.end();it01++) printf(\"Key:%d Value:%d\\n\",(*it01).first(*it01).second); &emsp;&emsp;下面做一道练习题：(hdu2550)[http://acm.hdu.edu.cn/showproblem.php?pid=2550] 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;int main()&#123; map&lt;int,int&gt; mp; map&lt;int,int&gt;::iterator it; int t,n,key,value,i,j; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d\",&amp;n); while(n--) &#123; scanf(\"%d%d\",&amp;key,&amp;value); mp[key]=value; &#125; for(it=mp.begin();it!=mp.end();it++) &#123; for(i=0;i&lt;(*it).second;i++) &#123; printf(\"&gt;+\"); for(j=0;j&lt;(*it).first-2;j++) printf(\"-\"); printf(\"+&gt;\\n\"); &#125; printf(\"\\n\"); &#125; mp.clear(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】3.4数据结构基础（1）栈、队列和链表","slug":"【ACM教程】3-4数据结构基础（1）栈、队列和链表","date":"2016-11-11T08:43:29.000Z","updated":"2017-04-13T13:25:15.898Z","comments":true,"path":"2016/11/11/【ACM教程】3-4数据结构基础（1）栈、队列和链表/","link":"","permalink":"http://www.z16388.top/2016/11/11/【ACM教程】3-4数据结构基础（1）栈、队列和链表/","excerpt":"","text":"第四节 数据结构基础（1）栈，队列和链表&emsp;&emsp;接下来的章节会介绍简单的数据结构，包括线性表（栈、队列、链表等）、二叉树和图。这些这些内容可能在我们今后要学习的算法中经常出现，都是需要去掌握的概念和内容。如果数据结构的基础没有打好，那么我们就很难设计出准确、高效的算法。 &emsp;&emsp;这一节我们要介绍三个基础的概念，栈、队列和链表。他们是最简单、最基础，同时也是最常用的数据结构。他们同属于线性表：n（n&gt;=0）个具有相同属性（数据类型一致）的数据元素的有限序列。我们之前学习过的数组，就是经常用来记录线性表的一种常用工具。 栈（Stack）&emsp;&emsp;栈是一种运算受到限制的线性表，它的插入和删除操作都只能在同一端进行。如果非要在生活中举个例子的话，那么栈的话，就像是一桶薯片。无论是拿出一片还是放进去一片，都只能从一个口里进行。这个口我们称之为栈顶（Top）。这样的规定会让先进去的元素后出来，我们称之为先进后出。（FILO） &emsp;&emsp;向栈顶插入新元素成为入栈，反之为出栈。栈的存储结构的C语言表述为： 12345typedef struct&#123; int a[N]; int top;&#125;SeqStack; &emsp;&emsp;栈为空时，我们将Top赋值-1；非空时，我们将可以使用下标0以上的元素。类似的表述方式我们在之前讲过的二分法中提到过。当存入一个元素或取出一个元素时，我们对结构体中的top进行相应的自增和自检，记录当前栈顶的位置。 &emsp;&emsp;我们在处理先进后出的问题时，推荐使用栈。比如，我们在进行进制换算时，将十进制转为八进制需要进行多次相除求余数。算出来的数越早，它的位置就越低。比如：十进制数字1835转化为八进制需要除以四次才能将商变为0，得到的余数分别为3 5 4 3，转化为十进制就是3453。所以对于这种问题来说，使用栈来存储计算结果是再好不过的了，我们不需要对存入的数据进行反转再输出。 &emsp;&emsp;令人可喜的是，在C++的STL中给我们提供了栈这种容器，我们在使用的时候不需要再用语言来构造出来这种结构以及对这种结构的操作函数了。以后介绍的数据结构中，我们也会提到相应的STL。 头文件： #include “stack”声明方法：stack&lt;类型&gt; s;成员函数：&emsp;&emsp;&emsp;&emsp;s.push(x)&emsp;&emsp;无返回值，将元素x压栈&emsp;&emsp;&emsp;&emsp;s.pop();&emsp;&emsp;退栈，无返回值&emsp;&emsp;&emsp;&emsp;s.top();&emsp;&emsp;取栈顶元素，返回栈顶元素&emsp;&emsp;&emsp;&emsp;s.empty();&emsp;&emsp;判断栈是否为空，如果是空，返回1，否则返回0&emsp;&emsp;&emsp;&emsp;s.size();&emsp;&emsp;返回栈中元素的个数 &emsp;&emsp;大家可以思考一下怎么把栈里所有的元素打印出来，也可以试着做一下上面的进制转换问题。 队列（Queue）&emsp;&emsp;刚刚我们提到的栈，是一种先进后出的线性表，那么这里的队列也是线性表的一种，不过是先进先出（FIFO）型的。我想这个名字应该比较形象，就像我们在超市排队付款一样，先到的先来。我们把允许插入的一端称为队尾（Rear），允许删除的一端称为队头（Front），没有元素的队列称为空队列。元素的插入和删除分别称为入队和出队。 &emsp;&emsp;为了便于理解，我们来看一下队列的的存储结构吧。 12345typedef struct&#123; int a[N]; int rear,front;&#125;SeQueue; &emsp;&emsp;我们看，它的结构和栈类似，但是在结构中比栈多了一个用来表示不同出口的“指针”。在空队列时，两个“指针”的初值都为-1。当有入队操作时，我们的队尾（rear）就要进行自增；有出队操作时，队头（front）自增。（思考一下为什么会这样） &emsp;&emsp;经过这样的操作，我们的队列可能会浪费很多的存储空间，所以在常用的队列存储方式中，我们经常使用首尾相连的数据结构，这就变成了一个“循环队列”。当然，我们的STL为我们已经做好了一切，我们只要用就好了。 头文件：#include “queue”声明方式：queue Q;常用成员函数：&emsp;&emsp;&emsp;&emsp;Q.push()&emsp;&emsp;入队&emsp;&emsp;&emsp;&emsp;Q.size()&emsp;&emsp;返回队列中元素的个数&emsp;&emsp;&emsp;&emsp;Q.front()&emsp;&emsp;显示队头元素&emsp;&emsp;&emsp;&emsp;Q.back()&emsp;&emsp;显示最后一个元素&emsp;&emsp;&emsp;&emsp;Q.pop()&emsp;&emsp;出队&emsp;&emsp;&emsp;&emsp;Q.empty()&emsp;&emsp;判断队列是否为空，如果是空，返回1，否则返回0 链表（List）&emsp;&emsp;用数组存储的元素具有空间上的连续性。那么如果我们需要一个逻辑上联系很紧密的结构，比如说树或者是图的话，就有可能要使用链表了。这里只是简单介绍一下链表的概念和基本类型，在后面我们会具体研究这种重要的数据结构。 &emsp;&emsp;首先我们来看一个链表节点的存储结构： 12345typedef struct Node //结点类型定义&#123; int data; struct Node *next;&#125;LinkList; &emsp;&emsp;我们看，在定义链表节点的时候，我们使用了一个类似于递归的方法，不过我们发现，它存放的是下一个结点的指针。我们来看一下简单的单链表的结构吧。 结点结构： ┌───┬───┐ │data&emsp;│next&emsp;│ └───┴───┘ 链表结构： &emsp;&emsp;除了单链表，还有我们刚刚提到过的队列要用到的循环链表以及双链表、静态链表等。下一节我们将对链表进行专门的研究。比起线性表，除了链表的结构关系比较强之外，还能提高存储空间的利用率。链表的存储密度小、存储内存随机。但是在查找的时候，链表必须按照顺序。所以我们应该根据需求来选择相应的数据结构。 &emsp;&emsp;理解了链表的结构之后，我们并不需要像在上数据结构课的时候那样搞得那么清楚，同样，会使用STL中的链表就可以了。 头文件：#include “list”声明方式：&emsp;&emsp;&emsp;&emsp;list l; //空链表&emsp;&emsp;&emsp;&emsp;list l(3); //长度为3的链表&emsp;&emsp;&emsp;&emsp;list l2(3,4); //有两个确定元素的链表 常用成员函数：push_front/pop_front和push_back/pop_back在开头和结尾插入或删除元素 begin() 返回指向第一个元素的迭代器end() 返回末尾的迭代器sort() 对链表中的数据进行排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt; #include &lt;list&gt; #include &lt;numeric&gt; #include &lt;algorithm&gt; using namespace std; //创建一个list容器的实例LISTINT typedef list&lt;int&gt; LISTINT; //创建一个list容器的实例LISTCHAR typedef list&lt;int&gt; LISTCHAR; void main() &#123; //用list容器处理整型数据 //用LISTINT创建一个名为listOne的list对象 LISTINT listOne; //声明i为迭代器 LISTINT::iterator i; //从前面向listOne容器中添加数据 listOne.push_front (2); listOne.push_front (1); //从后面向listOne容器中添加数据 listOne.push_back (3); listOne.push_back (4); //从前向后显示listOne中的数据 cout&lt;&lt;\"listOne.begin()--- listOne.end():\"&lt;&lt;endl; for (i = listOne.begin(); i != listOne.end(); ++i) cout &lt;&lt; *i &lt;&lt; \" \"; cout &lt;&lt; endl; //从后向后显示listOne中的数据 LISTINT::reverse_iterator ir; cout&lt;&lt;\"listOne.rbegin()---listOne.rend():\"&lt;&lt;endl; for (ir =listOne.rbegin(); ir!=listOne.rend();ir++) &#123; cout &lt;&lt; *ir &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //使用STL的accumulate(累加)算法 int result = accumulate(listOne.begin(), listOne.end(),0); cout&lt;&lt;\"Sum=\"&lt;&lt;result&lt;&lt;endl; cout&lt;&lt;\"------------------\"&lt;&lt;endl; //-------------------------- //用list容器处理字符型数据 //-------------------------- //用LISTCHAR创建一个名为listOne的list对象 LISTCHAR listTwo; //声明i为迭代器 LISTCHAR::iterator j; //从前面向listTwo容器中添加数据 listTwo.push_front ('A'); listTwo.push_front ('B'); //从后面向listTwo容器中添加数据 listTwo.push_back ('x'); listTwo.push_back ('y'); //从前向后显示listTwo中的数据 cout&lt;&lt;\"listTwo.begin()---listTwo.end():\"&lt;&lt;endl; for (j = listTwo.begin(); j != listTwo.end(); ++j) cout &lt;&lt; char(*j) &lt;&lt; \" \"; cout &lt;&lt; endl; //使用STL的max_element算法求listTwo中的最大元素并显示 j=max_element(listTwo.begin(),listTwo.end()); cout &lt;&lt; \"The maximum element in listTwo is: \"&lt;&lt;char(*j)&lt;&lt;endl; &#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】3.3二分查找","slug":"【ACM教程】3-3二分查找","date":"2016-11-09T08:40:36.000Z","updated":"2017-04-13T13:25:15.897Z","comments":true,"path":"2016/11/09/【ACM教程】3-3二分查找/","link":"","permalink":"http://www.z16388.top/2016/11/09/【ACM教程】3-3二分查找/","excerpt":"","text":"第三节 二分查找&emsp;&emsp;这次我们要学习的，就是著名的高效的，并且应用非常广泛的二分查找算法，简称二分法（Binary Search）。二分查找的时间复杂度为O(lgn)，是优化程序的常用方法之一。在我们使用的java教科书中，经常会见到作者举的一个例子——猜数字。这个程序就是让你去猜测一个给定范围内的数字，当然，我们可以暴力一点，把所有可能的结果都掏出来试一试——枚举。但是真正在写程序的时候，这样效率可能会非常低，这个时候我们就需要使用二分法来去做这个游戏。 &emsp;&emsp;我们可以这样去做：选择这个区间中间的数，大了，就把它当做新的区间的起点，继续做；小了就往左去找区间，以此类推，这就是我们在数学上学习过的二分法，那么，怎么能够在程序中实现呢？代码如下： 123456789int bSearch(int a[],int b,int low,int high)&#123; int mid; if(low&gt;high) return -1; mid=(low+high)/2; if(b==a[mid]) return mid; if(b&lt;a[mid]) return bSearch(a,b,low,mid-1); else return bSearch(a,b,mid+1,high);&#125; &emsp;&emsp;我们看代码中的函数使用了四个参数，其中需要注意的是，第一个参数不仅仅是一个普通的数组，而是一个经过排序的序列，所以应该对需要查找的数组进行排序再进行二分查找。需要注意的是，我们应当注意对相同数据的处理，就是说如果我们的序列中会出现相同的数据，它应当返回哪一个下标。 &emsp;&emsp;这个函数的功能是查找一个数在数组中是否存在，如果存在返回它的下标；如果不存在，则返回-1。在C++的STL中，给我们提供了类似的函数binary_search()，它的功能是判断一个数是否在给定序列中存在，返回值类型为布尔型。它的三个参数分别为： binary_search(起始地址，终止地址，查找值); &emsp;&emsp;遗憾的是，上面的函数只能告诉我们这个值是否存在，并不能知道它的确切位置，这个时候，我们可以使用这两个函数：lower_bound()和upper_bound()。这两个函数是用来算出要查元素的上界和下界的，意思是说，对于序列中出现相同的元素的情况，这两个函数是可以解决的。但是，需要注意的是： 返回值的类型是地址,不是下标；如果元素出现一次，lower_bounder()返回这个元素的地址，upper_bounder()返回它后面一个元素的地址；如果元素出现多次，lower_bounder()返回第一个元素的地址，upper_bounder()返回最后一个元素的后面一的元素的地址。 &emsp;&emsp;返回值是地址怎么办，我们也可以想办法投机取巧。我们知道，一个数组的名同时是一个数组第一个元素的地址，那么拿得到的地址减去首地址，就刚好是这个元素在数组中的下标了： 1lower_bounder(a,a+100,shu)-a &emsp;&emsp;除此之外，二分法还有非递归的写法，大家可以了解一下： 123456789101112int bSearch(int a[],int b,int n)&#123; int low,high,mid; low=0;high=n-1; while(low&lt;=high) &#123; mid=(low+high)/2; if(a[mid]==b) return mid; if(a[mid]&lt;b) low=mid+1; else high=mid-1; &#125; return -1;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】3-1枚举","slug":"【ACM教程】3-1枚举","date":"2016-11-02T07:55:31.000Z","updated":"2018-03-12T02:11:54.108Z","comments":true,"path":"2016/11/02/【ACM教程】3-1枚举/","link":"","permalink":"http://www.z16388.top/2016/11/02/【ACM教程】3-1枚举/","excerpt":"","text":"第一节 枚举&emsp;&emsp;枚举又叫穷举，是程序设计中最常用的算法之一，是一种很*很暴力的算法。要说它的方法，就是没有方法——通过将所有可能的结果一一列举出来进行判断，获得想要的结果的方法。枚举算法的特点就是比较单纯，容易写出来程序，但是速度非常慢，只能用来解决小规模的问题。 &emsp;&emsp;常见的题型有很多，比如计算空缺算式或者是火柴棒问题，接下来我们来举例说明一道非常经典的题目，来体会一下枚举算法。 &emsp;&emsp;我国古代数学家章丘建在《算经》一书中提过一道数学问题：鸡翁一值钱五，鸡母一值钱散，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何。这就是经典的百钱百鸡问题。除了原书中使用的方程式之外，我们还可以使用枚举法来进行计算，代码如下： 12345678910111213#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int i,j,k; for(i=1;i&lt;=20;i++) for(j=1;j&lt;=33;j++) for(k=1;k&lt;=100;k++) if((i*5+j*3+k/3==100)&amp;&amp;(i+j+k==100)&amp;&amp;(k%3==0)) printf(\"%d %d %d\\n\",i,j,k); return 0;&#125; &emsp;&emsp;在之前杭电的练习题中，我们也遇到过使用枚举算法的题目，hdu2010题的水仙花数就是。大家可以练习一下全排列的问题，练习一下枚举算法。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"关于杉果社区发展的二三想法","slug":"关于杉果社区发展的二三想法","date":"2016-10-31T04:52:28.000Z","updated":"2017-04-13T13:25:20.504Z","comments":true,"path":"2016/10/31/关于杉果社区发展的二三想法/","link":"","permalink":"http://www.z16388.top/2016/10/31/关于杉果社区发展的二三想法/","excerpt":"","text":"&emsp;&emsp;在杉果一年多，不算久也不算短，也剁了很多东西。从开始的陌生，到现在的熟悉，杉果带给了我很多（剁手的机会）一步步走来，看着社区的变化，想要说很多，各种想法也很凌乱。总之，还是本着站着说话不腰疼的立场，说一说自己的看法吧。 &emsp;&emsp;社区要想发展，定位、内容、管理、活动、UI等等，各种都不能少，那么，我就结合现状，发表一下自己的意见。 &emsp;&emsp;首先在定位上，杉果社区应该是成为一个玩家的交流平台，而不是一个评价商品的地方。那么，我们就应该给客户提供这样一个地方。之前我在给员子的私信中提到了这一点。刚好，也看到了这样的一个功能即将要上线的消息，我觉得，在“垃圾内容”上，应该很快会有所改善。毕竟，比起谈论什么怎么还不发key，我们更想看到什么更好剁，大家一起剁什么。 &emsp;&emsp;当然，没了活动时的抱怨，干货也要有对不对。所以第二点比较重要的，就是“独家内容”。必须是杉果特色的，必须是别家都找不到的。像之前和游戏厂商黑恶势力的谈笑风生活动啦，这样的好机会不应该成为给直播平台带来流量的活动对不对，为什么要便宜别人呢。结合自己的社区，发布自己的独家内容，这一点很重要。而且，杉果电台虽然做的很良心，但是我觉得受众可能还不是很广。我觉得如果去b站发视频的话，可能会有更好的效果。 &emsp;&emsp;管理层面我觉得暂时还不需要考虑，因为没人（心疼）。当然，人多之后的打算也是要提前做的。分区，管理，内容，各种方面，都要去做，当然这是后话。 &emsp;&emsp;活动，社区活动从来不缺，看万圣节活动对不对，下面复制粘贴300多回复，多火热。但是，活动结束呢？没有员子水贴和某up主的视频，我觉得可能三四天都看不到新的内容。活动是带来流量的方法，但是也要做对活动。像这样直接拿key走的活动，给人一种廉价感，而且是为了奖品而活动。我觉得应该活动日常化，积分化，让所有的人都参与进来。不是什么新人活动啦，发评测活动啦，这样除了会让人注册一堆小号，或者多一堆没有营养的测评之外，没有别的用处了。记得很久以前听说社区会有大改，但是等了好久也没有见到变化。。。社区现状就是抱怨和领key的地方。。。 &emsp;&emsp;UI不说了，毕竟不是专业搞UI的，但是至少steam的api该更新一下了，移动端密码框的安全性还有不能用psn的话就去掉这个功能对不对。 &emsp;&emsp;总之，千言万语总结成一句话：希望杉果越来越好，至少，我会等着。","categories":[],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://www.z16388.top/tags/游戏/"},{"name":"心情","slug":"心情","permalink":"http://www.z16388.top/tags/心情/"}],"keywords":[]},{"title":"ACM常用模版","slug":"ACM常用模版","date":"2016-10-30T15:57:55.000Z","updated":"2017-04-13T13:25:20.947Z","comments":true,"path":"2016/10/30/ACM常用模版/","link":"","permalink":"http://www.z16388.top/2016/10/30/ACM常用模版/","excerpt":"","text":"求素数1234567int su(int b)&#123; for(int i=2;i&lt;=(int)sqrt(b);i++) &#123; if(b%i==0) return 0; &#125; return 1;&#125; 最大公约数和最小公倍数欧几里得定力：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。123456789int gcd(int a,int b) //最大公约数&#123; if(b==0) return a; else return gcd(b,a%b);&#125;int lcm(int a,int b) //最小公倍数&#123; return a/gcd(a,b)*b;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】2.4编程细节","slug":"【ACM教程】2-4编程细节","date":"2016-10-30T14:39:21.000Z","updated":"2017-04-13T13:25:15.893Z","comments":true,"path":"2016/10/30/【ACM教程】2-4编程细节/","link":"","permalink":"http://www.z16388.top/2016/10/30/【ACM教程】2-4编程细节/","excerpt":"","text":"第四节 编程细节 细节决定成败，态度决定一切。 &emsp;&emsp;在我们程序编写的过程中，有一些细节我们需要注意，这对你以后的代码质量都会有很大的影响。下面，我会介绍一些常见的细节。 合理的缩进&emsp;&emsp;虽然编译器会忽略代码中一切空格和换行，但是一段乱奇葩早的缩进的代码真的是能逼死强迫症的。 &emsp;&emsp;常见的缩进方式是使用Tab键，默认4个空格。相同等级的语句不缩进，次级语句需要缩进，比如：123for(int i=1;i&lt;=100;i++) sum+=i;printf(\"%d\\n\",sum); &emsp;&emsp;在上面的代码中，我们看到循环体是累加计算，属于循环语句的次级语句，所以应当缩进。而输出是和循环同一等级的，所以要和for循环对齐。 &emsp;&emsp;除此之外，大括号的缩进也很重要，这一点在下面会介绍。 统一的大括号&emsp;&emsp;大括号也是决定一个程序是否整齐的关键，我们常用以下两种方法：12345678910int main()&#123; int sum=0; for(int i=1;i&lt;=100;i++) &#123; sum+=i; &#125; printf(\"%d\\n\",sum); return 0;&#125; 123456789public class Main() &#123; public static void main(String args[]) &#123; int sum=0; for(int i=1;i&lt;=100;i++) &#123; sum+=i; &#125; System.out.println(sum); &#125;&#125; 不同类型数据之间的计算&emsp;&emsp;这种情况经常出现在ACM的题目中，就比如hdu2002和hdu2009。如果是把int型数据赋值给double是没有问题的，但是如果是double数据给int，就会出现精度的损失，造成计算的失误。 &emsp;&emsp;hdu2002中的分数4/3。如果直接在程序里这么写，程序会当成4整除3来计算，应当写成4.0/3.0。 &emsp;&emsp;hdu2009题如果想要写成m=sqrt(m)的话，就要保证m的类型是double类型，否则在赋值时会损失精度。 程序的模块化&emsp;&emsp;模块化思想很重要，像C++和Java都是面向对象的编程语言，集成化程度很高。但是并不意味着我们写C就不要模块化。模块化的程序可读性高，便于修改。 &emsp;&emsp;比如hdu2005，判断是否是闰年的题目。我在判断是否是闰年时，写了一个函数，功能是：如果是闰年返回1，否则返回0。 &emsp;&emsp;当然不仅限于如此，假设某程序需要按照一个公式进行计算，但是后来我们突然想要改变计算过程，如果你把公式写在函数里，那么只需要修改函数就行了，避免了对主函数的修改。 关于数组&emsp;&emsp;关于数组有两点需要注意。 &emsp;&emsp;首先是对下标的确定。我们知道，数组的下标和元素的序号是刚好相差1的。那么我们可以抛弃数组的第一个元素，只使用数组的第二个往后的元素，这样可以统一下标和元素序号，比如： 1234int a[101];for(int i=1;i&lt;=100;i++) &#123; scanf(\"%d\",&amp;a[i]);&#125; &emsp;&emsp;再者，在申请数组大小的时候，我们可以多申请几个。有时候也可能要同时申请多组，这时候，推荐大家使用宏定义，比如： 12#define N 10010int a[N],b[N],c[N];","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"hud2011-2020答案","slug":"hud2011-2020答案","date":"2016-10-30T14:28:10.000Z","updated":"2017-04-13T13:25:15.864Z","comments":true,"path":"2016/10/30/hud2011-2020答案/","link":"","permalink":"http://www.z16388.top/2016/10/30/hud2011-2020答案/","excerpt":"","text":"hdu2011 多项式求和12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int m,n; double sum=0.0,f=1.0; scanf(\"%d\",&amp;m); while(m--) &#123; scanf(\"%d\",&amp;n); sum=0.0,f=1.0; for(int i=1;i&lt;=n;i++) &#123; sum+=f/i; f=-1.0*f; &#125; printf(\"%.2f\\n\",sum); &#125; return 0;&#125; hud2012 素数判定123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int cal(int a)&#123; return a*a+a+41;&#125;int su(int b)&#123; for(int i=2;i&lt;=(int)sqrt(b);i++) &#123; if(b%i==0) return 0; &#125; return 1;&#125;int main()&#123; int x,y,flag=1; while(scanf(\"%d%d\",&amp;x,&amp;y)&amp;&amp;(x||y)) &#123; flag=1; for(int i=x;i&lt;=y;i++) if(su(cal(i))==0) flag=0; if(flag==1) printf(\"OK\\n\"); else printf(\"Sorry\\n\"); &#125; return 0;&#125; hdu2013 蟠桃记&emsp;&emsp;这是一道非常经典的OI明星题，原名是《猴子吃桃》，我在2008年初二的时候第一次接触这道题目，也是因为这一道题爱上了算法。这道题目是非常经典的循环题，类似的题目还有《王小二切大饼》、《母牛问题》等。 123456789101112131415#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n,sum=0; while(scanf(\"%d\",&amp;n)!=EOF) &#123; sum=1; for(int i=1;i&lt;n;i++) &#123; sum=2*(sum+1); &#125; printf(\"%d\\n\",sum); &#125; return 0;&#125; hdu2014 青年歌手大赛_评委会打分&emsp;&emsp;这是一道日常生活中常见的题目，唯一需要注意的就是在使用sort()函数时，需要排序的范围，这里还请大家思考一下。 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 110using namespace std;int li[N];int main()&#123; int n; double p; while(scanf(\"%d\",&amp;n)!=EOF) &#123; p=0.0; memset(li,0,sizeof(li)); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;li[i]); &#125; sort(li+1,li+n+1); for(int i=2;i&lt;n;i++) &#123; p+=li[i]; &#125; printf(\"%.2f\\n\",p/(n-2)); &#125; return 0;&#125; hdu2015 偶数求和&emsp;&emsp;这道题算是这几道里面比较麻烦的了，开始想的可能比较复杂，取第几项加几什么的很烦。但是后来发现，按照题目的意思直接去计算可能比较简单。 &emsp;&emsp;首先，我们的思路是算出每组数的第一个数2+(m2)\\i,然后向后求和，去平均值。最后要判断一下最后一组是否完全，不全的话则需要除以n%m求平均值。 &emsp;&emsp;除此之外，还有输出的循环控制，最后一个元素的后面没有空格。代码如下： 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n,m; while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF) &#123; int sum=0,a=2,flag=0,i; for(i=1;i&lt;=n;i++) &#123; sum+=a; a+=2; if(i%m==0) &#123; flag++; if(flag!=1) printf(\" \"); printf(\"%d\",sum/m); sum=0; &#125; &#125; if(n%m==0) printf(\"\\n\"); else printf(\" %d\\n\",sum/(n%m)); &#125; return 0;&#125; hdu2016 数据的交换输出1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n,a[110],mi; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; mi=1; for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); if(a[i]&lt;a[mi]) &#123; mi=i; &#125; &#125; int t; t=a[mi]; a[mi]=a[1]; a[1]=t; printf(\"%d\",a[1]); for(int i=2;i&lt;=n;i++) &#123; printf(\" %d\",a[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125; hdu2017 字符串统计123456789101112131415161718#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n,sum; scanf(\"%d\",&amp;n); getchar(); while(n--) &#123; char s; int sum=0; while((s=getchar())!='\\n') &#123; if(s&gt;=48&amp;&amp;s&lt;=57) sum++; &#125; printf(\"%d\\n\",sum); &#125; return 0;&#125; hdu2018 母牛的故事&emsp;&emsp;这是一道简单的动态规划问题，这类问题的其他内容我们将在后来的教程中着重讨论。 12345678910111213141516#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int func(int y)&#123; if(y&lt;4) return y; else return func(y-3)+func(y-1);&#125;int main()&#123; int n; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; printf(\"%d\\n\",func(n)); &#125; return 0;&#125; hdu2019 数列有序！123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define N 110int a[N];using namespace std;int main()&#123; int n,m,ji=0; while(scanf(\"%d%d\",&amp;n,&amp;m)&amp;&amp;(n||m)) &#123; memset(a,0,sizeof(a)); ji=1; for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++) &#123; if(a[i]&gt;=m) &#123; ji=i; break; &#125; &#125; for(int i=n+1;i&gt;ji;i--) &#123; a[i]=a[i-1]; &#125; a[ji]=m; printf(\"%d\",a[1]); for(int i=2;i&lt;=n+1;i++) &#123; printf(\" %d\",a[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125; hdu2020 绝对值排序```C++","categories":[],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://www.z16388.top/tags/hdu/"},{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"}],"keywords":[]},{"title":"hdu1089-1096输入输出练习答案","slug":"1089-1096输入输出练习","date":"2016-10-28T11:40:22.000Z","updated":"2017-04-13T13:25:15.839Z","comments":true,"path":"2016/10/28/1089-1096输入输出练习/","link":"","permalink":"http://www.z16388.top/2016/10/28/1089-1096输入输出练习/","excerpt":"","text":"&emsp;&emsp;这是ACM基本的输入输出练习，答案如下： hdu10891234567891011#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b)!=EOF) &#123; printf(\"%d\\n\",a+b); &#125; return 0;&#125; hdu109012345678910111213#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,n; scanf(\"%d\",&amp;n); while(n--) &#123; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",a+b); &#125; return 0;&#125; hdu10911234567891011#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b)&amp;&amp;(a||b)) &#123; printf(\"%d\\n\",a+b); &#125; return 0;&#125; hdu1092123456789101112131415#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; int s=0,b,i; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;b); s+=b; &#125; printf(\"%d\\n\",s); &#125; return 0;&#125; hdu1093123456789101112131415161718#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; scanf(\"%d\",&amp;n); while(n--) &#123; int a,b,i,s=0; scanf(\"%d\",&amp;a); for(i=1;i&lt;=a;i++) &#123; scanf(\"%d\",&amp;b); s+=b; &#125; printf(\"%d\\n\",s); &#125; return 0;&#125; hdu109412345678910111213141516#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; while(scanf(\"%d\",&amp;n)!=EOF) &#123; int s=0,b,i; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;b); s+=b; &#125; printf(\"%d\\n\",s); &#125; return 0;&#125; hdu10951234567891011#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b)!=EOF) &#123; printf(\"%d\\n\\n\",a+b); &#125; return 0;&#125; hdu109612345678910111213141516171819#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; scanf(\"%d\",&amp;n); while(n--) &#123; int a,b,i,s=0; scanf(\"%d\",&amp;a); for(i=1;i&lt;=a;i++) &#123; scanf(\"%d\",&amp;b); s+=b; &#125; printf(\"%d\\n\",s); if(n!=0) printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://www.z16388.top/tags/hdu/"},{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"}],"keywords":[]},{"title":"hdu2000-2010答案","slug":"hdu2000-2010","date":"2016-10-28T11:16:10.000Z","updated":"2017-04-13T13:25:15.854Z","comments":true,"path":"2016/10/28/hdu2000-2010/","link":"","permalink":"http://www.z16388.top/2016/10/28/hdu2000-2010/","excerpt":"","text":"hdu2000 ASCII码排序&emsp;&emsp;这是一道简单的排序问题，可以直接使用sort函数解决，但是如果使用值交换的方法则需要注意回车的消除。 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; char a[4],t; while(scanf(\"%c%c%c\",&amp;a[1],&amp;a[2],&amp;a[3])!=EOF) &#123; getchar(); if(a[1]&gt;a[2]) &#123; t=a[1]; a[1]=a[2]; a[2]=t; &#125; if(a[2]&gt;a[3]) &#123; t=a[2]; a[2]=a[3]; a[3]=t; &#125; if(a[1]&gt;a[2]) &#123; t=a[1]; a[1]=a[2]; a[2]=t; &#125; printf(\"%c %c %c\\n\",a[1],a[2],a[3]); &#125; return 0;&#125; 12345678910111213#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; char str[3]; while(cin&gt;&gt;str) &#123; sort(str,str+3); cout&lt;&lt;str[0]&lt;&lt;\" \"&lt;&lt;str[1]&lt;&lt;\" \"&lt;&lt;str[2]&lt;&lt;endl; &#125; return 0;&#125; hdu2001 计算两点间的距离&emsp;&emsp;这是一道简单的计算题，第一次使用了数学函数和双精度的数，没有太多需要注意的地方。 1234567891011121314#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; double x1,y1,x2,y2; while(cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2) &#123; double jie=sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)); printf(\"%.2lf\\n\",jie); &#125; return 0;&#125; hdu2002 计算球体体积&emsp;&emsp;这是一道求球体体积的计算题，需要注意的是，这里可能会出现整数和实数之间的乘法，需要注意的是题目中的4/3需要写成4.0/3.0，这一点很容易犯错。 &emsp;&emsp;还有一点需要注意的是，我们应当使用题目中所给的pi值，否则结果可能会出现一定的误差。 123456789101112131415#define PI 3.1415927#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; double r; while(cin&gt;&gt;r) &#123; double jie=4.0*PI*r*r*r/3.0; printf(\"%.3lf\\n\",jie); &#125; return 0;&#125; hdu2003 求绝对值123456789101112131415#define PI 3.1415927#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; double r; while(cin&gt;&gt;r) &#123; double jie=fabs(r); printf(\"%.2lf\\n\",jie); &#125; return 0;&#125; #hdu2004 成绩转换 &emsp;&emsp;这道题需要仔细审题，一定要注意分数的范围，无论是上界还是下界。 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int grade; while(scanf(\"%d\",&amp;grade)!=EOF) &#123; if(grade&gt;=90&amp;&amp;grade&lt;=100) printf(\"A\\n\"); else if(grade&gt;=80&amp;&amp;grade&lt;=89) printf(\"B\\n\"); else if(grade&gt;=70&amp;&amp;grade&lt;=79) printf(\"C\\n\"); else if(grade&gt;=60&amp;&amp;grade&lt;=69) printf(\"D\\n\"); else if(grade&gt;=0&amp;&amp;grade&lt;=59) printf(\"E\\n\"); else printf(\"Score is error!\\n\"); &#125; return 0;&#125; hdu2005 第几天？123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int runn(int yy)&#123; if(yy%400==0||(yy%100!=0&amp;&amp;yy%4==0)) return 1 ; else return 0 ;&#125;int main()&#123; int y,m,d,sum; while(scanf(\"%d/%d/%d\",&amp;y,&amp;m,&amp;d)!=EOF) &#123; sum = 0 ; switch(m-1) &#123; case 11 : sum+=30; case 10 : sum+=31; case 9 : sum+=30; case 8 : sum+=31; case 7 : sum+=31; case 6 : sum+=30; case 5 : sum+=31; case 4 : sum+=30; case 3 : sum+=31; case 2 :if (runn(y)==1) sum+=29; else sum+=28; case 1 : sum+=31; &#125; sum+=d; printf(\"%d\\n\",sum); &#125; return 0;&#125; hdu2006 求奇数的乘积12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; int liste[100]; while(scanf(\"%d\",&amp;n)!=EOF) &#123; int i; for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;liste[i]); int sum=1; for(i=1;i&lt;=n;i++) if(liste[i]%2!=0) sum*=liste[i]; printf(\"%d\\n\",sum); &#125; return 0;&#125; hdu2007 平方和与立方和123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int m,n,t,i; while(scanf(\"%d%d\",&amp;m,&amp;n)!=EOF) &#123; if(m&gt;n) &#123; t=m; m=n; n=t; &#125; int s1=0,s2=0; for(i=m;i&lt;=n;i++) &#123; if(i%2==0) s1=s1+i*i; else s2=s2+i*i*i; &#125; printf(\"%d %d\\n\",s1,s2); &#125; return 0;&#125; hdu2008 数值统计123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; double liste[100]; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; for(int i=1;i&lt;=n;i++) &#123; scanf(\"%lf\",&amp;liste[i]); &#125; int a=0,b=0,c=0; for(int i=1;i&lt;=n;i++) &#123; if(liste[i]&lt;0) a++; if(liste[i]==0) b++; if(liste[i]&gt;0) c++; &#125; printf(\"%d %d %d\\n\",a,b,c); &#125; return 0;&#125; hdu2009 求数列的和&emsp;&emsp;这一题看起来很简单，但是需要进行不同类型数据的运算。这一点还是比较容易犯一些错误的，大家需要注意一些。 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; double sum; int m,n; while(scanf(\"%d%d\",&amp;m,&amp;n)!=EOF) &#123; sum=0.0; double mm=m; for(int i=1;i&lt;=n;i++) &#123; sum+=mm; mm=sqrt(mm); &#125; printf(\"%.2f\\n\",sum); &#125; return 0;&#125; hdu2010 水仙花数&emsp;&emsp;这是一道很经典的题目，可能需要使用比较多的判断。 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int m,n,flag; while(scanf(\"%d%d\",&amp;m,&amp;n)!=EOF) &#123; int i=m; flag=0; for(i=m;i&lt;=n;i++) &#123; int a,b,c; a=i/100; b=i/10%10; c=i%10; if(i==a*a*a+b*b*b+c*c*c) &#123; if(flag==0) &#123; flag++; printf(\"%d\",i); &#125; else &#123; flag++; printf(\" %d\",i); &#125; &#125; &#125; if(flag==0) &#123; printf(\"no\\n\"); &#125; else &#123; printf(\"\\n\"); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://www.z16388.top/tags/hdu/"},{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"}],"keywords":[]},{"title":"【ACM教程】2.2从排序开始","slug":"【ACM教程】2-2从排序开始","date":"2016-10-28T08:29:49.000Z","updated":"2017-04-13T13:25:15.889Z","comments":true,"path":"2016/10/28/【ACM教程】2-2从排序开始/","link":"","permalink":"http://www.z16388.top/2016/10/28/【ACM教程】2-2从排序开始/","excerpt":"","text":"第二节 从排序开始&emsp;&emsp;今天看群里有同学说：“看dalao的博客，今天晚上估计要讲C++框架了”，这我能忍？让你们猜到了，我该多没面子啊。所以呢，今天我就把教程改了一下，顺便更好地串联后面的内容。 &emsp;&emsp;如题，我们今天要讲的是排序，排序是写程序中，比较重要的一个部分，以后也会专门做一个章节去讲，今天只涉及一些简单的排序方法。 这他喵叫排序？——桶排序&emsp;&emsp;一直讲排序，可能会有些枯燥，我们先来点好玩的。 &emsp;&emsp;桶排序是最简单的排序算法，思路也是最奇葩的，奇葩到我都不想把它算作排序。那么它具体是怎么来的呢，我们来看下面一个题目： &emsp;&emsp;在一次体育比赛中，某个选手的动作将会由多名裁判进行打分，分值在0～10之间的整数。输入一个数组，存放有N名裁判给出的分数(1&lt;=N&lt;=10000)，输出要求从大到小输出裁判打出的分数。 &emsp;&emsp;这道题很简单，有同学该说了，“我知道！用冒泡！”行，冒泡的确可以解决这个问题，但是时间复杂度可能会比较高。这道题，有一种更好的方法，那就是我们这一节的主角——桶排序，今天学了可能一辈子都再也用不到的排序方法。那么，究竟应该怎么去做呢？ &emsp;&emsp;首先声明一个长度为11的数组a[11]，再将该数组的每个元素都赋值为0。当选手得分为s时，进行操作a[s]++。这样进行一遍便利之后，我们数组中每个元素都将表示得s分的次数。这样，我们只需要将s打印a[s]次，就会得到我们需要的结果，代码如下： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define N 10010int grade[N];using namespace std;int main()&#123; int n,a[11]; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;grade[i]); &#125; memset(a,0,sizeof(a)); for(int i=1;i&lt;=n;i++) &#123; a[grade[i]]++; &#125; for(int i=10;i&gt;=1;i--) &#123; if(a[i]==0) continue; else &#123; for(int j=1;j&lt;=a[i];j++) &#123; printf(\"%d\",i); &#125; &#125; &#125; printf(\"\\n\"); return 0;&#125; 基础中的基础，“牛奶杯”排序&emsp;&emsp;有一杯水，一杯牛奶，想让他们两个换一下，那么我们得需要另一个杯子作为中转站。这是我们在写程序中，进行值交换的最简单的方法。比如航电上的hdu2000题：http://acm.hdu.edu.cn/showproblem.php?pid=2000这就是一道使用牛奶杯排序法的题目,我们只需要一个中间变量就可以实现两个变量值的交换，然后比较三次达到排序的目的。这种方法比较麻烦，适用于样本比较少的排序。 C++，带带我（利用C++的STL函数排序）&emsp;&emsp;其实在竞赛中，我们最常使用的是C++的STL中的排序函数。（STL是C++的标准模版库） &emsp;&emsp;sort()函数是我们最常用的排序函数，它在algorithm头文件中，使用时需要在你的程序上方添加一行： 1#include&lt;algorithm&gt; &emsp;&emsp;排序函数在比赛中都是被允许的，它拥有三个参数： sort(起始地址,终止地址,[比较方法]) &emsp;&emsp;其中比较方法不是必须参数，它的使用方法我们将会在下一节进行说明。那么，一个使用sort()函数进行排序的简单程序如下： 1234567891011121314151617#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[11]; for(int i=1;i&lt;=10;i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a+1,a+10); for(int i=1;i&lt;=10;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; return 0;&#125; &emsp;&emsp;刚刚的那道hdu2000也可以使用这种方法去做，代码如下： 12345678910111213#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; char str[3]; while(cin&gt;&gt;str) &#123; sort(str,str+3); cout&lt;&lt;str[0]&lt;&lt;\" \"&lt;&lt;str[1]&lt;&lt;\" \"&lt;&lt;str[2]&lt;&lt;endl; &#125; return 0;&#125; 初始化&emsp;&emsp;除了排序，初始化也很重要。在做和图、矩阵有关的题目时，我们经常会对二维数组进行初始化。将两个无关点之间的距离初始化为无穷，或者是给单位矩阵非对角线元素进行的初始化。C++给我们提供了memset() 函数实现初始化，这个函数在cstring头文件中。下面是memset() 函数的参数： Memset(数组名，初始化内容，初始化范围)；","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"大连交通大学 软件竞赛协会介绍","slug":"aboutdjac","date":"2016-10-22T05:46:19.000Z","updated":"2019-11-16T14:37:12.703Z","comments":true,"path":"2016/10/22/aboutdjac/","link":"","permalink":"http://www.z16388.top/2016/10/22/aboutdjac/","excerpt":"","text":"关于大连交通大学软件竞赛协会&emsp;&emsp;大连交通大学软件竞赛协会（以下简称：协会），前身是大连交通大学ACM俱乐部。ACM俱乐部是由参加ACM竞赛的学长们自发组织成立的学习交流性组织，多年来诞生了我校大批技术大牛。前辈们参赛诸多，为我校捧得诸多荣誉。协会由学生自发组织，大连交通大学软件学院支持，进行算法相关的学习与培训，参加ACM和蓝桥杯为主的算法竞赛，为校争光。 协会招新&emsp;&emsp;协会面向大连交通大学全体四年制／五年制全日制本科生开放，如果你拥有以下条件那就更好了~： 参加过ACM／OI等竞赛的 对算法感兴趣或接触过的 学习过C/C++或Java &emsp;&emsp;联系我们：&emsp;&emsp;&emsp;&emsp;QQ群号：216063864 大连交通大学竞赛相关政策&emsp;&emsp;根据《大连交通大学关于大学生科技创新活动的若干规定》（大交大发[2006】63号]、《大连交通大学指导学生科技创新活动教师工作量核算及奖励办法》（大交大发[2007]147号）等文件精神，为进一步加强和规范我校大学生科技创新活动的深入发展，培养学生的创新精神和实践能力，鼓励学生积极参与科技创新活动，鼓励教师积极参与指导大学生科技创新活动、浓厚校园学术科技氛围，提高大学生创新能力和综合素质，颁发了大学生科技创新活动实施细则。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"MAC下hexo的安装与使用","slug":"MAC下hexo的安装与使用","date":"2016-10-06T15:37:24.000Z","updated":"2017-04-13T13:25:20.842Z","comments":true,"path":"2016/10/06/MAC下hexo的安装与使用/","link":"","permalink":"http://www.z16388.top/2016/10/06/MAC下hexo的安装与使用/","excerpt":"","text":"&emsp;&emsp;不知道就是造了什么孽，电脑，又炸了。唉～没想到，我这么肝，倒下的竟然是我的电脑，也是可怕。 &emsp;&emsp;闲话不多说了。哥哥把他的Mac接我救急用了，刚到手还没捂热乎呢，只是随意的装了一些必须的东西。什么java啦，jsp啦，xcode啦。总之搞了很多，但是博客这个东西一直没搞好，因为一直没去研究Mac下GitHub的使用。今天，借着这个炸的机会，把我的博客给挪到啦Mac上，继续更新啦。 &emsp;&emsp;讲道理，苹果的工业设计还是很好的。到手没几天，已经熟悉的七七八八了；当然也不能说熟悉到windows这种程度，但是也是到了能够日常使用，应付一些简单的coding。我们话说回来啊，这个hexo我本来是打算放弃掉的。因为前几天，我用微软的azure搭建了一个Wordpress的博客。但是令人蛋疼的是，DreamSpark订阅的微软Azure它不能使用域名绑定功能，这就很尴尬了，谁会顶着一个超长的链接去看你的博客呢对不对。所以既然电脑炸了，没了办法，那只能研究mac上怎么去使用hexo了。来，我们闲话不多说，正式开始了。 第一步 安装Node.js&emsp;&emsp;这是hexo必须的一步，毕竟是基于Node.js的框架嘛。至于在哪里下载，怎么安装，以及GitHub的注册，域名什么的，我就不过多赘述了，这在我之前的博客里面都有的。 第二步 安装hexo&emsp;&emsp;这里直接使用Node.js的npm去安装，在终端中，浏览到你想要存放博客内容的文件夹，比如cd /Applications/blog。之后执行hexo的安装命令： 1sudo npm install -g hexo &emsp;&emsp;安装好之后，把你之前博客的内容放到里面去；如果没有，则执行hexo init。然后就可以正常地去使用你的hexo了，和windows环境下的操作完全一样。 &emsp;&emsp;唉～说点题外话，讲道理，上天真的是逼我这学期要好好学习啊，害怕。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"}],"keywords":[]},{"title":"联想Y400折腾第二天","slug":"联想Y400折腾第二天","date":"2016-09-30T13:45:23.000Z","updated":"2017-04-13T13:25:15.964Z","comments":true,"path":"2016/09/30/联想Y400折腾第二天/","link":"","permalink":"http://www.z16388.top/2016/09/30/联想Y400折腾第二天/","excerpt":"","text":"&emsp;&emsp;我也是够闲的。本着不抛弃，不放弃地原则，抢救我的笔记本小Y。虽然从早上开机到现在，我。。。不不不，不能奶！总之，倒持了一天吧，不说成果怎么样，也是有一些收获的。相比于昨天的硬件，我把今天折腾的方向转向了软件。 &emsp;&emsp;嘛，有一只老学长，作为长者，在计算机的各种心肝脾肺肾上都有涉猎，我很是佩服的一颗赛艇。其实我昨天就想请教他的，但是硅脂到了，也就没麻烦他了。但是，对于硬件靠脚踹，软件做系统的我，想要搞个大新闻出来，也是没那么容易的。 &emsp;&emsp;看了一上午的《齐木楠雄的灾难》，真的希望万能的齐神能够保佑我。打开了AIDA64，一直监测着CPU的温度——毕竟我是怀疑CPU出问题了的。然后我就发现，AIDA64有个功能，叫做“生成报告”，随手就点了进去。然后，搞了一大串东西出来。我就看啊看，天哪，这个东西把我电脑里各种信息都搞出来了，比香港记者的新闻还要详细，不能忍。我就往下看，看到了超频这一项，发现我的CPU超频了15%。我就怀疑，是不是超频让CPU过热了，才造成的死机。 &emsp;&emsp;我就去百毒了一下，怎么去关掉超频。看了一会儿觉得太麻烦，就放弃了。哎~还要进BIOS,还不如等我哥把他的笔记本给我寄过来呢。。。好麻烦~好麻烦。 &emsp;&emsp;刚好，这会儿去问候了一下我们的老学长。老学长提了提裤腰回复道：“你这是睿频吧”。 &emsp;&emsp;天哪，睿频，睿频是啥，我不能说我不知道什么是睿频吧，多丢人。百毒，百毒，赶紧百毒。很关键啊，有一篇很关键的博文告诉我了睿频和超频的区别。好吧，不是这玩意儿的错，那我只能继续求助长者了。 &emsp;&emsp;“是不是你的系统炸了”。 &emsp;&emsp;ありえない、ありえない！有时候关机之后都开不开，怎么可能是软件的问题，肯定是硬件的问题。 &emsp;&emsp;“我觉得不是CPU导致的，你硅脂没涂好吧。” &emsp;&emsp;嘛~不排除这种可能，但是至少比之前的强很多啊。 &emsp;&emsp;长者的话总是言简意赅：“唔。。。那你去看看事件管理器吧。” &emsp;&emsp;事件管理器？事件管理器！事件管理器はなに～？わがりｒない！！！はやく百毒！百毒百毒愛してる～！嗯嗯，百毒不负众望，在众多广告和莆田系医院和工口网站中，我找到了正确答案。 &emsp;&emsp;找啊找啊，摸索了两分钟，搞清楚了这是个什么东西。あああああ～一堆错误和警告啊，作为程序猿，肯定要看错误嘛，警告是个什么东西!程序猿会看的警告，只有FBI的好吗！！！咳~咳~~ &emsp;&emsp;在事件管理器中，我看到了一个比较敏感的时间。2016年9月26日晚上21：40：23。没错了！就是这个时间!第一次自动关机的时候！只要看每次错误关机的时间，以及前面发生了什么！不就知道错误在哪里了吗！！！我真是太机智了!! &emsp;&emsp;这时候，我看到了一连串的四个来自CPU的错误，天哪！肯定是它！绝对是CPU！还说不是！呵呵呵!被我打脸了吧！哈哈哈哈~但是。。。我又去查了一下，好吧，然而并没有什么卵关系，这是因特尔节能技术的那个功能。哎，又一次失望了。 &emsp;&emsp;但是，我又多看了一眼！！！就是你了！犯人就是你!!!! &emsp;&emsp;查了一下，果然，这个服务！就是鲁大师！！！修改的！！！！！鲁大娘！！！！原来罪魁祸首！！！就是你啊！！！！害怕。然后我去开启这个服务，但是发现，缺少模块，还原服务的话虽然可以做到，但是我觉得可以顺便做一个系统嘛，一年了也该换了。再说今天一天都没。。。。不不不！不能奶!好吧，再死机我就装win10。 &emsp;&emsp;胆儿肥了之后，我又上FF14排了个本，打了2小时！@#￥%。（23333懂的都懂）都没有问题。嘛~今天是撑过去了，但是，还是再观察一下吧。反正万一修不好的话（这不是钦定！），有我哥的笔记本嘛~233333。讲道理，这么赛艇的大新闻，还是第一次搞。嘛~自己修的话，还是比那些个电脑店放心靠谱的~。","categories":[],"tags":[{"name":"笔记本","slug":"笔记本","permalink":"http://www.z16388.top/tags/笔记本/"}],"keywords":[]},{"title":"联想Y400拆机换硅脂过程","slug":"联想Y400拆机换硅脂过程","date":"2016-09-29T08:02:08.000Z","updated":"2017-04-13T13:25:20.497Z","comments":true,"path":"2016/09/29/联想Y400拆机换硅脂过程/","link":"","permalink":"http://www.z16388.top/2016/09/29/联想Y400拆机换硅脂过程/","excerpt":"","text":"&emsp;&emsp;最近笔记本出了一个问题，从前天开始，玩着玩着就炸了。从讨鬼传开始，一玩就自动断电，一点办法都没有。前天晚上开始炸了1次，昨天炸了3次，但是还是可以玩的。然后查了一下，可能是散热的问题，就去网上买了硅脂换了。今天换上，还是有些问题，但是整个拆机的过程还是很惊险刺激的，下面分享给大家： &emsp;&emsp;首先是我们今天的患者，联想Y400。 &emsp;&emsp;然后是我们的硅脂：MX-4 &emsp;&emsp;接下来是工具介绍： 一套小螺丝刀一个用来吸螺丝的螺丝刀一个拆笔记本专用的小螺丝刀棉签酒精雕刻刀（不知道干什么用）清灰刷 &emsp;&emsp;之后进行的是Y400的标准拆解过程，将电池拆掉，后盖打开，拆掉硬盘光驱以及内存条。 &emsp;&emsp;然后我们可以拆一下网卡的排线。小心翼翼的用镊子夹掉，然后卸下唯一一个螺丝，就可以拿掉了。 &emsp;&emsp;接下来是拆键盘了。键盘还是比较好拆的，把两个螺丝卸掉，就可以抠出来了。 &emsp;&emsp;然后我们要把键盘面的电源键排线，触控板排线和键盘排线拆掉；再把反面的风扇排线拆掉，再卸掉螺丝，就可以拆掉键盘面的面板了：&emsp;&emsp;这是卸掉的键盘面板： &emsp;&emsp;拆掉之后，把摄像头排线和硬盘排线拆掉，再卸掉主板的两个螺丝就可以拆了。因为有一个风扇的排线不是太好拆，所以我就没拆，但是这样已经可以拆散热件了： &emsp;&emsp;我怕刮花了屏幕，所以就垫了一本书，然后拧掉散热片的螺丝，就可以涂硅脂了。 &emsp;&emsp;涂完之后我就迫不及待地装上去了，虽然打开了，表示存活，也开了下摄像头测试了一下没问题，但是还是会炸。没办法，只能等过年回家找售后了。这学期的话，先学习好吧。这是上天给我的学习的好机会，玩什么游戏！学习！","categories":[],"tags":[{"name":"笔记本","slug":"笔记本","permalink":"http://www.z16388.top/tags/笔记本/"}],"keywords":[]},{"title":"hexo+github博客搭建教程","slug":"hexo-github博客搭建教程","date":"2016-09-13T10:24:56.000Z","updated":"2019-11-16T13:03:32.501Z","comments":true,"path":"2016/09/13/hexo-github博客搭建教程/","link":"","permalink":"http://www.z16388.top/2016/09/13/hexo-github博客搭建教程/","excerpt":"","text":"&emsp;&emsp;之前写了一篇域名绑定的教程，但是只有域名没有东西也不行啊。其实早在前几天就想写这样一篇总结性教程了，但是一直没有抽出时间。我这个博客最初也是在朋友的帮助之下搭建的，这个技术并不难用，在此分享给大家。 &emsp;&emsp;hexo是一个基于node.jsd静态博客框架，然后使用Github Pages来存放我们的博客。 账号注册我们需要以下的账号： &emsp;&emsp;github：用于存放页面，是一个非常流行的开源社区，拥有众多的开源项目。 &emsp;&emsp;多说:用来实现博客的评论和点赞。 &emsp;&emsp;七牛云：用来存放博客中使用的图片。 &emsp;&emsp;阿里云：如果你需要一个域名，可以到阿里云购买。 &emsp;&emsp;CNZZ：如果你需要统计你的博客访问，可以使用CNZZ。除此之外还有百度统计，谷歌统计等。 环境搭建你需要下载以下几种软件： &emsp;&emsp;Node.js:用来生成静态页面，hexo的环境。 &emsp;&emsp;Git Bash:把本地的内容提交到github上的软件。 &emsp;&emsp;Markdown Pad:用来写博客。 &emsp;&emsp;NotePad++:一款比较好的记事本，用来修改配置文件。 &emsp;&emsp;在github创建一个新的项目，命名为： YourUserName.github.io 开始安装&emsp;&emsp;Node.js和Git Bash安装好之后，首先，创建一个文件夹,比如叫blog，用于存放你的博客相关的文件。然后进入文件夹，开始安装hexo。 &emsp;&emsp;右键，git bash here,打开git bash，然后运行安装命令： npm install -g hexo &emsp;&emsp;然后执行初始化命令： hexo init &emsp;&emsp;打开根目录下的_config.yml配置文件，修改最后的信息为：1234567deploy: type: git repo: ssh://git@github.com/Git_uername/Your_git_io_url branch: master &emsp;&emsp;按照备注修改相关的参数，比如博客的名字，你的姓名等等。除此之外，你还可以到hexo的官网的主题页面，去下载你喜欢的主题，放在themes文件夹下。需要修改的参数大部分在主题的配置文件上。当然这一步你以后都可以去做。 &emsp;&emsp;执行命令： npm install hexo-deployer-git –save &emsp;&emsp;配置ssh： 如果是Linux系统或者是Mac，则先需要进入配置文件所在的位置，需要先执行： cd ~/.ssh Windows系统的话，可以直接进行下面的步骤： git config –global user.name “name”git config –global user.email “email”ssh-keygen -t rsa -C “邮件地址@youremail.com” &emsp;&emsp;输入好上面的代码之后，三次回车即可。后面的两次为你提交项目时使用的密码，直接回车可以省略。 &emsp;&emsp;创建完ssh之后，需要到github进行配置。打开文档中的.ssh文件夹下的id_rsa.pub文件，复制所有内容。登陆到你的github，Setting-&gt;SSH and GPG keys-&gt;New SSH Key，将刚刚复制的内容粘贴进去即可。 &emsp;&emsp;执行配置命令： hexo deploy （或者是缩写：hexo d） &emsp;&emsp;至此，博客搭建完成，你可以在浏览器输入http://YourUserName.github.io来访问。每次对博客修改之后，我们都需要先生成(hexo g)，再提交到git(hexo d)。当然，我们可以先进行本地预览，运行本地的服务器(hexo s)，然后用浏览器访问。hexo g和hexo d可以合并成一个指令：hexo d -g &emsp;&emsp;hexo的常用命令和写博客使用的markdown语法请参考： hexo常用命令：http://z16388.top/2016/09/09/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Markdown常用语法：http://z16388.top/2016/09/09/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"}],"keywords":[]},{"title":"Python常用知识","slug":"Python常用知识","date":"2016-09-12T14:04:46.000Z","updated":"2017-04-13T13:25:15.879Z","comments":true,"path":"2016/09/12/Python常用知识/","link":"","permalink":"http://www.z16388.top/2016/09/12/Python常用知识/","excerpt":"","text":"&emsp;&emsp;想要学Python很久了。一是流行，再是强大。现在写一篇博客，整理一下常用的知识点，以备复习。 1.数据类型数据Python可以处理任意大小的整数可以用0xff00的方法表示十六进制整数 浮点数处理的精度也比较高，但是太高精度需要用科学记数法表示 字符串用单引号或双引号括起来转义字符大体同C大量需要转义字符的地方，可以简写成：r’\\\\\\\\\\’Python允许字符串内换行，使用…来表示：123print(str1...str2...str3) 布尔值：true false可使用and or not 运算 Python中的强制类型转换方法如下：12&gt;&gt;&gt;s=input('birth:')&gt;&gt;&gt;birth=int(s) 注意，input()返回的数据类型是str。 运算符/ 除法，结果一定是浮点型// 整除% 求余 2.字符串和字符编码字符串和整数的转换ord()函数，获取字符的整数表示chr()函数，把编码转换成对应的字符可以使用转义字符表示，例如：\\u4e2d会显示代表的汉字”中” 字符串和字节str是字符串类型bytes是字节类型，需要用带b前缀的单引号或双引号表示：x=b’ABC’‘ABC’和b’ABC’占用的内存不同，后者每个字符都只占用一个字节encode()方法可以把str转换成指定的bytes，例如：12&gt;&gt;&gt;'ABC'.encode('ascii')&gt;&gt;&gt;'中文'.encode('utf-8') 把字节转换成字符串需要使用decode()方法：1&gt;&gt;&gt;'ABC'.decode('ascii') len()函数，用于计算str中的字符数和bytes中的字节数（英文字符只占一个字节，中文字符经常占3个字节） 要保证编译的python文件能够正确显示中文，我们除了在编写环境中指定编码类型为utf-8之外，通常还要在开头加上两行：12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 replace()方法，用于取代字符串中某个字符，但是不影响字符串本身：12345&gt;&gt;&gt;a='abc'&gt;&gt;&gt;a.replace('a','A')'Abc'&gt;&gt;&gt;a'abc' 格式化同C的格式化类似1&gt;&gt;&gt; 'Hello, %s' % 'world' %开头的叫做占位字符，常用的占位字符有： %&emsp;&emsp;&emsp;&emsp;整数 %f&emsp;&emsp;&emsp;&emsp;浮点数 %s&emsp;&emsp;&emsp;&emsp;字符串 %x&emsp;&emsp;&emsp;&emsp;十六进制整数 格式化整数和浮点数可以指定是否补0或者确定小数的位数1234&gt;&gt;&gt; '%2d-%02d' % (3, 1)' 3-01'&gt;&gt;&gt; '%.2f' % 3.1415926'3.14' 3.list和tuplelistlist是Python内置的一种数据类型，列表。它是一种有序的集合，可以随时添加和删除其中的元素，声明方式如下：1&gt;&gt;&gt;name=['tom','cat','car'] 可以使用len()函数获取list元素的个数用索引来访问每个元素，索引从0开始：12&gt;&gt;&gt;name[0]tom 可以使用-1做索引，访问最后一个元素，依次类推，可以访问倒数第二，第三个元素：1234&gt;&gt;&gt;name[-1]car&gt;&gt;&gt;name[-2]cat 可以使用append()方法，向list中追加元素到末尾：123&gt;&gt;&gt;name.append('apple')&gt;&gt;&gt;name['tom','cat','car','apple'] 可以使用insert()方法，将元素插入到指定位置，比如下标为1的位置：123&gt;&gt;&gt;name.insert(1,'banana')&gt;&gt;&gt;name['tom','banana','cat','car','apple'] 可以使用pop()方法，删除list末尾的元素：123&gt;&gt;&gt;name.pop()&gt;&gt;&gt;name['tom','banana','cat','car'] 可以使用pop(i)方法，删除指定位置的元素：123&gt;&gt;&gt;name.pop(1)&gt;&gt;&gt;name['tom','cat','car'] 可以使用直接赋值的方法将某元素替换成别的元素：123&gt;&gt;&gt;name.[2]='apache'&gt;&gt;&gt;name['tom','cat','apache'] list中可以存放不同类型的元素，也可以存放list（可以看做二维数组）如果list中没有元素，就是一个空list，长度为0。 tupletuple叫做元组，一旦初始化就不能修改，可以使用索引来访问每个元素，但是不能赋值成另外的元素。因为它无法被修改，所以更加安全。 tuple的定义方法：1234567891011&gt;&gt;&gt;t=(1,2)&gt;&gt;&gt;t(1,2)&gt;&gt;&gt;t=()&gt;&gt;&gt;t()&gt;&gt;&gt;t=(1,)&gt;&gt;&gt;t(1,) 不能使用t=(1)的方法来定义只有一个元素的tuple，这会让python认为它是个括号，而将t认为是一个整形变量。 4.dict和setdictdict即C++中的map，全称是dictionary，具有极快的查找速度。它的元素有两种，一种叫做key，另一种叫做value。前者是查询的参数，后者则是它所对应的值。dict的声明方法如下：123&gt;&gt;&gt;d=&#123;'tom':90,'cat':80,'apache':70&#125;&gt;&gt;&gt;d['tom']90 当然，我们在“放入”的时候也很方便：123&gt;&gt;&gt;d['apache']=60&gt;&gt;&gt;d['apache']60 每个key只对应一个值，后面赋的值会将前面的覆盖。 我们可以使用in来判断一个key是否存在：12&gt;&gt;&gt;'toom' in dFalse 可以使用get方法来获取指定的value。如果不存在，可以返回指定的值：1234&gt;&gt;&gt;d.get('tom')90&gt;&gt;&gt;d.get('tomm',-1)-1 dict的特点 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 setset是一组key的集合，但不存储value。因为key不能重复，所以在set中没有重复的元素。要创建一个set需要提供一个list作为输入集合：1234567&gt;&gt;&gt;s=set([1,2,3])&gt;&gt;&gt;s&#123;1,2,3&#125;&gt;&gt;&gt;s=set([1,1,2,2,3,3])&gt;&gt;&gt;s&gt;&#123;1,2,3&#125; 通过add(key)方法可以添加到set中：123&gt;&gt;&gt;s.add(4)&gt;&gt;&gt;s&#123;1,2,3,4&#125; 通过remove(key)方法可以删除元素：123&gt;&gt;&gt;s.remove(4)&gt;&gt;&gt;s&#123;1,2,3&#125; set可以看成无序无重复元素的集合，可以进行交集，并集等操作：123456&gt;&gt;&gt;s1=set([1,2,3])&gt;&gt;&gt;s2=set([2,3,4])&gt;&gt;&gt;s1&amp;s2&#123;2,3&#125;&gt;&gt;&gt;s1|s2&#123;1,2,3,4&#125; 5.判断与循环判断Python也有if和else语句，但是和C比起来又显得非常“任性”。它没有小括号，也没有大括号，具体例子如下：1234age = 20if age &gt;= 18: print(\"your age is %d\",age) print('adult') 根据Python的缩进规则，如果满足if后的条件，则会执行缩进的两个print语句，else也类似：1234567age = 3if age &gt;= 18: print('your age is', age) print('adult')else: print('your age is', age) print('teenager') 注意不要少写了：。 Python中还有elif语句，也就是else if的缩写，所以if语句的完整版就是：12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 循环for…in循环，可以依次将list或tuple中的每个元素迭代出来：123names=['tom','cat','apache']for name in names: print(name) 执行这段代码，就会依次打印出names中的每个元素：123tomcatapache for x in …循环，可以将元素依次代入变量x，然后执行缩进的语句，例如：1234sum=0;for x in [1,2,3,4,5,6,7,8,9,10]: sum+=x;print(sum) 这段代码显示的结果是0-10的累加和 Python提供了range()函数来生成一个整数序列，比如range(5)生成的是从0开始的5个整数：12&gt;&gt;&gt;list(rangr(5))[0,1,2,3,4] 则0累加到100的程序可以写成：1234sum=0for x in range(101): sum+=xprint(sum) Python中也有while循环，用法和C类似：123456sum=0n=0;while n&lt;101: sum+=n n+=1print(sum)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.z16388.top/tags/Python/"}],"keywords":[]},{"title":"在博客中插入网易云音乐歌单","slug":"在博客中插入网易云音乐歌单","date":"2016-09-11T03:37:44.000Z","updated":"2017-04-13T13:25:15.956Z","comments":true,"path":"2016/09/11/在博客中插入网易云音乐歌单/","link":"","permalink":"http://www.z16388.top/2016/09/11/在博客中插入网易云音乐歌单/","excerpt":"","text":"&emsp;&emsp;因为版权的原因，网易云音乐已经禁止了歌单的“生成外链播放器”的功能，只能单首歌曲的进行。之前还有查看代码的方法，现在连生成外链播放器的代码都找不到了。但是，方法还是有的。 &emsp;&emsp;首先我们找到以前的代码，以我的歌单为例：1234&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=240 height=100 src=&quot;http://music.163.com/outchain/player?type=0&amp;id=462197233&amp;auto=0&amp;height=430&quot;&gt;&lt;/iframe&gt; &emsp;&emsp;我们来解释一下里面几个比较有用的几个参数： &emsp;&emsp;1.第二行里面的 width=240 height=100 是用来控制播放器的大小的。但是要注意的是，播放器左侧有图片，如果要完全显示的话，宽度一定要长于270&emsp;&emsp;2.第三行有两个比较有用的参数，一个是id 一个是auto。id改成你歌单的ID，可以在网页端进入你的歌单，在地址栏里查看；auto是自动播放属性，0是关闭，非0即开启。后面的height没有任何意义。 &emsp;&emsp;另外歌单的歌曲顺序由加入歌单的顺序决定，这点很麻烦，在歌曲时一定要注意次序。 &emsp;&emsp;令人遗憾的是，网易云音乐的歌单插入毕竟是已经禁止了的功能，有些时候会出现资源加载失败的状况。所以说，想要让自己的博客唱起来，还是只能单个音乐地用。如果想要更好的效果，还是要选用第三方播放器。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"},{"name":"音乐","slug":"音乐","permalink":"http://www.z16388.top/tags/音乐/"}],"keywords":[]},{"title":"【ACM教程】3.2递归","slug":"【ACM教程】3-2递归","date":"2016-09-10T07:12:02.000Z","updated":"2017-04-13T13:25:20.706Z","comments":true,"path":"2016/09/10/【ACM教程】3-2递归/","link":"","permalink":"http://www.z16388.top/2016/09/10/【ACM教程】3-2递归/","excerpt":"","text":"第二节 递归&emsp;&emsp;递归是一个语言中最难理解的内容之一，它是通过自己调用自己的方法，来进行运算的方法。关于递归有一个非常有意思的定义： 递归：参见“递归” &emsp;&emsp;在生活中，我们也会遇到这样的递归例子： 导员：“你给任课老师请假就行了”。任课老师：“去让你导员给你写个假条”。 &emsp;&emsp;其实在以前的学习中，我们也遇到过递归的思想，数学归纳法就是： 1是正整数如果k是正整数，证明k+1也是正整数若①和②满足，则证明序列n是正整数序列 &emsp;&emsp;C语言和C++是支持递归的。但是，在使用递归的时候，大家应该注意跳出递归的条件，不然就会发生上面导员和任课老师模型之间的无限循环问题。C/C++语言中的递归一般是通过函数来实现的： 1234567func(n) &#123; if(xxx) &#123; func(n+1);&#125;else return xxx;&#125; &emsp;&emsp;像我们常用的求最大公约数最小公倍数的方法，和hdu2018的母牛问题，都是递归的经典题目。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【游戏安利】噬神者","slug":"【游戏安利】噬神者","date":"2016-09-10T00:56:37.000Z","updated":"2017-04-13T13:25:20.519Z","comments":true,"path":"2016/09/10/【游戏安利】噬神者/","link":"","permalink":"http://www.z16388.top/2016/09/10/【游戏安利】噬神者/","excerpt":"","text":"&emsp;&emsp;噬神者是我非常喜欢的游戏系列，它由日本万代南梦宫制作发行，初版在psp上，二代之后以及我要安利的狂怒解放和解放重生都是在PS4，PSV，Steam三平台都有的。 &emsp;&emsp;要说玩，那玩的时间可不少，但是让我安利的话，我却不知道怎么说了。于是，我就问我的联机群里的小伙伴们，如果让他们安利，他们会怎么做。 乳摇 大枪 啪啪啪 &emsp;&emsp;群里的月冷dalao是这么说的。 mh式的操作，精美的人设，未来风，武器多且酷炫，各种大触的子弹，alisa &emsp;&emsp;群里的英灵Archer是这么说的。 &emsp;&emsp;嘛~这里顺便说一下，噬神者Steam联机群： &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;533840872 &emsp;&emsp;但是，其实让我来说的话，作为一个动漫风格，剧情很好的共斗游戏，和朋友在一起联机的体验是最好的。当劳累了一天，和朋友们在游戏里用子弹对♂轰时，仿佛一天的压力都没了。 &emsp;&emsp;嘛~总之，我安利一个人也是马马虎虎的。拉他进群，下午就买游戏了。。。 &emsp;&emsp;还是放一个宣传片吧，官方的安利还是更可靠点的呢2333。","categories":[],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://www.z16388.top/tags/游戏/"},{"name":"游戏安利","slug":"游戏安利","permalink":"http://www.z16388.top/tags/游戏安利/"},{"name":"Steam","slug":"Steam","permalink":"http://www.z16388.top/tags/Steam/"},{"name":"心情","slug":"心情","permalink":"http://www.z16388.top/tags/心情/"}],"keywords":[]},{"title":"给Github Pages绑定阿里云域名","slug":"给Github-Pages绑定阿里云域名","date":"2016-09-09T15:54:20.000Z","updated":"2018-01-10T12:45:23.840Z","comments":true,"path":"2016/09/09/给Github-Pages绑定阿里云域名/","link":"","permalink":"http://www.z16388.top/2016/09/09/给Github-Pages绑定阿里云域名/","excerpt":"","text":"&emsp;&emsp;我在阿里云上注册了一个域名，现在想把它和我的Github Pages绑定起来，也就是说我想达到访问这个域名，能够进入我的博客的目的。 第一步&emsp;&emsp;运行cmd，输入 1ping yourusername.github.io &emsp;&emsp;然后我们会看到一个IP地址。 第二步&emsp;&emsp;在你的阿里云域名解析设置中，添加以下两项内容 A&emsp;&emsp;&emsp;&emsp;www&emsp;&emsp;&emsp;&emsp;&emsp; Your IPA&emsp;&emsp;&emsp;&emsp;@&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; Your IP &emsp;&emsp;保存，等待十分钟左右，你就可以使用你的域名来访问你的博客了。 &emsp;&emsp;除此之外，你需要在你的github pages项目的根目录新建一个CNAME文件，用于存放显示给用户的域名。如果你的域名是def.com，你的CNAME存放的域名是blog.def.com，那么用户在浏览器看到的域名将会是blog.def.com。需要注意的是，每一个github pages项目只能绑定一个域名。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"},{"name":"域名","slug":"域名","permalink":"http://www.z16388.top/tags/域名/"}],"keywords":[]},{"title":"【ACM教程】2.XJAVA大数","slug":"【ACM教程】2-4JAVA大数","date":"2016-09-09T14:35:24.000Z","updated":"2017-04-13T13:25:20.756Z","comments":true,"path":"2016/09/09/【ACM教程】2-4JAVA大数/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】2-4JAVA大数/","excerpt":"","text":"第X节 JAVA大数&emsp;&emsp;由于近些年，大数据的兴起，在ACM比赛中，经常会出现大数的问题。 &emsp;&emsp;大数，字面意思很简单。而在编程中，特指超过32位二进制的数。虽然低于64位的数据计算可以使用long long 的数据类型，但是如果出现乘法，则难免会越界。这样的问题，我们称为大数问题。 &emsp;&emsp;虽然C++给我们提供了大数，但是使用起来不是很方便。特别是在处理乘法和除法的时候，代码可能会达到上百行。JAVA的大数类则比较实用，在ACM竞赛中，我们大多使用JAVA语言进行大数题目的计算。下面是JAVA大数加法的程序:12345678910111213import java.math.BigInteger; import java.util.Scanner; public class Main &#123; public static void main (String args[]) &#123; Scanner in = new Scanner(System.in); while(in.hasNextBigInteger()) &#123; BigInteger a = in.nextBigInteger(); BigInteger b = in.nextBigInteger(); System.out.println(b.add(a)); &#125; in.close(); &#125; &#125; &emsp;&emsp;需要特别注意的是，普通的四则运算符号在大数加减时不能使用，我们要使用类似于C++中运算符重载的方法来进行计算。常用的几种运算如下： add( ) 加法subtract( ) 减法multiply( ) 乘法divide( ) 除法remainder ( ) 求余abs( ) 绝对值pow( int n ) n次幂 &emsp;&emsp;不仅如此，大数只能和大数进行运算。在需要使用常数的时候，我们需要用下面这种方法进行定义：1BigInteger a = new BigInteger ( “XXXXXXX” ); 练习： &emsp;&emsp;&emsp;&emsp;Ti6奖金池","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】2.3排序、查找与初始化","slug":"【ACM教程】2-3(旧)排序、查找与初始化","date":"2016-09-09T14:26:37.000Z","updated":"2017-04-13T13:25:20.772Z","comments":true,"path":"2016/09/09/【ACM教程】2-3(旧)排序、查找与初始化/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】2-3(旧)排序、查找与初始化/","excerpt":"","text":"第三节 排序、查找与初始化&emsp;&emsp;STL指的是C++的标准模板库。使用STL能给我们带来很大的便利，但是它比较复杂，我们只选取一些算法竞赛中常用的STL进行一系列的讲解。首先，我们先学习第一部分。排序和初始化。 排序与查找&emsp;&emsp;排序与查找是两个对于数据常用的操作。C++给我们提供了sort() 和lower_bound() 两个函数来实现这两个功能，这两个函数都在algorithm头文件中。首先，介绍一下两个函数的参数。 sort（起始地址，终点地址，比较方法）；lower_bound（起始地址，终点地址，查找元素）； &emsp;&emsp;sort() 函数可以对任意对象进行排序，不一定是默认的数据类型。但是，在使用其他类型的时候，我们要首先要对该类型进行“大于”或者“小于”运算进行定义。排序的对象可以存放在数组里，也可以存放在vector中（动态数组，以后会进行讲解）。但是，在使用的细节上有所不同。前者是：sort(a,a+n) 后者是：sort(v.begin(),v.end())。 Lower_bound() &emsp;&emsp;这个函数的作用是查找“大于或等于x的第一个位置”。 &emsp;&emsp;stable_sort()函数和sort()函数类似，与后者的区别是，排序之后，不改变相同值元素的相对位置。我们称stable_sort()为稳定排序，举个例子，a1,a2,a3,a4,a5是一数组，其中a2=a4，那么经过排序之后是：a1,a2,a4,a3,a5，我们能看到，排序前后a2总是在a4的前面。在数组的排序中，可能效果不太明显，但是如果是对结构体的排序就会有明显的区别。 &emsp;&emsp;使用这两个函数，将会给我们带来很大的便利。不仅缩短了代码的长度，而且可能要比我们所了解的各种排序查找方法更加优秀，无论是时间复杂度或者空间复杂度。 &emsp;&emsp;请练习下面的题目： &emsp;&emsp;&emsp;&emsp;好汉杯积分问题 &emsp;&emsp;请练习下面的题目： &emsp;&emsp;&emsp;&emsp;我要送人头！","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】2.3竞赛C++入门","slug":"【ACM教程】2-3竞赛C++入门","date":"2016-09-09T14:11:43.000Z","updated":"2017-04-13T13:25:20.765Z","comments":true,"path":"2016/09/09/【ACM教程】2-3竞赛C++入门/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】2-3竞赛C++入门/","excerpt":"","text":"第三节 竞赛C++入门&emsp;&emsp;本系列文章是以读者学习过C语言为背景的。C语言是一门很好的语言，但是在算法竞赛中却不是十分流行。举个例子：在2013年的ACM/ICPC世界总决赛中，有1347份代码使用C++提交，323份使用Java提交，但唯独C语言没有人使用。 &emsp;&emsp;在我们参加各类软件竞赛时，C语言的程序代码其实都可以直接作为C++程序来进行编译。C++博大精深，但是也会有很多让人诟病的地方。我们在比赛中，重点只需要利用它其中很少的一部分特性。 C++框架&emsp;&emsp;虽然C语言的程序可以直接在C++中运行，但是并不是以C++的写法，下面简单地区别一下两种语言。 C:a+b。12345678#include&lt;stdio.h&gt; int main() &#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b)==2) printf(\"%d\\n\",a+b); return 0; &#125; C++:返回两个个实数中，较小的一个的绝对值。123456789101112#include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; int main() &#123; double a,b; while(cin&gt;&gt;a&gt;&gt;b) &#123; cout&lt;&lt;fabs(min(a,b))&lt;&lt;endl; &#125; return 0; &#125; &emsp;&emsp;首先，和之前我们写的C程序进行比较，在我们使用数学相关的函数时，调用的头文件变成了cmath。实际上math.h依然存在，但是在C++中我们比较推荐使用cmath。类似地，stdio.h变成了cstdio，string.h变成了cstring。 &emsp;&emsp;其次，在我们新增的两个头文件中：iostream提供了输入输出流，而algorithm则提供了一些常用的算法，就比如我们刚刚使用的min()函数。但是，在比赛中建议大家手动编写max和min函数，以免发生意外。 &emsp;&emsp;cin&gt;&gt;a 和 cout&lt;&lt;a 就是我们前面提到的输入输出流，他们就相当于C语言中的scanf和printf函数。相比于后面两个函数，我们在使用输入输出流时省略了%d、%s等占位符。一个是简化了这些繁琐的东西，再一个可以轻易地避免long long 型的输入输出占位符不统一的问题（%i64d、%lld）。但是，C++流是不完美的，其最致命的缺点就是运行太慢，以致于有些题目会在后面明确注明：本题的输入量很大，请不要使用C++的流输入。另外，不要将cout和printf混合使用，会造成输出的数据混乱。 &emsp;&emsp;cin&gt;&gt;a我们还看到了有这一行：using namespace std; 。在C++中，有个概念叫做名称空间。把函数放在名称空间里，我们可以通过这样的方法进行调用： 空间名:函数名(); &emsp;&emsp;cin&gt;&gt;a而我们头文件iostream和algorithm就是放在std 名空间中的。如果我们在写程序的时候，不把std里的名字导入默认空间，那么我们在使用输入输出流的时候就要这么写了： std:cin&gt;&gt;a;std:cout&lt;&lt;a; &emsp;&emsp;C++和C语言的数据类型非常相近，最显著的区别就是多了一个bool类型（ture/false）。 引用&emsp;&emsp;如果想要在一个函数中去操作主函数中的数值，我们除了可以利用指针之外，C++还给我们提供了引用。相比于指针，引用的功能上比指针要弱，但是减少了出错的可能，还能提高代码的可读性。下面我们来看一个例子:1234567891011121314#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; void swapp(int&amp; a,int&amp; b) &#123; int t=a;a=b;b=t; &#125; int main() &#123; int a=3,b=4; swapp(a,b); cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;endl; return 0; &#125; &emsp;&emsp;在上面的程序中，我们使用了饮用。在参数的前面加上“&amp;”符号，就表示这个传参是按照传引用的方式进行传递，而不是C语言中的按值传递。这样，在上面的函数内改变参数的值，也会修改到函数的实参。 模板&emsp;&emsp;在之前，我们可能接触过一些C++给我们提供的函数，比如sort()。默认的函数功能是提供从小到大的排序。如果我们需要从大到小排序，难道需要我们重写sort()吗。 &emsp;&emsp;C++给我们提供了模板功能，可以对一些函数进行修改。 &emsp;&emsp;sort()函数的参数实际上有三个：sort(begin,end,[compare]);第三个是非必填项，意思是排序方式。我们只需要在使用sort函数之前，对它的排序方式进行规定，就可以实现从大到小的排序了。下面是代码：1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;bool compare(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int a[5]; for(int i=0;i&lt;5;i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+5,compare); for(int i=0;i&lt;5;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】2.1常用输入输出格式","slug":"【ACM教程】2-1常用输入输出格式","date":"2016-09-09T12:34:22.000Z","updated":"2017-04-13T13:25:20.793Z","comments":true,"path":"2016/09/09/【ACM教程】2-1常用输入输出格式/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】2-1常用输入输出格式/","excerpt":"","text":"第一节 常用输入输出格式&emsp;&emsp;写程序，大家都会写。但是在比赛里面怎样写程序，应该按照怎样的格式去写程序，都是有严格的要求的。下面简单介绍一下各种比赛中，常见的输入输出格式。 OI&emsp;&emsp;OI比赛中，输入输出均需要使用文件操作。常见的格式如下：123456789101112#include&lt;stdio.h&gt; int main() &#123; FILE *fin,*fout; fin=fopen(\"fin.txt\",\"r\"); fout=fopen(\"fout.txt\",\"w\"); int a,b,sum; fscanf(fin,\"%d %d\",&amp;a,&amp;b); sum=a+b; fprintf(fout,\"%d\\n\",sum); return 0; &#125; 蓝桥杯&emsp;&emsp;蓝桥杯比赛对格式的要求不是很高，养成良好的代码书写习惯即可。123456#include&lt;stdio.h&gt; int main() &#123; printf(\"Hello world\\n\"); return 0; &#125; ACM&emsp;&emsp;ACM比赛中，对输入输出的要求多种多样。因为题目都是英语，所以大家应当仔细审题，控制好输入和输出。其中，一下几种情况会经常出现。 &emsp;&emsp;第一种，输入一个或一组数据。方法同蓝桥杯比赛。123456#include&lt;stdio.h&gt; int main() &#123; printf(\"Hello world\\n\"); return 0; &#125; &emsp;&emsp;第二种，输入多组数据。题目中，常见的描述方式为：The input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line.1234567891011#include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; int main() &#123; int i,j; while(scanf(\"%d%d\",&amp;i,&amp;j)!=EOF) &#123; printf(\"%d\\n\",i+j); &#125; return 0; &#125; &emsp;&emsp;这里我们的输入语句是写在while循环语句里面的，后面有一个!=EOF。EOF是文件结尾的标志，也就是说循环在输入结束时停止。这种输入方法在ACM中最为常见，大家应当熟练掌握。 &emsp;&emsp;第三种，输入多组数据，直到遇到0，0这组数据时，停止输入。常见描述方式为：Input contains multiple test cases. Each test case contains a pair of integers a and b, one pair of integers per line. A test case containing 0 0 terminates the input and this test case is not to be processed.1234567891011#include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; int main() &#123; int i,j; while(scanf(\"%d%d\",&amp;i,&amp;j)&amp;&amp;(i||j)) &#123; printf(\"%d\\n\",i+j); &#125; return 0; &#125; &emsp;&emsp;第四种，输入一个数字n，接下来输入n组测试数据。常见的描述方式为：Input contains an integer N in the first line, and then N lines follow.1234567891011121314#include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; int main() &#123; int n; scanf(\"%d\",&amp;n); while(n--) &#123; int i,j; scanf(\"%d%d\",&amp;i,&amp;j); printf(\"%d\\n\",i+j); &#125; return 0; &#125; &emsp;&emsp;另外，在输入字符串时，我们可以使用gets()函数12char buf [ 20 ] ; gets ( buf ) ; 练习题目：hdu1089~hdu1096题","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】1.3常用编译环境与OJ系统","slug":"【ACM教程】1-3算法竞赛介绍","date":"2016-09-09T11:35:32.000Z","updated":"2017-04-13T13:25:15.888Z","comments":true,"path":"2016/09/09/【ACM教程】1-3算法竞赛介绍/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】1-3算法竞赛介绍/","excerpt":"","text":"第三节 常用编译环境与OJ系统编译环境&emsp;&emsp;编译环境就是我们编写代码时所使用的软件。在参加算法类竞赛时，我们通常使用以下三种软件。 DEV-C++ &emsp;&emsp;Dev-C++为OI和蓝桥杯C/C++组比赛中的指定编译环境。 Code::Blocks &emsp;&emsp;Code::Blocks为ACM比赛中指定的C/C++编译环境。 Eclipse &emsp;&emsp;Eclipse为蓝桥杯java组和ACM中指定的java编译环境。 常用OJ系统HDU: http://acm.hdu.edu.cn/PKU: http://poj.org/Clang: http://www.clang.cc/Codevs: http://www.codevs.cn/51nod: http://www.51nod.com/","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】1.2算法竞赛介绍","slug":"【ACM教程】1-2算法竞赛介绍","date":"2016-09-09T11:21:37.000Z","updated":"2017-04-13T13:25:20.799Z","comments":true,"path":"2016/09/09/【ACM教程】1-2算法竞赛介绍/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】1-2算法竞赛介绍/","excerpt":"","text":"第二节 算法竞赛介绍&emsp;&emsp;本教程是针对参加各种算法竞赛的同学们编写的。这一节主要介绍几种比较有名的算法竞赛。 OI(Olympiad in Informatics，信息学奥林匹克竞赛)&emsp;&emsp;OI是Olympiad in Informatics的简称，1987年，保加利亚的Sendov教授在联合国教科文组织第24届全体会议上，倡议举行国际信息学奥林匹克，定名为International Olympiad in Informatics，简称IOI。OI是面向中学生的一年一度的信息学科竞赛。第一届国际信息学奥林匹克竞赛于1989年在保加利亚的布拉维茨举行。 &emsp;&emsp;考的内容主要是计算机编程。OI的比赛有NOIP，NOI，IOI等。NOIP是最初级别的比赛，分初赛和复赛，初赛为笔试，选出成绩优秀的选手参加复赛；复赛是上机编程，选出各个省市的一等奖，参加省级OI（NOIP是参加NOI的必备条件）。NOI是通过NOIP或各省省选选出的优秀选手组成省队参加的全国比赛。NOI选出全国一二三等奖，并选出国家集训队。 &emsp;&emsp;中国队参加8届大赛，届届名列前茅。中国队共计派出选手31人次，全部获奖，累计金牌17块、银牌6块，铜牌8块。在这种世界级别的智能大赛中，中国的娃娃们给参赛国的领队和选手留下了深刻的印象，盛赞“中国队是整体实力最强的队”。在波IOI’92 的发奖大会上，组委会为金牌得主设置了6台高档微计算机， 中国队捧回了3台。在IOI’94（瑞典），黄天明同学编的程序比组委会的标准答案运行速度快了20倍，组委会非常欣赏，派专人到中国队驻地索取原程序。1995年中国队首次派女选手参加IOI， 结果两位女选手杨域和林凌荣登金牌领奖台，填补了国际信息学赛事上女选手从未拿过金牌的空白，引起轰动。IOI’96（匈牙利）中国队经努力拼搏，4名选手夺得4枚金牌，实现了全“金”的突破，创造了新的纪录。近几年来，中国选手在国际信息学奥林匹克竞赛中表现优异，已连续三年在IOI中全部摘得金牌。 ACM-ICPCACM-Association for Computing Machinery，国际计算机学会。ICPC-International Collegiate Programming Contest，国际大学生程序设计竞赛。 &emsp;&emsp;ACM国际大学生程序设计竞赛是由国际计算机学会（ACM）主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过近40年的发展，ACM国际大学生程序设计竞赛已经发展成为最具影响力的大学生计算机竞赛。赛事目前由IBM公司赞助。 &emsp;&emsp;赛事由各大洲区域预赛和全球总决赛两个阶段组成。各预赛区第一名自动获得参加全球总决赛的资格。决赛安排在每年的3-4月举行，而区域预赛一般安排在上一年的9-12月举行。一个大学可以有多支队伍参加区域预赛，但只能有一支队伍参加全球总决赛 &emsp;&emsp;竞赛进行5个小时，一般有11—13道试题，由同队的三名选手使用同一台计算机协作完成。当解决了一道试题之后，将其提交给评委，由评委判断其是否正确。若提交的程序运行不正确，则该程序将被退回给参赛队，参赛队可以进行修改后再一次提交该问题。竞赛结束后，参赛各队以解出问题的多少进行排名，若解出问题数相同，按照总用时的长短排名。总用时为每个解决了的问题所用时间之和。一个解决了的问题所用的时间是竞赛开始到提交被接受的时间加上该问题的罚时(每次提交通不过，罚时20分钟)。没有解决的问题不记时。美国英语为竞赛的工作语言。竞赛的所有书面材料(包括试题)将用美国英语写出，区域竞赛中可以使用其它语言。总决赛可以使用的程序设计语言包括pascal，c，c++及java，也可以使用其它语言。具体的操作系统及语言版本各年有所不同。 竞赛流程：123456参赛队伍最多由三名参赛队员组成。 竞赛中一般命题10题左右，试题描述为英文，比赛时间为5个小时，前四个小时可以看到实时排名，最后一小时封榜，无法看到排名。竞赛可以使用的语言：C++、C、Java和Pascal。但final赛只有C/C++;重点考察选手的算法和程序设计能力，不考察任何Windows编程知识；选手可携带任何非电子类资料，包括书籍和打印出来的程序等，部分赛区会对携带的资料进行限制；评委负责将结果（正确或出错的类型）通过网络尽快返回给选手，除此之外不提供任何额外帮助； 返回结果：1234567Accepted. ---通过！(AC)Wrong Answer. ---答案错。(WA)Run Time Error. ---程序运行出错，意外终止等。(RTE)Time Limit Exceeded. ---超时。程序没在规定时间内出答案。(TLE)Presentation Error. ---格式错。程序没按规定的格式输出答案。(PE)Memory Limit Exceeded. ---超内存。程序没在规定空间内出答案。(MLE)Compile Error. ---编译错。程序编译不过。(CE) ACM试题的特点：1234严格的输入输出格式，有一点儿偏差都不能够AC；对算法的高效有着极致的追求，即使算法正确，但是如果效率不高，也不能AC；测试数据庞大，即使算法是正确的，不能应对极端的测试数据的话，也不能AC；强调解决实际问题的能力，试题大多会有大篇幅的描述，需要有一定的读题能力，分析能力，当然，英语也很重要。 蓝桥杯&emsp;&emsp;蓝桥杯由工业和信息化部人才交流中心举办，全称为：“全国软件专业人才设计与创业大赛”。包含个人和团队两个比赛项目。个人竞赛分为：C/C++本科A组，C/C++本科B组，C/C++高职高专组，java本科A组， java本科B组，java高职高专组，嵌入式设计与开发大学组，嵌入式设计与开发研究生组，单片机设计与开发本科组，单片机设计与开发高职高专组，电子设计与开发本科组，电子设计与开发高职高专组共12个组别。每位选手只能参加其中一个组别的竞赛。 &emsp;&emsp;蓝桥杯算法类比赛是一个比较新的比赛，到2016年共举办了七次，在国内外的知名度还不是很高。但是获得省赛一等奖以上可以获得IBM颁发的“高级软件工程师认证”和工信部颁发的“电子信息从业人员高级证书”。 参考资料： IOI官方网站： ACM-ICPC：https://icpc.baylor.edu/ 蓝桥杯官方网站：http://www.lanqiao.org/","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】1.1算法概述","slug":"【ACM教程】1-1算法概述","date":"2016-09-09T11:00:24.000Z","updated":"2017-04-13T13:25:20.806Z","comments":true,"path":"2016/09/09/【ACM教程】1-1算法概述/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】1-1算法概述/","excerpt":"","text":"第一节 算法概述算法是什么？&emsp;&emsp;算法是软件工程非常重要的基础科目。简单来说，算法就是解决特定问题的方法和步骤。为了解决现实生活中的各种问题，我们就把现实问题对应成数学问题，然后设计公式，编写程序，让计算机编译，运行得到答案——这时候运用的方法就是算法。 &emsp;&emsp;尽管这里运用了“公式”这个词来形容算法，然而算法并不是大家印象中死板的数学公式。因为计算机能够执行复杂的计算，所以公式可以设计成好几行，甚至几百行，用到很多数学理论。因此，就算学习过算法的人，也不一定会设计算法。因为数学、程序上面的东西都比较复杂。想要把现实中的问题对应到数学问题，那就更加复杂了。 &emsp;&emsp;通常，算法具有由三部分组成：输入、输出、计算过程。说到这里，大家可能会联想到函数。 &emsp;&emsp;输入、输出是一个或一组数据，实际上是将这些数字放在数据结构中比如数组、链表。输入的来源，通常是硬盘中存储的数据，或者是由键盘输入的数字；输出的去处可能是硬盘中的文件或是由硬盘中的数据转换之后以其他的形式呈现，例如显示器。 &emsp;&emsp;计算过程是一连串处理数字的指令。指令有两种类型，一种是运算，例如数学运算的加减乘除、逻辑预算的与或非、比较大小、位运算等等；另一种则是读写，例如读取某处的数字，存储数字至某处。 &emsp;&emsp;在算法之前的定义中，算法的计算步骤必须是有限的。用程序的语言说：算法不能无限轮回。之所以规定算法的步骤有限是为了方便统计计算的步数。但是事实上，很多的计算机程序都是开启之后保持运行的状态，直到遇到死机或者关机。例如用于网络传输的算法。因此，实际上，算法是可以有无限步的。 计算机只会算数字&emsp;&emsp;计算机就是一台用于计算的机器，它只会计算、判断以及存储数据，但是能够做得又快又准。而程序，是一连串计算、判断、存储数据的过程。 &emsp;&emsp;计算机只会处理二进制数字，计算机中的每一个文字、每一种颜色、每一种声音，都有它所对应的数字。例，我们规定：用1代表数字“一”，用2代表汉字“乙”，用3代表汉字“人”…一个数字对应一个汉子。按照这样的规定，计算机中所有的汉字都变成了数字。同理，呈现在电脑屏幕上的不同颜色、图片、影像等，都可以转化成数字。一切事物在计算机里都是数字。 &emsp;&emsp;如果我们想要利用计算机解决实际问题，通常要考虑两个方面：一、计算机应该使用哪些设备?计算机如何操作这些设备？二、显示问题如何对应到数学问题?如何设计算法？当然，编写程序，计算数字，这就是程序设计师的工作。 数学和程序这么复杂，为什么要用计算机解决现实问题？&emsp;&emsp;计算机解决问题的速度很快，一秒可以进行几千万次以上的计算。即使是很大的数据量，计算机也能够轻松解决。打开计算机中的一份文件，用鼠标滑动页面。眼镜还没来得及眨一下，正确的内容就已经显示在显示器上了。事实上，在我们滑动页面的时候，计算机已经完成了很多次的计算，然后把正确的内容展示在显示器上了。 &emsp;&emsp;人们想要用计算机来解决问题，就是因为它速度快，正确率高，而且计算机会按照人们设计的程序来进行运算。程序设计师只要设计好一个好的程序，接下来的工作就可以让计算机代劳了。计算机的运算速度比人要更快更好，计算机做得到人类做不到是事。相比于算法的复杂，程序和计算机的组合能够给人们带来更多的便利。现在，计算机应用在人们生产生活的各个方面，程序设计师们设计的程序也在世界各地发光发热。 如何表示一个算法&emsp;&emsp;有人用伪代码来表示一个算法。如要实际计算机程序，伪代码是比较方便使用的。下面是一段伪代码：1234567GREATEST_COMMON_DIVISOR(a, b) while a ≠ b do if a &gt; b then a ← a - b else b ← b - a return a &emsp;&emsp;当然，你也可以使用流程图来表示一个算法。下面是一个流程图： 如何实现一个算法&emsp;&emsp;实现的意思就是实际操作，实际运行。对于程序设计师来说，就是把算法写成程序，比如C/C++程序或者是java程序，然后在计算机上去执行。这个是我们接下来我们主要研究的东西。 衡量算法优良的标准&emsp;&emsp;要评价一个算法的好坏，最基本的两个指标就是时间复杂度和空间复杂度。用直观的感觉来说，就是程序的执行时间和内存使用量。但是由于不同的计算机执行时间会有所不同，而且这两项指标同时会受到程序语言的类型、程序设计的技巧的影响。因此，执行时间和内存使用量并不是一个稳定的评判标准。1234for ( i = 0 ; i &lt; length(A) ; i ++ ) for (j = 0 ; j &lt; length(A)-I ; j ++ ) if A [ j ] &lt; A [ j+1] swap A [ j ] and A [ j+1 ] &emsp;&emsp;上面的程序是一个简单的数组排序问题，我们经常采用统计计算步骤的方法来去衡量一个算法的时间复杂度。1234567 Code stepfor ( i = 0 ; i &lt; length(A) ; i ++ ) n for (j = 0 ; j &lt; length(A)-I ; j ++ ) n ( n - 1) / 2 if A [ j ] &lt; A [ j+1] &#123; n ( n - 1) / 2 Temp = A [ j ] ; n ( n - 1) / 2 A [ j ] = A [ j + 1 ] ; n ( n - 1) / 2 A [ j + 1 ] = temp ; n ( n - 1) / 2 Sum = n + 5n ( n – 1 ) / 2= n + 2.5n2 – 2.5n= 2.5n2 – 1.5n= O ( n2 ) &emsp;&emsp;像上面那个算法，我们称它的时间复杂度为O ( n2 )。这是因为在上式中，我们进行的并不是精确的步骤计算。针对不同的数据，系数变动会很大。因此，我们只取代数式的最高次方。最高次方越大，时间复杂度越高，算法的速度也就越慢。并且，我们规定n必须足够大。尽管这样的估算并不是非常精准，但是还是可以对一些常见的算法进行简易的分类，粗略地比较快慢。 &emsp;&emsp;下面是几种常见算法的时间复杂度和空间复杂度。（空间复杂度的计算和时间复杂度类似。）1234567type time spacebubble sort ( 冒泡排序 ) O ( n2 ) O ( n ) insertion sort ( 插入排序 ) O ( n2 ) O ( n ) merge sort ( 归并排序 ) O ( n log ( n ) ) O ( n ) quicksort ( 快速排序 ) O ( n2 ) O ( n ) heapsort ( 堆排序 ) O ( n log ( n ) ) O ( n ) counting sort ( 计数排序 ) O ( n + r ) O ( n + r ) 学习编程语言&emsp;&emsp;学习编程语言，有两个层次：一是语言本身的语法，二是把算法转换成代码的能力。算法固然重要，然而更重要的是用一种语言来把它表述出来，这样它才能发挥作用。而使用编程语言将算法描述出来这个过程，正是我们今后学习的重点。关于各种编程语言，本教程不作详细介绍，因为其他的书籍已经介绍得足够详细了。接下来对算法的描述，以C/C++语言为主，部分辅以java语言。 参考书目： 1.《算法竞赛入门经典（第二版）》 （刘汝佳编著，2009年，清华大学出版社）2.《数据结构实用教程（C语言版）（第二版）》（2009年，清华大学出版社）","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"ACM教程","slug":"ACM教程","date":"2016-09-09T10:53:22.000Z","updated":"2018-03-13T07:03:43.886Z","comments":true,"path":"2016/09/09/ACM教程/","link":"","permalink":"http://www.z16388.top/2016/09/09/ACM教程/","excerpt":"","text":"ACM教程前言&emsp;&emsp;从今天起，我将会在我的博客同步更新我的ACM教程系列。虽说是教程，但是两年ACM经历的我还是有许多要学的东西，在这里写下自己的学习经历，也算是共同进步吧。 目录第一章 简介第1节 算法概述第2节 算法竞赛介绍第3节 常用编译环境与OJ系统大连交通大学 软件竞赛协会介绍第二章 走进算法竞赛第1节 常用输入输出格式第2节 从排序开始第3节 竞赛C++入门第4节 编程细节第5节 数学简单问题第6节 文件操作第X节 JAVA大数第三章 算法初步第1节 枚举第2节 递归第3节 二分查找第4节 数据结构基础（1）栈、队列和链表第5节 常用C++容器vector,set和map第6节 数据结构基础（2）树、二叉树和图第7节 排序（一）第8节 从全排列到深度优先搜索算法第四章 动态规划第1节 动态规划简介第2节 动态规划初体验第3节 下降/非降子序列问题第五章 图论第1节 图论的基本概念第2节 图的存储方式第3节 单源最短路径Dijkstra算法附录HDU答案：http://www.z16388.top/answer/ ACM常用模板：http://www.z16388.top/2016/10/30/ACM常用模版/ 第六届蓝桥杯C/C++省赛B组题目详解：http://www.z16388.top/2017/03/21/lanqiao6/ 第七届蓝桥杯C/C++省赛B组题目详解:http://www.z16388.top/2017/02/21/lanqiao7/","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2016-09-09T10:38:06.000Z","updated":"2017-04-13T13:25:15.863Z","comments":true,"path":"2016/09/09/hexo常用命令/","link":"","permalink":"http://www.z16388.top/2016/09/09/hexo常用命令/","excerpt":"","text":"hexo常用命令笔记 1.hexo相关123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 2.常用的缩写12345hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 持续更新","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"}],"keywords":[]},{"title":"Markdown常用语法","slug":"Markdown常用语法","date":"2016-09-09T09:35:47.000Z","updated":"2017-04-13T13:25:15.875Z","comments":true,"path":"2016/09/09/Markdown常用语法/","link":"","permalink":"http://www.z16388.top/2016/09/09/Markdown常用语法/","excerpt":"","text":"Markdown常用语法 一.标题&emsp;&emsp;使用#来表示标题d大小。123# 一级标题## 二级标题### 三级标题 二.列表&emsp;&emsp;用-、+或者*来使用无序列表，数字后加点使用无序列表。 无序列表1234无序列表- 1- 2- 3 1 2 3 有序列表12345有序列表1. abc2. def3. ghi abc def ghi 嵌套列表12345678嵌套列表- 嵌套列表1 + 嵌套列表2 + 嵌套列表3 - 嵌套列表4 * 嵌套列表5- 嵌套列表6 嵌套列表1 嵌套列表2 嵌套列表3 嵌套列表4 嵌套列表5 嵌套列表6 三.引用&emsp;&emsp;使用大于号&gt;来表示引用。1&gt;这里是引用 这里是引用 四.图片与链接123456![图片名](图片链接)[链接名](链接地址)&lt;链接&gt;图片：![百毒](https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png)链接：[bilibili](http://www.bilibili.com/)&lt;http://www.bilibili.com/&gt; 五.字体&emsp;&emsp;支持html字体。1234567**粗体** *斜体* &lt;del&gt;删除线&lt;/del&gt;&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt; 六.分割线1--- 七.代码把代码用三个`符号括起来，可以选择所使用的语言。123456#include&lt;stdio.h&gt;int main()&#123; printf(\"Hello world\\n\"); return 0;&#125; 八.注释1&lt;!-- 注释 --&gt; 九.转义字符及空格&emsp;&emsp;同html。12345678910111213141516171819202122232425262728\\\\ 反斜杠\\` 反引号\\* 星号\\_ 下划线\\&#123;\\&#125; 大括号\\[\\] 中括号\\(\\) 小括号\\# 井号\\+ 加号\\- 减号\\. 英文句号\\! 感叹号半方大的空白&amp;ensp;或&amp;#8194;看，飞碟全方大的空白&amp;emsp;或&amp;#8195;看，飞碟不断行的空白格&amp;nbsp;或&amp;#160;看，飞碟&amp;emsp;&amp;emsp;段落从此开始。 \\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号 半方大的空白&ensp;或&#8194;看，飞碟全方大的空白&emsp;或&#8195;看，飞碟不断行的空白格&nbsp;或&#160;看，飞碟&emsp;&emsp;段落从此开始。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://www.z16388.top/tags/markdown/"}],"keywords":[]}]}