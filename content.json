{"meta":{"title":"崎径 其镜","subtitle":"求学道路上的行车记录仪","description":null,"author":"Anqi Zhao","url":"http://www.z16388.top"},"pages":[{"title":"","date":"2017-04-13T13:25:15.986Z","updated":"2017-04-13T13:25:15.986Z","comments":true,"path":"README.html","permalink":"http://www.z16388.top/README.html","excerpt":"","text":"blogsource"},{"title":"","date":"2017-04-13T13:25:20.983Z","updated":"2017-04-13T13:25:20.983Z","comments":true,"path":"7d0a5d56bfd911bf552ed1753dc23c1f.html","permalink":"http://www.z16388.top/7d0a5d56bfd911bf552ed1753dc23c1f.html","excerpt":"","text":"7d0a5d56bfd911bf552ed1753dc23c1f"},{"title":"","date":"2017-04-13T13:25:20.476Z","updated":"2017-04-13T13:25:20.476Z","comments":true,"path":"baidu_verify_bJsKt9rMJw.html","permalink":"http://www.z16388.top/baidu_verify_bJsKt9rMJw.html","excerpt":"","text":"bJsKt9rMJw"},{"title":"下载资源","date":"2016-09-11T05:56:07.000Z","updated":"2017-04-13T13:25:20.469Z","comments":true,"path":"Download/index.html","permalink":"http://www.z16388.top/Download/index.html","excerpt":"","text":"工具锐捷破解版:http://pan.baidu.com/s/1slCLdFn SQSXvpn:http://pan.baidu.com/s/1qX9Pb20 everything:https://pan.baidu.com/s/1gfE1wD9 vegas Pro12.0-64:https://pan.baidu.com/s/1slVHVNB vegas Pro12.0-64汉化补丁：https://pan.baidu.com/s/1dEHDamt matlab 2014b:https://pan.baidu.com/s/1qYo0AG8 Guitar Pro 5.2:https://pan.baidu.com/s/1dF2ukpz Adobe Audition CC:http://pan.baidu.com/s/1dFgF4Hj Adobe Photoshop CC:http://pan.baidu.com/s/1slvkkjz 软件开发ADTx86:https://pan.baidu.com/s/1nuABjxJ Eclipse:http://pan.baidu.com/s/1mio8JxQ Code:Blocks:http://pan.baidu.com/s/1mihhkvu Dev-C++:http://pan.baidu.com/s/1kVoALH9 MarkdownPad 2:http://markdownpad.com/download/markdownpad2-setup.exe Macdown(Mac用markdown编辑器):http://macdown.uranusjr.com notepad++:https://notepad-plus-plus.org/repository/6.x/6.9.2/npp.6.9.2.Installer.exe 电子书Qt及Qt Quick开发实战精解：https://pan.baidu.com/s/1gfqeSCj Qt+Creator快速入门：https://pan.baidu.com/s/1bo2ib1P 音乐相关一万首吉他谱：https://pan.baidu.com/s/1kUOmzPH Sound Horizon全专辑：https://pan.baidu.com/s/1o8k0Ujo"},{"title":"关于我","date":"2016-09-09T11:54:10.000Z","updated":"2018-01-10T12:10:01.206Z","comments":true,"path":"about/index.html","permalink":"http://www.z16388.top/about/index.html","excerpt":"","text":"赵安琪/Anqi Zhao mail:1021622929@qq.com phone:177-5679-7986 blog:http://z16388.top 教育经历 大连交通大学 &emsp;&emsp;数学与应用数学+软件工程（五年制:2013年9月至今） 技能掌握 熟练使用：C/C++、Java、Markdown 熟悉：Qt Creator、Html/CSS、matlab、Python 操作系统：Win、Mac OS X、Ubuntu 简单的音、视频处理：Cubase+waves、Vegas、Photoshop，Adobe Audition 大学经历 大连交通大学理学院学生会 科技部部长 大连交通大学软件竞赛协会 创始人 大连交通大学汉服社 创始人、工部 一个算法教程（持续更新中）：ACM教程 一个hexo+GitHub Pages的博客 参与项目： 离心泵专家选型系统（Qt Creator界面开发） 大交江湖（部分页面的html/CSS） 获奖经历 2012年1月 中华情艺术风采国际交流展演活动安徽赛区选拔赛 吉他·少年B组·金奖 2015年4月 第六届蓝桥杯软件和信息技术专业人才大赛辽宁省赛区C/C++程序设计大学生B组 一等奖 2015年5月 ACM-ICPC Contest 辽宁省 二等奖 2015年5月 第六届蓝桥杯软件和信息技术专业人才大赛全国总决赛C/C++程序设计大学生B组 三等奖 2015年7月 大连交通大学2015年(第三届)Java程序设计大赛（JPC） 二等奖 2016年3月 第七届蓝桥杯软件和信息技术专业人才大赛辽宁省赛区C/C++程序设计大学生B组 二等奖 2017年3月 第八届蓝桥杯软件和信息技术专业人才大赛辽宁省赛区C/C++程序设计大学生B组 二等奖 等级考试 CET-4 其他天赋 中国音乐学院 社会艺术水平考试 吉他六级 中国音乐艺术家研究院 全国艺术特长生认证 中国音乐家协会 中国音协吉他学会会员"},{"title":"fan","date":"2017-01-24T12:25:38.000Z","updated":"2017-04-13T13:25:15.974Z","comments":true,"path":"fan/index.html","permalink":"http://www.z16388.top/fan/index.html","excerpt":"","text":"评分标准： 5 值得回味4 不可多得3 好看2 可以看1 渣作 动画 番名 类型 年份 评分 备注 Air TV12话+2OVA+总集 2005年冬 Key社季节四部曲，夏之Air Angel Beats！ TV13+1OVA+2特别篇 5 阿拉德战记 TV26集 2009年春夏 2 DNF游戏改编 爱丝卡&amp;罗吉的炼金工房～黄昏天空之炼金术士～ TV12话 2014春 3 爱杀宝贝 TV13+1OVA 2012冬 5 暗杀教室 TV22话+2OVA 2015冬、春 4 BIKINI WARRIORS TV12话+1OVA 2015夏 2 没看完 Black★RockShooter TV8话 2012冬 2 Black★RockShooter OVA 1话 2010年7月 2 百合熊风暴 TV12话 2015冬 ？ 看不懂+没看完 笨蛋、测验、召唤兽 TV13话+2OVA 2010冬 4 笨蛋、测验、召唤兽2！ TV13话 2011夏 4 不思议美眉 12话泡面番 2015秋 4 Clannad TV22话+1番外+1特别 2007秋、2008冬 5 Key社季节四部曲，春之Clannad CLANNAD～AFTER STORY～ TV22话+1番外+1总集+1特别 2008秋、2009冬 5 Clannad第二季 Chaos Dragon 赤龙战役 TV12话 2015夏 2.5 没看完 侧耳倾听 剧场版 1995年 5 曾几何时天魔的黑兔 TV13话 2011夏 3 没看完 赤发白雪姬 TV24话 2015夏秋 3.5 没看完 出包王女 TV26话+6OVA 2008年春夏 4 &amp; 更多出包王女 TV12话 2010年秋 4 出包王女Darkness TV12+6OVA 2012秋 4 出包王女Darkness 2nd TV14+1特别+3OVA 2015夏 4 穿越时空的少女 剧场版 2006年7月 5 小说之后的故事 纯白交响曲 TV12话 2011年秋 3 大家集合吧！Falcom学园 两季26话泡面番 2014冬、2015春 3.5 fans向 电波教师 TV24话 2015春夏 3 没看完 东京食尸鬼 TV12话 2014夏 3 哆啦A梦：新·大雄的日本诞生 剧场版 2016年3月 5 ef - a tale of memories. TV12话 2007秋 &amp; ef - a tale of melodies. TV12话 2008秋 &amp; 恶魔阿萨谢尔在召唤你 恶魔阿萨谢尔在召唤你z Fate/Stay Night TV24话 2006年冬春 5 Fate/stay night [Unlimited Blade Works] TV26+1OVA 2014秋、2015春 5 Fate/Stay Night Unlimited Blade Works 剧场版 2010年1月 4 节奏过快，需要结合原作去看才能跟上 Fate/Zero TV两季25话 2011年秋、2012年春 5 风之谷 剧场版 1984 5 GATE 奇幻自卫队 TV24话 2015夏、2016冬 4.5 甘城辉煌乐园救世主 TV13+OVA 2014秋 &amp; 搞姬日常 13话 泡面番 2014夏 5 搞笑漫画日和 4季12*3+25话 泡面番 - 5 干物妹！小埋 TV12+1OVA 2015夏 5 关于完全听不懂老公在说什么的事 两季26话 泡面番 2014秋、2015春 5、4 哈尔的移动城堡 剧场版 2014年11月 4 好想告诉你 TV25+TV13 2009秋、2010冬+2011冬 4 &amp; 红猪 剧场版 4 花舞少女 TV12话 2014夏 4 幻想嘉年华 12+α 2011年夏秋 5 极黑的布伦希尔德 TV13话 2014春 5-1 后面烂尾 机巧少女不会受伤 TV12话 2013秋 4 没看完 寄生兽 TV24话 2014秋、2015冬 4 没看完 加速世界 TV24话+2OVA 2012春 5 舰队collection TV12话 2015冬 * 结城友奈是勇者 TV12话 2014秋 4 没看完 借东西的小人阿莉埃蒂 剧场版 2010年7月 4 尽管如此世界依然美丽 TV12话 2014春 5 老夫的少女心~(@^_^@)~ 进击的巨人 TV26+5OAD 2013春夏 2 没看完 境界的彼方 TV12+OVA 2013秋 5 境界的彼方 -I’LL BE HERE- 未来篇 剧场版 2015年4月 4 绝对双刃 TV12话 2015冬 X 完全没有印象了 Kannon TV 5 key社季节四部曲，冬之Kannon 可塑性记忆 TV13话 2015春 4 &amp; 科学超电磁炮 TV24+OVA 2009秋、2010冬 3 科学超电磁炮S TV24+OVA 2013春夏 3 空之境界 剧场版8集 2007~2010年 5 LoveLive! TV两季16话+OVA 2013冬、2014春 3 来自虞美人之坡 剧场版 2011年7月 3 宫崎吾朗第二作 凉宫春日的消失 剧场版 2010年2月 5 凉宫春日的忧郁 TV14话 2006春 5 凉宫春日的忧郁 TV28话（包括前作14话） 2009年春夏 -5 邻座的怪同学 TV13+1OAD 2012秋 4 零之使魔 TV13话 2006夏 4 零之使魔～双月的骑士～ TV12话 2007夏 4 零之使魔～三美姬的轮舞～ TV12+OVA 2008夏 4 零之使魔F TV12话 2012冬 4 六叠间的侵略者 TV12话 2014夏 4 六花的勇者 TV12话 2015夏 3.5 龙猫 剧场版 5 龙娘七七七埋藏的宝藏 TV11话 2014春 4 &amp; 龙与虎 TV25+OVA 2008秋、2009冬 5 鲁邦三世VS名侦探柯南 剧场版 2009年3月 5 鲁邦三世：卡里奥斯特罗城 剧场版 1979年 5 路人女主的养成方法 TV13话 2015冬 4 萝球社！ TV12+1OVA 2011夏 4 小仓唯圈粉作 轮回的拉格朗日 两季TV24+OVA 2012冬、夏 ？ &amp; MACROSS DELTA TV16话 2016春夏 5 GiriGiri~EYE~ MM一族 TV12话 2010秋 4 漫画家与助手 TV12话+6OVA 2014春 5 猫的报恩 剧场版 2002年7月 4 《侧耳倾听》外传 每度！浦安铁筋家族 泡面番 2014夏 4 迷茫管家与懦弱的我 秒速五厘米 剧场版 2007年 5 魔法禁书目录 TV24话 2008秋、2009冬 3 魔法禁书目录 TV24话 2010秋、2011春 3 魔法的禁书目录：恩底弥翁的奇迹 剧场版 2013年2月 4 魔法少女小圆 TV12话 2011冬 4 魔法少女小圆剧场版 [前篇] 起始的物语 剧场版 2012年10月 3 魔法少女小圆剧场版 [后篇] 永远的物语 剧场版 2012年10月 3 魔法少女小圆剧场版 [新篇] 叛逆的物语 剧场版 2013年10月 5 魔法少女什么的已经够了啦。 泡面番两季24话 2016冬、秋 3 没看完 魔女宅急便 剧场版 1989 4 魔物娘的同居日常 TV12话+OAD 2015夏 3 没看完 目隐都市的演绎者 TV12话 2014春 * 没看完 NO GAME NO LIFE游戏人生 TV12话 2014春 4 虎纹鲨鱼~ 那就是声优！ TV13话 2015夏 4 南家三姐妹 你的名字。 剧场版 2016年12月 5 新海老贼！！！！ 虐杀姬 5OVA 2007年 4 Overlord TV13+1OVA 2015夏 4.5 乒乓 TV11话 2014春 5 普通女高中生要做当地偶像 TV12话 2014夏 3 起风了 剧场版 2013年7月 4 漆黑的子弹 TV13话 2014春 3 没看完 齐木楠雄的灾难 TV24话 2016夏秋 5 潜行吧！奈亚子 TV12话+1OVA 2012春 4 潜行吧！奈亚子W TV12话+1OVA 2013春 4 潜行吧！奈亚子F OVA1话 2015年5月 4 琴浦小姐 TV12话 2013冬 4 平胸小姐 侵略！乌贼娘 TV24话+3OVA 2010秋、2011秋 3 前进吧！登山少女 TV两季36话泡面番 2013冬、2014夏秋 3 千与千寻 剧场版 2001年 5 枪神斯托拉塔斯 TV12话 2015春 3 没看完 青春×机关枪 TV12话 2015夏 3 青春之旅 TV12话 2014夏 4 &amp; 请问您今天要来点兔子吗？ TV12话 2014春 3.5 请问您今天要来点兔子吗？？ TV12话 2015秋 3 轻音少女！ TV12+2番外 2009春 5 轻音少女！！ TV24+3番外 2010春夏 5 轻音少女 剧场版 剧场版 2011年12月 5 犬神同学和猫山同学 12话+1OVA 泡面番 2014春 5 日常 TV26+OVA 2011春夏 5 散华礼弥 TV12+2OVA+1OAD 2012春 3 神的记事本 死亡笔记 TV37+2SP 2006秋~2007春 3 四月是你的谎言 TV22话+1OAD 2014秋、2015冬 5 上课小动作 TV全21集+OVA2集+映像特典2集 泡面番 2014冬、春 5 石膏男孩 TV12话 2016冬 4.5 噬神者 TV13话 2015夏、2016冬 5 御神乐学园组曲 TV12话 2015春 3 &amp; 授业到天亮Chu! 剧场版 2014年6月 4.5 黄漫改编表番！？ 桃剑 TV12话 2014夏 2.5 没看完 天降之物 TV13+OVA 2009秋 3 天降之物 f TV12 2010秋 3 天降之物：发条装置之哀女神 剧场版 2011年6月 3 天降之物Final：永远的我的鸟笼 剧场版 2014年4月 3 天空之城 剧场版 1986年 5 天体的秩序 图书馆战争 TV12+1 2008年春 3 没看完 妄想学生会 TV13+8OVA 2010年夏 5 妄想学生会* TV13+6OVA 2014冬 5 未来日记 TV26话 2011秋、2012冬 2 单纯的不喜欢而已 伪恋 TV20话+3OVA 2014冬春 4 伪恋： TV12话 2015春 3 为美好的世界献上祝福！ TV10+2OVA 2016冬 4 为美好的世界献上祝福！2 2017冬 &amp; 问题儿童都来自异世界？ TV10+OVA 2013冬 3 没看完 我不受欢迎，怎么想都是你们的错！ TV12话+1OVA 2013夏 5 我被抓到贵族女校当“庶民样本” TV12话 2015秋 3 我老婆是学生会长！ TV12+1OVA 2015夏 3.5 我老婆是学生会长！+！ TV12话 2016秋 3 我的妹妹哪有这么可爱！ 16话+1番外 2010秋 5 我的妹妹哪有这么可爱。 16话 2013年春 4 我的脑内恋碍选项 TV10话+OVA 2013秋 3 没看完 我的朋友很少 TV12+OVA+OAD 2011秋 4 我的朋友很少NEXT TV12话 2013冬 3 &amp; 我的青春恋爱物语果然有问题。 TV13+OVA 2013春 5 我的青春恋爱物语果然有问题。续 TV13话 2015春 -5 惨不忍睹，渣作之最，只看2分钟 我家浴室的现况 13话 泡面番 2014秋 3 我女友与青梅竹马的惨烈修罗场 TV13 2013春 3 毁于画风 我们大家的河合庄 TV13话 2014春 4.5 我们没有羽翼 TV12话 2011春 5 贼他喵黄暴 我们仍未知道那天所看见的花的名字 TV11话 2011春 5 我们仍未知道那天所看见的花的名字剧场版 剧场版 2013年8月 5 我太受欢迎了该怎么办 TV12话 2016秋 4 我永远的圣诞老人 2OVA 2005年12月 3 物语系列 - - - - 化物语 TV12+3 2009夏 5 伪物语 TV11话 2012冬 5 猫物语（黑） TV4话 2012年12月31日 5 物语系列 2nd Season TV26+5SP 2012夏、秋 5 包括《猫物语（白）》、《倾物语》、《囮物语》、《鬼物语》和《恋物语》，SP为《花物语》 凭物语 TV4话 2014年12月31日 5 &amp; 终物语 TV12话 2015秋 5 &amp; 历物语 APP12话 2016年1月 ？ &amp; 伤物语Ⅰ铁血篇 剧场版 2016年1月 ？ &amp; 伤物语Ⅱ 热血篇 剧场版 2016年8月 ？ &amp; 伤物语Ⅲ 冷血篇 剧场版 2017年1月 ？ &amp; 下流梗不存在的灰暗世界 TV12话 2015夏 5 夏目友人帐 TV13话 2008夏 5 续夏目友人帐 TV13话 2009冬 5 夏目友人帐叁 TV13话 2011夏 5 夏目友人帐肆 TV13话 2012冬 5 夏目友人帐 猫咪老师首次变身使者 OVA 2013年8月 5 夏目友人帐 曾几何时下雪之日 OVA 2014年2月 5 夏目友人帐伍 TV11话+OVA 2016秋 4 小长门有希的消失 TV16+OVA 2015春夏 4 线上游戏的老婆不可能是女生？ TV12话 2016春 3 没看完 幸腹涂鸦 TV12话 2015冬 3 没看完 星刻的龙骑士 TV12话 2014春 2 幸运星 TV24+OVA 2007春 4 &amp; 修业魔女璐璐萌 TV12话 2014夏 &amp; 悬崖上的金鱼公主 剧场版 2008年7月 4 学生会的一己之见 TV12话 2009年秋 4 学生会的一己之见 Lv.2 TV9+1EX 2013年、冬 3 &amp; 血型君 四季49话泡面番 2013春、2015冬、秋、2016冬 3 要听爸爸的话！ TV12+1+2OVA 2012冬 3 没看完 摇曳百合 TV12话 2011夏 5 摇曳百合♪♪ TV12话 2012夏 4.5 摇曳百合 3☆High! TV12话 2015秋 5 摇曳百合 夏日时光+ 2话 2015年8月 5 野良神 两季 -4 异国迷路的十字路口 一拳超人 TV12+OVA+OAD 2015秋 5 樱花庄的宠物女孩 TV24话 2012秋、2013冬 2 没看完 幽灵公主 剧场版 1997年 5 有你的小镇 TV12+3OVA 2013夏 4 有你的碧池 元气囝仔 TV12话 2014夏 5 元气少女缘结神 TV13+OVA 2012秋 4 元气少女缘结神◎ TV12话 2015冬 4 月刊少女野崎君 TV12话 2014夏 5 在下坂本，有何贵干？ TV12话 2016春 4 斩·赤红之瞳！ TV24话 2014夏 3 没看完 这个是僵尸吗？ TV12+1OVA 2011冬 3 这样算是僵尸吗？OF THE DEAD TV10话 2012春 3 枕男子 TV12泡面番 2015夏 3 只有神知道的世界 TV12话 2010秋 4 只有神知道的世界2 TV12话 2011春 4 只有神知道的世界·女神篇 TV12话 2013夏 4 重金属摇滚双面人 中二病也要谈恋爱！ TV12+1 2012秋 5 中二病也要谈恋爱！恋 TV12+1 2014冬 3.5 终结的炽天使 TV24话 2015春、秋 3.4 没看完 罪恶王冠 TV22+1+1OVA 2011秋、2012冬 3 没看完 - - - - - 补 荒川爆笑团 TV两季26话 2010春、秋 4 黑白来看守所 人渣的本愿 小林家的妹抖龙 One Room 珈百璃的堕落 风夏 政宗君的复仇 清恋 杀老师Quest NEW GAME! 双星之阴阳师 Re：从零开始的异世界生活 无彩限的怪灵世界 吹响！上低音号 两季TV26+1 2015春、2016秋 &amp; 军火女王 TV两季24话 2012春、秋 恶魔阿萨谢尔在召唤你 恶魔阿萨谢尔在召唤你z 文学少女 银魂 薄樱鬼 迷糊餐厅 会长大人是女仆 真·恋姬无双 黑塔利亚 一骑当千 玉响 黑之契约者 传颂之物 亲吻姐姐 滑头鬼之孙 学园默示录 缘之空 食梦者 GOSIC 追逐繁星的孩子 君吻 圣诞之吻 学园默示录 无口的森田小姐 电波女与青春男 命运石之门 花开伊吕波 萤火之森 旋风管家 就算是哥哥，有爱就没问题了，对吧 绝园的暴风雨 玉子市场 超元气三姐妹 魔王勇者 变态王子与不笑猫 打工吧！魔王大人 言叶之庭 high school 神不在的星期天 来自风平浪静的明天 三者三叶 京骚戏画 最近，妹妹的样子有点怪？ 一周的朋友 我，要成为双马尾 肯普法 安琪莉可 电波女 圣剑锻造师 Another 在盛夏等待 东京残响 新妹魔王的契约者 山田君与7人魔女 俺物语！！ 学园孤岛 灵感！ 苍之彼方的四重奏 灰与幻想的格林姆迦尔 若叶女孩 亚人酱有话要说 冰上的尤里 日剧 番名 类型 年份 评分 备注 百鬼夜行抄 虫师 我们仍未知道那天所看见的花的名字。 剧场版 2015年9月 5 那朵花SP 排名200补番表200.希德尼娅的骑士197.心理测量者193.光之美少女192.冰菓188.坂道上的阿波罗186.刀语185.东之伊甸184.魔法少女奈叶182.flcl特别的她181.狼与香辛料180.悠哉日常大王179.樱兰高校男公关部178.圣母在上177.异邦人 无皇刃谭174.阿兹漫画大王172.星界的战旗170.无限的未知169.校园迷糊大王165.重金属摇滚双面人164.飞跃巅峰163.只有我不在的街道157.萤火虫之墓156.摇滚新乐园154.无头骑士异闻录141.xxxHOLIC继140.赌博默示录137.剑风传奇136.向阳素描135.自新世界131.黑之契约者126.奇诺之旅125.千年女优123.ef122.盗梦侦探121.狼的孩子雨和雪120.海马118.秀逗魔导师115.欢迎加入NHK113.夏日大作战（细田守）112.飞跃巅峰110.宇宙战舰大和号109.超智游戏108.ef2106.怪化猫（怪物）96.星界的战旗295.相聚一刻94.宇宙兄弟93.交响诗篇91.星界的纹章89.jojo88.东京教父87.perfect blue86.吹响！上低音号 （上面有）85.王牌投手83.第一神拳81.机动警察 和平保卫战80.昭和元禄落语中心77.四畳半神话大系（歌）、75.夏娃的时间70.电脑线圈68.精灵守护者67.交响情人梦61.黑礁60.白兔糖57.全职猎人55.全金属狂潮54.皇家国教骑士团51.百变之星 不死鸟传说48.十二国记45.食梦者43.空之境界40.混沌武士38.百变之星37.永生之酒35.蜂蜜与四叶草（长井龙雪）31.死亡笔记30.歌牌情缘28.怪物26.少女与战车25.天元突破22.星空清理着20.白箱17.排球少年15.反叛的鲁路修14.虫师13.EVA10.水星领航员9.浪客剑心8.钢之炼金术师7.命运石之门6.银魂5.星际牛仔4.银河英雄传说2.攻壳机动队 歌龙与虎 田中君总是如此慵懒的小剧场亚人甲铁城三月的狮子橘色奇迹91天黑色幻想的格林姆加尔昭和元禄落语中心jojo漂流武士drifters文豪野犬relife重生计划我的英雄学院冰上的尤里灵能百分百排球少年只有我不在的街道"},{"title":"hdu答案","date":"2016-10-28T11:14:23.000Z","updated":"2018-01-10T12:10:34.352Z","comments":true,"path":"answer/index.html","permalink":"http://www.z16388.top/answer/index.html","excerpt":"","text":"1089-1096输入输出练习答案:http://www.z16388.top/2016/10/28/1089-1096输入输出练习/ hdu1326:http://www.z16388.top/2016/11/16/hdu1326-hdu2088/ hdu1720:http://www.z16388.top/2016/11/16/hdu1720/ hdu2000-2010:http://www.z16388.top/2016/10/28/hdu2000-2010/ hdu2011-2020:http://www.z16388.top/2016/10/30/hud2011-2020答案/ hdu2088:http://www.z16388.top/2016/11/16/hdu1326-hdu2088/"},{"title":"友情链接","date":"2016-09-10T07:46:28.000Z","updated":"2018-01-10T11:28:43.008Z","comments":true,"path":"friend/index.html","permalink":"http://www.z16388.top/friend/index.html","excerpt":"","text":"&emsp;&emsp;小川先生：http://www.superxc.com/ &emsp;&emsp;田&emsp;浩：http://tianhao.site &emsp;&emsp;林嘉铭：http://jammylin.win"},{"title":"tags","date":"2016-09-09T07:42:07.000Z","updated":"2017-04-13T13:25:15.990Z","comments":false,"path":"tags/index.html","permalink":"http://www.z16388.top/tags/index.html","excerpt":"","text":""},{"title":"常用网址导航","date":"2016-09-09T12:08:29.000Z","updated":"2018-01-10T12:11:14.360Z","comments":true,"path":"int/index.html","permalink":"http://www.z16388.top/int/index.html","excerpt":"","text":"分析 学习廖雪峰的官方网站：Python，js，git教程 程序猿ACM-ICPC 蓝桥杯 杭电 C语言网 CodeVS 51nod CSDN 慕课网 王道论坛 七牛云 HB包 学校教务在线 网络中心 音乐现音研吉他社"}],"posts":[{"title":"QT笔记-基础篇","slug":"qt","date":"2017-07-12T07:46:28.000Z","updated":"2017-07-12T15:26:41.905Z","comments":true,"path":"2017/07/12/qt/","link":"","permalink":"http://www.z16388.top/2017/07/12/qt/","excerpt":"","text":"基础部分修改某个控件显示的文字（优先级比属性高）123ui-&gt;pushButton-&gt;setText(tr(\"新的\"));//在软件中应避免直接出现中文字符串，应该使用tr()函数包含//这段代码如果用于控件的初始化，应当写在构造函数中 弹出警告对话框 需要使用头文件QMessageBox 123QMessageBox::warning(this, tr(\"警告！\"), tr(\"用户名或密码错误！\"), QMessageBox::Yes); &emsp;&emsp;从上面的例子我们可以看出这个函数的参数分别为：父窗口、对话框标题、对话框的显示内容、对话框中的按钮。也就是说，上面这段代码实现的是弹出一个提示密码输入错误的，带有一个Yes按钮的警告对话框。 &emsp;&emsp; 注：需要使用头文件 #include 登陆窗口的创建步骤 在项目视图中，右键-&gt;添加文件-&gt;QT-&gt;QT设计师界面类 在创建好的登陆窗口中新建一个按钮，切换成“控件和槽编辑模式”，拖动按钮，放开鼠标后，会弹出配置连接对话框。将pushButton的clicked()信号和LoginDlg的accept()槽关联起来。其中，accept()槽的功能是：将对话框关闭并返回QDialog::Accepted标识。 修改main函数：12345678910111213141516#include \"mainwindow.h\"#include &lt;QApplication&gt;#include \"logindlg.h\" // 增加登陆窗口的头文件int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; LoginDlg dlg; // 声明 if(dlg.exec() == QDialog::Accepted) // 利用Accepted返回值判断按钮是否被按下 &#123; w.show(); // 如果被按下，显示主窗口 return a.exec(); // 程序一直执行，直到主窗口关闭 &#125; else return 0; // 如果没有被按下，则不会进入主窗口，整个程序结束运行&#125; &emsp;&emsp;在上面的代码中，我们首先创建了LoginDlg类的对象dlg，然后让dlg运行，即执行exec()函数，然后判断它的返回值。如果用户按下了按钮，那么返回值应该是Accepted，这个时候就会显示主窗口，并正常执行程序；否则，结束程序。 &emsp;&emsp;另外，在平时写程序的时候，我们需要控制Accepted返回值，可以使用accept()函数。以点击登陆按钮直接进入为例：1234void LoginDialog::on_loginBtn_clicked()&#123; accept();&#125; 密码输入框&emsp;&emsp;首先，新建一个文本条。然后在这个文本条所在的窗口的构造函数中将它的EchoMode属性更改为密码条就行了。例子如下：1ui-&gt;pswEdit-&gt;setEchoMode(QLineEdit::Password); 去除输入中的空格&emsp;&emsp;使用函数trimmed() 清除文本条、光标定位12ui-&gt;usrLineEdit-&gt;clear();ui-&gt;usrLineEdit-&gt;setFocus(); 创建新窗口之后、原窗口不消失的窗口 对一个按钮右键-&gt;”转到槽”； 选择“clicked()”信号，确定，然后自动转到当前窗口代码编辑模式中的on_pushButton_clicked()函数处； 补充函数体：（需要添加头文件#include ）12345void MainWindow::on_pushButton_clicked()&#123; QDialog *dlg = new QDialog(this); dlg-&gt;show(); &#125; &emsp;&emsp;在上面的代码中实现了创建一个对话框对象，然后让它显示出来，创建时指定的this参数表明这个对话框的父窗口是MainWindow。 &emsp;&emsp;这种方法，会让我们每按一次按钮，都会生成一个新的对话框。但是在这个过程中，不会造成内存泄漏或者是内存耗尽，这得益于QT的对象机制，保证了不会造成内存泄漏，而且不需要使用delete语句。 &emsp;&emsp;在日常使用的过程中，我们可以在mainwindow.h文件中先定义一个对话框对象，并在构造函数中进行创建，再在这里使用。 创建一个退出按钮 单击设计模式下方的信号和槽编辑器（Signals &amp; Slots Editor）中的绿色加法号添加关联； 发送者为按钮，信号为clicked()，接受者为当前窗口，操为close()。 QT Creator常用命令Ctrl+滚轮：控制字体大小 Ctrl+1~6：切换左侧边栏，如常用的Ctrl+2(编辑)、Ctrl+3(设计) Ctrl+R：编译 F3：控件编辑模式 F4：信号和槽编辑模式 参考文档API和文档 QT开源社区 教程目录","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"http://www.z16388.top/tags/QT/"}],"keywords":[]},{"title":"数学模型中的Huntington除数法","slug":"Huntington","date":"2017-05-19T14:36:44.000Z","updated":"2017-05-22T10:42:40.359Z","comments":true,"path":"2017/05/19/Huntington/","link":"","permalink":"http://www.z16388.top/2017/05/19/Huntington/","excerpt":"","text":"本篇博客请结合《数学模型（第四版）》，姜启源版教材第八章第四节内容阅读。 &emsp;&emsp;在处理席位分析问题时，常使用Huntington除数法来进行处理。在书中279~281的学习中，我们了解到了怎样去比较一个分配结果的不公平度，以及一个较惯例分配法更加公平的“Q值法”。那么，下面我将介绍一种处理这类问题的通用方法，Huntington除数法。 &emsp;&emsp;Edward Vermilye Huntington(1874~1952)，1922年获得哈佛大学博士学位。20世纪20年代，他对这个问题做了具体的研究，提出了一系列的席位分配方法。之前介绍过的“Q值法”，也作为其中的一种情况，包含在内。 &emsp;&emsp;假设共有m方分配N个席位，第i方的人数记为pi,ni表示第i方分配的席位数，且均为非负整数。 Huntington除数法 除数&emsp;d(n) 不公平度的度量指标(假定pi/ni&gt;pj/nj) 最大除数法(GD) n+1 (nj-pi)/pj-ni 主要分数法(MF) n+1/2 (nj/pj)-(ni-pi) 相等比例法(EP) sqrt(n(n+1)) (njpi)/(nipj)-1 调和平均法(HM) 2n(n+1)/(2n+1) pi/ni-pj/nj 最小除数法(SD) n nj-nipj/pi &emsp;&emsp;下面是这个方法的思路：首先，我们对每一方都分配一个席位，然后利用选定的衡量指标，计算出每一方的不公平度。给最大的那一组，分配一个席位，然后继续计算，直到将所有席位分配完毕。一般情况下，在使用Huntington除数法时，通常在各方自动分得1席的基础上在做分配，除非在各方人数悬殊且席位数较少的时候。 &emsp;&emsp;由于在计算的过程中，采用了每增加1席计算一次的方式，因此不会出现席位悖论和人口悖论。 &emsp;&emsp;下面是C语言写的Huntington算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int w;FILE *fin=fopen(\"in.txt\",\"r\");double dn(int n)&#123; switch(w) &#123; case 1:return n+1.0; case 2:return n+0.5; case 3:return sqrt(n*(n+1.0)); case 4:return 2*n*(n+1.0)/(2*n+1); case 5:return n; default:return 0; &#125;&#125;void Huntington()&#123; int s,flag=0,bh=1; double p[6],pd[6]; int n[6]; double max_pd; fscanf(fin,\"%d\",&amp;s); for(int i=1;i&lt;=5;i++) &#123; fscanf(fin,\"%lf\",&amp;p[i]); &#125; for(int i=1;i&lt;=5;i++) &#123; n[i]=1; &#125; while(n[1]+n[2]+n[3]+n[4]+n[5]!=s) &#123; flag=1; for(int i=1;i&lt;=5;i++) &#123; pd[i] = p[i]/dn(n[i]); &#125; max_pd = p[1]/dn(n[1]); for(int i=2;i&lt;=5;i++) &#123; if(pd[i]&gt;max_pd) &#123; flag = i,max_pd = pd[i]; &#125; &#125; n[flag]++; cout&lt;&lt;\"第\"&lt;&lt;bh++&lt;&lt;\"次：\"&lt;&lt;endl; for(int i=1;i&lt;=5;i++) cout&lt;&lt;\"p/di=\"&lt;&lt;pd[i]&lt;&lt;\" n=\"&lt;&lt;n[i]&lt;&lt;endl; cout&lt;&lt;\"--------------------\"&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125;void printList()&#123; cout&lt;&lt;\"#请选择需要模拟的权重函数#\"&lt;&lt;endl; cout&lt;&lt;\"1.最大除数法(GD)\"&lt;&lt;endl; cout&lt;&lt;\"2.主要分数法(MF)\"&lt;&lt;endl; cout&lt;&lt;\"3.相等比例法(EP)\"&lt;&lt;endl; cout&lt;&lt;\"4.调和平均法(HM)\"&lt;&lt;endl; cout&lt;&lt;\"5.最小除数法(SD)\"&lt;&lt;endl; cout&lt;&lt;\"--------------------\"&lt;&lt;endl; cout&lt;&lt;\"退出请输入0\"&lt;&lt;endl;&#125;void select()&#123; printList(); while(cin&gt;&gt;w) &#123; switch (w) &#123; case 1:case 2:case 3:case 4:case 5: Huntington(); select(); break; case 0:fclose(fin);exit(0); default: cout&lt;&lt;\"输入错误，请重新输入\"&lt;&lt;endl; cout&lt;&lt;\"--------------------\"&lt;&lt;endl; select(); &#125; &#125;&#125;int main()&#123; select(); fclose(fin); return 0;&#125; &emsp;&emsp;GD法偏向于人数多的组，SD法偏向于人数少的组。Huntington推荐偏向适中的EP法，也就是“Q值法”，该方法在1930年后一直在被美国国会众议员席位分配中采用。","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://www.z16388.top/tags/数学/"},{"name":"数学模型","slug":"数学模型","permalink":"http://www.z16388.top/tags/数学模型/"}],"keywords":[]},{"title":"VS调试时提示找不到msvcr80d.dll解决方案","slug":"vs1","date":"2017-04-15T02:18:53.000Z","updated":"2017-04-15T02:30:57.722Z","comments":true,"path":"2017/04/15/vs1/","link":"","permalink":"http://www.z16388.top/2017/04/15/vs1/","excerpt":"","text":"&emsp;&emsp;在学校的很多课程中，需要使用到Visual Studio。在编写程序进行调试的时候，经常会出现报错“找不到msvcr80d.dll”的情况，让人很头疼。 &emsp;&emsp;这个是由于调试类型和硬盘的格式造成的。在学校机房的环境里，可以进行一下的步骤解决问题： 项目 -&gt; [项目名] 属性 -&gt; 配置属性 -&gt; 清单工具 -&gt; 常规 -&gt; 将“使用FAT解决办法”的属性设置为“是”。 进行设置之后，保存，执行: 生成 -&gt; 重新生成解决方案 重新调试","categories":[],"tags":[{"name":"Visual-Studio","slug":"Visual-Studio","permalink":"http://www.z16388.top/tags/Visual-Studio/"}],"keywords":[]},{"title":"dfs专项练习","slug":"dfs","date":"2017-03-30T10:52:27.000Z","updated":"2018-01-10T13:39:57.470Z","comments":true,"path":"2017/03/30/dfs/","link":"","permalink":"http://www.z16388.top/2017/03/30/dfs/","excerpt":"","text":"poj1664:放苹果 hdu1016:素数环问题 hdu2553:N皇后问题 hdu1584:蜘蛛牌 hdu1181:变形课","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】3.8从全排列到深度优先搜索dfs算法","slug":"【ACM教程】3-8从全排列到深度优先搜索dfs算法","date":"2017-03-22T08:37:34.000Z","updated":"2018-01-10T12:18:33.064Z","comments":true,"path":"2017/03/22/【ACM教程】3-8从全排列到深度优先搜索dfs算法/","link":"","permalink":"http://www.z16388.top/2017/03/22/【ACM教程】3-8从全排列到深度优先搜索dfs算法/","excerpt":"","text":"第八节 从全排列到深度优先搜索算法全排列&emsp;&emsp;什么是全排列？就是一组数据所有可能的排列顺序。如果使用暴力枚举的方法，需要对每一个位置都进行一次循环，如果有n个数据则需要循环n次，而且还要加上对重复序列的判断。 &emsp;&emsp;可喜的是，在STL中有两个函数可以帮我们实现字典序的全排列。他们分别是：next_permutation()prev_permutation()，参数是数据的开始和结束地址。举个例子，比如一个字符数组：a,b,c，它的下一个序列就是a,c,b。在处理全排列问题的时候，使用比较方便。这两个函数在算法头文件中。 &emsp;&emsp;由于这两个函数是根据字典序来给出下一个全排列，如果想要得出所有的全排列，则需要首先对序列进行排序。 &emsp;&emsp;蓝桥杯中很多题目可以使用这种方法来解决，以第七届蓝桥杯的第三题为例： B DEFA + —— + ——— = 10 C GHI这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。比如：6+8/3+952/714 就是一种解法，5+3/1+972/486 是另一种解法。这个算式一共有多少种解法？注意：你提交应该是个整数，不要填写任何多余的内容或说明性文字。 &emsp;&emsp;代码如下： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]; int i; int sum[4]; int ans; for(i=1;i&lt;=9;++i)&#123; a[i]=i; &#125; ans=0; do&#123; sum[0]=a[1]*a[3]*(a[7]*100+a[8]*10+a[9]); sum[1]=a[2]*(a[7]*100+a[8]*10+a[9]); sum[2]=(a[4]*100+a[5]*10+a[6])*a[3]; sum[3]=10*a[3]*(a[7]*100+a[8]*10+a[9]); if(sum[0]+sum[1]+sum[2]==sum[3])&#123; ++ans; &#125; &#125;while(next_permutation(a+1,a+1+9)); printf(\"%d\\n\",ans); return 0;&#125; 深度优先搜索dfs算法&emsp;&emsp;突然想要感叹一句：终于要讲到dfs算法了。为什么要发出这样的感叹呢，因为从这里开始，我们真正要接触到算法的内容了。之前的学习都可以说是小打小闹，到这里再是正主。 &emsp;&emsp;事实上，深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。dfs算法是算法学习过程中的重中之重，因为全排列是个一维的过程，为了便于大家的理解，我就从它开始吧。 &emsp;&emsp;有a、b、c三个盒子，以及1，2，3三只球。我们将球放到盒子里，每个盒子只能放一个球，求一共有几种放法。如果形象地形容这个全排列的过程，将会是这个样子：首先按照字典序顺序放球，也就是在a盒子中放1号球，b盒子中放2号球，c盒子中放3号球。再向后走就没有盒子了，同时我们手中也没有剩余球了。这个时候，往回走，寻找有没有其他的放球顺序。先回到c盒子前拿出3号球，再到b盒子前拿出2号球。这时候，又产生了一种排列方式：把3号球放到b盒子中，2号球放到c盒子中。接下来以此类推，产生剩余的序列。 &emsp;&emsp;那么，我们把上面的过程用程序来模拟一下。首先是第一种放置方法，先按照升序将球放好： 123for(int i=1;i&lt;=n;i++) &#123; a[step] = i;&#125; &emsp;&emsp;这里的数组a表示盒子的序列，变量step表示我们正处在第step个盒子的前面。a[step]=i的意思就是将第i个球放到第step个盒子里。但是需要注意的是，球一旦放进一个盒子里，就不能放在另一个盒子里了。这时候，我们需要记录一下。 123456for(int i;i&lt;=n;i++) &#123; if(book[i]==0) &#123; //book[i]==0表示球还在我们手上 a[step]=i; book[i]=1; //标记i号球已经放到盒子里了 &#125;&#125; &emsp;&emsp;那么，我们既然在第step个盒子里放球了，后面就要继续向后放了。很明显，这是一个递归的过程。我们将要写的过程封装到函数里，将这个函数命名为dfs。然后在里面处理第step+1个盒子。 12345678910void dfs(int step) &#123; for(int i;i&lt;=n;i++) &#123; if(book[i]==0) &#123; a[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125;&#125; &emsp;&emsp;细心的同学可能已经注意到了，除了除以step+1个盒子之外，我们还另外加了一行代码book[i]=0，为什么要加上这一句呢？我们想一下，递归放完所有的球之后，我们是不是在回来的过程中要将这个球从盒子里拿出来呀。如果没有这个操作，这将会对接下来的放置造成障碍。 &emsp;&emsp;在之前的学习中，我们都知道，递归必须要有一个停止条件。转换到这个问题中就是：我们应该在什么时候将计算完毕的全排列输出出来呢？答案是处理到第n+1个盒子时。在前面的“故事背景”中，我们在走到第四个盒子的位置时，发现这个地方没有盒子，就往回走了。这个时候就是要输出的时候。代码如下： 1234567891011121314151617void dfs(int step) &#123; if(step==n+1) &#123; for(int i=1;i&lt;=n;i++) &#123; printf(\"%d\",a[i]); &#125; printf(\"\\n\"); return; //返回前一步 &#125; for(int i;i&lt;=n;i++) &#123; if(book[i]==0) &#123; a[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125;&#125; &emsp;&emsp;整个过程我们模拟完毕了，整理得到完整的代码： 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int a[10],book[10],n;void dfs(int step) &#123; if(step==n+1) &#123; for(int i=1;i&lt;=n;i++) &#123; printf(\"%d\",a[i]); &#125; printf(\"\\n\"); return; //返回前一步 &#125; for(int i;i&lt;=n;i++) &#123; if(book[i]==0) &#123; a[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125;&#125;int main() &#123; scanf(\"%d\",&amp;n); dfs(1); return 0;&#125; &emsp;&emsp;这个问题虽然简单，但是包含了dfs的基本模型。理解dfs算法的关键在于理解“当下应该如何去做”。至于“下一步应该怎么做”是和当下的操作一样的。我们在处理第step个盒子和step+1个盒子的时候，都采用的是一样的操作。因此，我们可以整理出dfs的基本模型： 1234567void dfs(int step) &#123; 判断边界 尝试所有的可能 for(int i=1;i&lt;=n;i++) &#123; 继续下一步 dfs(step+1) &#125; 返回&#125; &emsp;&emsp;我们以一道题目为例，第七届蓝桥杯的第七题，剪邮票： 如【图1.jpg】, 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连）比如，【图2.jpg】，【图3.jpg】中，粉红色所示部分就是合格的剪取。请你计算，一共有多少种不同的剪取方法。请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 图1 图2 图3 &emsp;&emsp;我们先看一下一位同学错误的解法吧：http://blog.csdn.net/star92014/article/details/50942239 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;int a[5]=&#123;0,&#125;;int check()&#123; int flag[5]=&#123;0,&#125;; flag[0]=1; int check[5]=&#123;0,&#125;; int i,j;rep: for(i=0;i&lt;5;i++)&#123; if(flag[i]&amp;&amp;check[i]==0)&#123; check[i]=1; for(j=0;j&lt;5;j++)&#123; if(j==i)continue; if(a[j]==a[i]+1||a[j]==a[i]-1 ||a[j]==a[i]-4||a[j]==a[i]+4)&#123; flag[j]=1; &#125; &#125; &#125; &#125; for(i=0;i&lt;5;i++)&#123; if(flag[i]&amp;&amp;check[i]==0)goto rep; &#125; int count=0; for(i=0;i&lt;5;i++)&#123; if(flag[i])count++; &#125; if(count==5)return 1; else return 0;&#125;int main()&#123; int count=0; for(a[0]=1;a[0]&lt;13;a[0]++)&#123; for(a[1]=a[0]+1;a[1]&lt;13;a[1]++)&#123; // if(a[1]==a[0])continue; for(a[2]=a[1]+1;a[2]&lt;13;a[2]++)&#123; // if(a[2]==a[0]||a[2]==a[1])continue; for(a[3]=a[2]+1;a[3]&lt;13;a[3]++)&#123; // if(a[3]==a[0]||a[3]==a[1]||a[3]==a[2])continue; for(a[4]=a[3]+1;a[4]&lt;13;a[4]++)&#123; //if(a[4]==a[0]||a[4]==a[1]||a[4]==a[2]||a[4]==a[3])continue; if(check())&#123; printf(\"%d %d %d %d %d\\n\",a[0],a[1],a[2],a[3],a[4]); count++; &#125; &#125; &#125; &#125; &#125; &#125; printf(\"%d\",count); return 0;&#125; &emsp;&emsp;代码质量不说，这位同学得到的答案是202，是错误的。那么问题出在了哪里呢？是序列的重复问题。比如12345和12354。为了避免这种情况，我们除了增加判断条件之外，还可以从数据上入手，将序列改为{1,2,3,4,6,7,8,9,11,12,13,14};这样，在判断换行之后的左右侧元素时，就会有失效的元素，避免了重复。下面是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int dir[4] = &#123;1,-1,5,-5&#125;;int temp1[12] = &#123;1,2,3,4,6,7,8,9,11,12,13,14&#125;;int temp2[5];int vis[5];int ans = 0;void dfs(int u)&#123; for(int i=0 ;i&lt;4 ;i++)&#123; int t = temp2[u]+dir[i]; if(t&gt;=1&amp;&amp;t&lt;=14)&#123; for(int j=0 ;j&lt;5 ;j++) if(t==temp2[j]&amp;&amp;!vis[j])&#123; vis[j]=1; dfs(j); &#125; &#125; &#125;&#125;int main()&#123; for(int a=0 ;a&lt;12 ;a++)&#123; for(int b=a+1 ;b&lt;12 ;b++)&#123; for(int c=b+1 ;c&lt;12 ;c++)&#123; for(int d=c+1 ;d&lt;12 ;d++)&#123; for(int e=d+1 ;e&lt;12 ;e++)&#123; temp2[0]=temp1[a]; temp2[1]=temp1[b]; temp2[2]=temp1[c]; temp2[3]=temp1[d]; temp2[4]=temp1[e]; //初始化访问标记数组 memset(vis,0,sizeof(vis)); vis[0]=1; dfs(0); //连通性判断 int flag = 1; for(int i=0 ;i&lt;5 ;i++)&#123; if(vis[i]==0)&#123; flag = 0; &#125; &#125; if(flag)ans++; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125; &emsp;&emsp;DFS专项练习：http://www.z16388.top/2017/03/30/dfs/","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】2.5数学简单问题","slug":"【ACM教程】2-5数学简单问题","date":"2017-03-22T07:25:01.000Z","updated":"2017-04-13T13:25:15.893Z","comments":true,"path":"2017/03/22/【ACM教程】2-5数学简单问题/","link":"","permalink":"http://www.z16388.top/2017/03/22/【ACM教程】2-5数学简单问题/","excerpt":"","text":"第五节 数学简单问题&emsp;&emsp;竞赛中的很多题目会考到数学相关的知识，在这一节，我们会挑出一些简单的问题集中讲解。 最大公约数/最小公倍数&emsp;&emsp;首先我们要介绍一个算法，欧几里德算法。欧几里得是著名的古希腊数学家，被称为“几何学之父”，代表作为《几何原本》。 &emsp;&emsp;欧几里得算法又称辗转相除算法，定理如下：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。（最大公约数缩写为gcd）在这里就不作证明了，直接给出代码： 123456789int gcd(int a,int b) //最大公约数&#123; if(b==0) return a; else return gcd(b,a%b);&#125;int lcm(int a,int b) //最小公倍数&#123; return a/gcd(a,b)*b;&#125; 判断素数&emsp;&emsp;什么是素数呢？素数是大于等于2的，只有1和他本身能够整除他的数。要去判断一个数n是否是素数，只要从2到sqrt(n)依次判断即可，代码如下： 1234567int su(int b)&#123; for(int i=2;i&lt;=(int)sqrt(b);i++) &#123; if(b%i==0) return 0; &#125; return 1;&#125; 排列组合打表12345678910int c[N][N];void com() &#123; memset(c,0,sizeof(c)); for(int i=1;i&lt;N;i++) &#123; c[i][0]=c[i][i]=1; for(int j=1;j&lt;i;j++) &#123; c[i][j]=c[i-1][j]+c[i-1][j-1]; &#125; &#125;&#125; 快速幂&emsp;&emsp;求a的b次幂，我们可以直接使用for循环去做。但是当b很大的时候，就会花费很多时间，这时候需要使用快速幂算法。 &emsp;&emsp;下面我们就以求a^11为例，介绍一下快速幂算法。 将11转化为二进制——1011 分解：11=1*2^3+0*2^2+1*2^1+1*2^0 将a^11转化为a^(2^3)*a^(2^1)*a^(2^0) &emsp;&emsp;代码如下： 123456789int Fast(int x,int n) &#123; int tem=x,ans=1; while(n) &#123; if(n%2==1) ans*=tem; tem*=tem; n&gt;&gt;=1; &#125; return ans;&#125; 快速幂取模&emsp;&emsp;公式：a*b%c=((a%c)*b)%c&emsp;&emsp;(a+b)%c=(a%c+b%c)%c 123456789int pow(int a,int x) &#123; int ans=1,temp=a%p; while(x) &#123; if(x&amp;1) ans=((long long)ans*temp)%p; temp=((long long)temp*temp)%p; x&gt;&gt;=1; &#125; return ans;&#125; 十进制转换为x进制1234567891011121314string trans(int num,int base) &#123; string str; while(num&gt;0) &#123; if(num%base&lt;10) &#123; str+=num%base+'0'; &#125; else &#123; str+=num%base-10+'A'; &#125; num=num/base; &#125; reverse(str.begin(),str.end()); return str;&#125; 常用的数学公式等差数列求和公式： Sn=n*a1+n(n-1)d/2Sn=n(a1+an)/2 等比数列求和公式： Sn=a1(1-q^n)/(1-q)","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"第六届蓝桥杯C/C++省赛B组题目详解","slug":"lanqiao6","date":"2017-03-21T11:57:34.000Z","updated":"2017-04-13T13:25:15.864Z","comments":true,"path":"2017/03/21/lanqiao6/","link":"","permalink":"http://www.z16388.top/2017/03/21/lanqiao6/","excerpt":"","text":"第一题 奖券数目 有些人很迷信数字，比如带“4”的数字，认为和“死”谐音，就觉得不吉利。虽然这些说法纯属无稽之谈，但有时还要迎合大众的需求。某抽奖活动的奖券号码是5位数（10000-99999），要求其中不要出现带“4”的号码，主办单位请你计算一下，如果任何两张奖券不重号，最多可发出奖券多少张。请提交该数字（一个整数），不要写任何多余的内容或说明性文字。 &emsp;&emsp;这道题虽然可以使用穷举法去做，但是其实是一道“稿纸题”。分析每一位上面数的可能性，直接使用8*9*9*9*9即可计算出来。最终答案为：52488 第二题 星系炸弹 在X星系的广袤空间中漂浮着许多X星人造“炸弹”，用来作为宇宙中的路标。每个炸弹都可以设定多少天之后爆炸。比如：阿尔法炸弹2015年1月1日放置，定时为15天，则它在2015年1月16日爆炸。有一个贝塔炸弹，2014年11月9日放置，定时为1000天，请你计算它爆炸的准确日期。请填写该日期，格式为yyyy-mm-dd 即4位年份2位月份2位日期。比如：2015-02-19 &emsp;&emsp;这是一道简单的日期计算问题。掌握好每个月的天数，然后计算。当然，也可以是一道稿纸题。 &emsp;&emsp;最终答案为：2017-08-05 第三题 三羊献瑞 观察下面的加法算式： 祥 瑞生 辉 三羊 献 瑞-——————三 羊 生 瑞 气其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字。请你填写“三羊献瑞”所代表的4位数字（答案唯一），不要填写任何多余内容。 &emsp;&emsp;经典的蓝桥题目，直接暴力枚举就可以。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123;/* int xiang,rui,sheng,hui; int san,yang,xian,rui; int san,yang,sheng,rui,qi;*/ int xiang,rui,sheng,hui; int san,yang,xian; int qi; int a,b,c; for(xiang=1;xiang&lt;=9;++xiang)&#123; for(rui=0;rui&lt;=9;++rui)&#123; if(rui==xiang)continue; for(sheng=0;sheng&lt;=9;++sheng)&#123; if(sheng==xiang||sheng==rui)continue; for(hui=0;hui&lt;=9;++hui)&#123; if(hui==xiang||hui==rui||hui==sheng)continue; for(san=1;san&lt;=9;++san)&#123; if(san==xiang||san==rui||san==sheng||san==hui)continue; for(yang=0;yang&lt;=9;++yang)&#123; if(yang==xiang||yang==rui||yang==sheng||yang==hui||yang==san)continue; for(xian=0;xian&lt;=9;++xian)&#123; if(xian==xiang||xian==rui||xian==sheng||xian==hui||xian==san||xian==yang)continue; for(qi=0;qi&lt;=9;++qi)&#123; if(qi==xiang||qi==rui||qi==sheng||qi==hui||qi==san||qi==yang||qi==xian)continue; a=xiang*1000+rui*100+sheng*10+hui; b=san*1000+yang*100+xian*10+rui; c=san*10000+yang*1000+sheng*100+rui*10+qi; if(a+b==c)&#123; //printf(\"%d+%d=%d\\n\",a,b,c); printf(\"%d %d %d %d\\n\",san,yang,xian,rui); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; return 0;&#125; 第四题 格子中输出 格子中输出StringInGrid函数会在一个指定大小的格子中打印指定的字符串。要求字符串在水平、垂直两个方向上都居中。如果字符串太长，就截断。如果不能恰好居中，可以稍稍偏左或者偏上一点。下面的程序实现这个逻辑，请填写划线部分缺少的代码。对于题目中数据，应该输出：+——————+|&emsp;&emsp;&emsp;&emsp;&emsp;|| abcd1234 ||&emsp;&emsp;&emsp;&emsp;&emsp;||&emsp;&emsp;&emsp;&emsp;&emsp;|+——————+ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;void StringInGrid(int width, int height, const char* s)&#123; int i,k; char buf[1000]; strcpy(buf, s); if(strlen(s)&gt;width-2) buf[width-2]=0; printf(\"+\"); for(i=0;i&lt;width-2;i++) printf(\"-\"); printf(\"+\\n\"); for(k=1; k&lt;(height-1)/2;k++)&#123; printf(\"|\"); for(i=0;i&lt;width-2;i++) printf(\" \"); printf(\"|\\n\"); &#125; printf(\"|\"); printf(\"%*s%s%*s\",_____________________________________________); //填空 printf(\"|\\n\"); for(k=(height-1)/2+1; k&lt;height-1; k++)&#123; printf(\"|\"); for(i=0;i&lt;width-2;i++) printf(\" \"); printf(\"|\\n\"); &#125; printf(\"+\"); for(i=0;i&lt;width-2;i++) printf(\"-\"); printf(\"+\\n\"); &#125;int main()&#123; StringInGrid(20,6,\"abcd1234\"); return 0;&#125; 答案是： 1(width-strlen(buf)-2)/2,\"\",buf,(width-strlen(buf)-2+1)/2,\"\" &emsp;&emsp;C语言语法考题，太过于变态，基本没有做出来的。这道题不必深究。 第五题 九数组分数 九数组分数1,2,3…9 这九个数字组成一个分数，其值恰好为1/3，如何组法？下面的程序实现了该功能，请填写划线部分缺失的代码。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;void test(int x[])&#123; int a = x[0]*1000 + x[1]*100 + x[2]*10 + x[3]; int b = x[4]*10000 + x[5]*1000 + x[6]*100 + x[7]*10 + x[8]; if(a*3==b) printf(\"%d / %d\\n\", a, b);&#125;void f(int x[], int k)&#123; int i,t; if(k&gt;=9)&#123; test(x); return; &#125; for(i=k; i&lt;9; i++)&#123; &#123;t=x[k]; x[k]=x[i]; x[i]=t;&#125; f(x,k+1); _____________________________________________ // 填空处 &#125;&#125; int main()&#123; int x[] = &#123;1,2,3,4,5,6,7,8,9&#125;; f(x,0); return 0;&#125; &emsp;&emsp;水题，答案： 1&#123;t=x[k]; x[k]=x[i]; x[i]=t;&#125; 第六题 加法变乘法 我们都知道：1+2+3+… + 49 = 1225现在要求你把其中两个不相邻的加号变成乘号，使得结果为2015比如：1+2+3+…+10*11+12+…+27*28+29+…+49 =2015就是符合要求的答案。请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int i,j; int a,b; for(i=1;i&lt;=49;++i)&#123; for(j=i+2;j&lt;=49;++j)&#123; a=1225-(i+i+1)-(j+j+1); b=2015-(i*(i+1))-(j*(j+1)); if(a==b)&#123; printf(\"i=%d,j=%d\\n\",i,j); &#125; &#125; &#125; return 0;&#125; &emsp;&emsp;暴力枚举，枚举所有的可能的两个位置，用1225和2015分别减去这两个位置的值，看看是否相等。 第七题 牌型种数 小明被劫持到X赌城，被迫与其他3人玩牌。一副扑克牌（去掉大小王牌，共52张），均匀发给4个人，每个人13张。这时，小明脑子里突然冒出一个问题：如果不考虑花色，只考虑点数，也不考虑自己得到的牌的先后顺序，自己手里能拿到的初始牌型组合一共有多少种呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,aJ,aQ,aK; int sum=0; for(a1=0;a1&lt;=4;++a1)&#123; for(a2=0;a2&lt;=4;++a2)&#123; for(a3=0;a3&lt;=4;++a3)&#123; for(a4=0;a4&lt;=4;++a4)&#123; for(a5=0;a5&lt;=4;++a5)&#123; for(a6=0;a6&lt;=4;++a6)&#123; for(a7=0;a7&lt;=4;++a7)&#123; for(a8=0;a8&lt;=4;++a8)&#123; for(a9=0;a9&lt;=4;++a9)&#123; for(a10=0;a10&lt;=4;++a10)&#123; for(aJ=0;aJ&lt;=4;++aJ)&#123; for(aQ=0;aQ&lt;=4;++aQ)&#123; for(aK=0;aK&lt;=4;++aK)&#123; if(a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+aJ+aQ+aK==13)&#123; ++sum; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\",sum); return 0;&#125; &emsp;&emsp;当然，我们也可以用dfs来解决这道题。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int sum;void dfs(int cur,int tol)&#123; if(tol&gt;13) return; if(cur==14)&#123;//13种牌都拿完了 if(tol==13)&#123;//手里13张牌了 ++sum; &#125; return; &#125; int i; for(i=0;i&lt;=4;++i)&#123; dfs(cur+1,tol+i); &#125;&#125;int main()&#123; sum=0; dfs(1,0);//从第1张牌开始选，当前手中有0张 printf(\"%d\\n\",sum); return 0;&#125; 第八题 移动距离 X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3…当排满一行时，从下一行相邻的楼往反方向排号。比如：当小区排号宽度为6时，开始情形如下： 1 2 3 4 5 612 11 10 9 8 713 14 15 …..我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动）输入为3个整数w m n，空格分开，都在1到10000范围内w为排号宽度，m,n为待计算的楼号。要求输出一个整数，表示m n两楼间最短移动距离。例如：用户输入：6 8 2则，程序应该输出：4再例如：用户输入：4 7 20则，程序应该输出：5资源约定：峰值内存消耗","categories":[],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://www.z16388.top/tags/蓝桥杯/"}],"keywords":[]},{"title":"GJB5369考点笔记","slug":"GJB5369考点笔记","date":"2017-03-18T02:35:42.000Z","updated":"2017-04-13T13:25:20.920Z","comments":true,"path":"2017/03/18/GJB5369考点笔记/","link":"","permalink":"http://www.z16388.top/2017/03/18/GJB5369考点笔记/","excerpt":"","text":"启用规则 禁止使用嵌套的注释 建议不适用单行的注释“//” 禁止使用不适合的循环变量类型（循环变量类型应为int） 循环变量必须是局部声明的 谨慎使用无限循环语句 避免在循环中使用break语句 谨慎使用无法控制的循环条件 禁止对指针变量使用强制类型转换赋值 谨慎使用其他类型变量给指针赋值 避免使用不必要的类型转换 枚举元素的初始化必须完整 结构体变量初始化的类型必须一致 结构体变量初始化的嵌套结构必须与定义的相一致 变量使用前必须被赋过值 禁止对实数类型的量做是否相等的比较 禁止逻辑判别的表达式不是逻辑表达式 switch语句中的表达式禁止是逻辑表达式 建议逻辑表达式采用显式的表达 禁止枚举类型中的元素名与已有的变量名同名 禁止局部变量与全局变量同名 禁止形参名与全局变量名同名 禁止形参名与类型或标识符同名 禁止在内部块中重定义已有的变量名 禁止复杂表达式中使用volatile类型的变量 在源程序中谨慎使用非标准字符 禁止使用预处理操作符#和## 过程名禁止被重用 禁止过程或函数中的参数表为空 禁止在同一个宏中使用多个#或## 禁止定义不像函数的宏 禁止在宏中包含不允许的项 禁止重新定义保留字 字符型变量必须明确定义是有符号还是无符号 禁止对一个名字重新定义 用typedef自定义的类型禁止被重定义 禁止在同一个文件中有#if而没有#endif 禁止数组没有边界限定 标号名禁止被重用 禁止在#include&lt;&gt;中使用绝对的路径名 禁止结构体声明不完整 禁止结构体定义中含有空域 禁止声明多重标号 在过程声明中必须对参数说明 禁止过程参数只有类型没有标识符 禁止在过程参数表中使用省略号 禁止重新定义使用C或C++的关键字 建议使用typedef在统一的变量声明头文件中对基本的变量类型重新定义 避免将过程定义为参数 过程中避免使用过多的参数，建议不要超过20个 在结构体定义中谨慎使用位域 禁止在块中使用#define或#undef 谨慎使用#pragma 谨慎使用联合(union)的声明 在结构体中谨慎使用无名位域 main必须定义为int main(void)或int main(int,char*[])的形式 循环体必须用大括号括起来 then/else中的语句必须用大括号括起来 逻辑表达式的连接必须使用括号 禁止在头文件前有可执行的代码 宏参数必须用括号括起来 嵌入汇编程序的过程必须是纯汇编程序 头文件名禁止使用“‘”,”、”,”\\”和”#”等字符 禁止字符串中单独使用”\\”，字符串的终止必须使用”\\0” 建议一个文件中的程序总行不超过200行 建议一个过程或函数中的程序总行不超过200行 禁止条件判别成立时相应分支无可执行语句 在if…else if语句中必须使用else分支 禁止条件判别的else分支无可执行语句 在switch语句中必须使用default语句 禁止使用空switch语句 禁止switch语句中只包含defau语句 禁止switch的case语句不是由break终止 禁止switch的case语句中无任何可执行语句 禁止将参数指针赋值给过程指针 禁止将指针的指针超过两级 禁止将过程声明为指针类型 谨慎使用指针的逻辑比较 谨慎对指针进行代数运算 禁止直接从过程中跳出 禁止使用goto语句 避免使用setimp/longimp 禁止在非赋值表达式中出现赋值操作符 禁止对常数值做逻辑非的运算 禁止对有符号类型使用位运算 禁止对枚举类型的越限使用 禁止在逻辑表达式中使用赋值操作福 禁止赋值操作符与“&amp;&amp;”，“||”连用 禁止位操作符带有布尔型的操作数 禁止位操作符作用于布尔值 数组的使用必须保证不会出现越界 禁止对有符号的类型进行位运算 对变量进行位运算必须保证不会产生溢出 禁止给无符号变量赋负值 有符号类型的长度必须大于等于两位 位的定义必须是由符号整数或无符号整数 禁止给变量赋的值与变量的类型不一致 赋值类型必须匹配 避免使用逗号操作符 谨防长度操作符sizeof的副作用 谨慎使用不同类型变量的混合运算 避免由于设计的原因导致某些代码不能执行 主过程所在的文件中禁止有未被该文件中任何过程调用的子过程 static类型的过程在所在的文件中必须被调用 禁止使用被禁用的过程、函数、文件或名称 禁止用一个表达式中调用多个相关函数 禁止void类型的变量作为参数进行传递 禁止实参和形参类型不一致 避免过程参数在过程调用中未被使用 避免以非调用方式使用函数 谨慎使用abort，exit等函数 禁止单独使用小写字母”i”或大写字母”O”作为变量名 禁止三字母词的使用 使用八进制数必须加以注释 避免使用”+=”或”-=”操作符 谨慎使用”++”或”–”操作符 避免使用continue语句 谨慎使用三重表达式 避免使用不起作用的语句 避免使用空语句 谨慎使用寄存器变量 避免使用老的参数表的定义形式 函数必须有返回语句 禁止void类型的过程中的return语句带有返回值 有返回值的函数中，return必须带有返回值 函数返回类型必须一致","categories":[],"tags":[{"name":"GJB5369","slug":"GJB5369","permalink":"http://www.z16388.top/tags/GJB5369/"},{"name":"软件测试","slug":"软件测试","permalink":"http://www.z16388.top/tags/软件测试/"}],"keywords":[]},{"title":"【ACM教程】5.3单源最短路径Dijkstra算法","slug":"【ACM教程】5-3单源最短路径Dijkstra算法","date":"2017-03-15T08:46:18.000Z","updated":"2017-04-13T13:25:15.931Z","comments":true,"path":"2017/03/15/【ACM教程】5-3单源最短路径Dijkstra算法/","link":"","permalink":"http://www.z16388.top/2017/03/15/【ACM教程】5-3单源最短路径Dijkstra算法/","excerpt":"","text":"第三节 单源最短路径Dijkstra算法&emsp;&emsp;最短路径的问题在生活中是十分常见的。不仅仅是表面上的路程计算，网络中的数据传输什么的都能用到最短路径算法。我们在求最短路问题时，常用两种算法。Dijkstra单源最短路径算法和全源最短路径Floyd算法。首先对Dijkstra算法进行学习。 &emsp;&emsp;Dijkstra算法用于计算一个点到其他所有节点的最短路径，是比较有代表性的最短路径算法。数学的很多学科中，都会接触到。它的思路是：把所有的顶点分为两组，一组是已经知道最短路径的，然后从未知最短路径并与之相邻的顶点中选出一个最短的放进已知组里，直到将所有的点放入已知组，找到最短路。 &emsp;&emsp;举个例子，以下图为例，求A到F的最短路。 &emsp;&emsp;首先，已知点是A，然后我们去找和他相邻的，距离最短的点。这时我们看到C点距离A点是3，比B的6要短，所以我们将C点放入已知集合；然后看A、C相邻的点，最短的路径是C到B，所以把B点放入已知集合。就这样一直做下去，直到将所有点放入已知点集合为止。我们将上面的过程，记录在表格里。 步骤 已知点集 B C D E F 1 A 6 3 00 00 00 2 A、C 5 6 7 00 3 A、C、B 6 7 00 4 A、C、B、D 7 9 5 A、C、B、D、E 9 &emsp;&emsp;通过上面的步骤，我们将A到F的最短路找到了：A-C-D-F。除此之外，A到所有点的最短路我们都能够找到。那么，下面我们考虑用程序来实现这个过程。 1234567891011121314151617181920212223242526272829#define INF 0x0f0f0f0f //用INF来代替正无穷（+OO）#define N 1100int low[N]; //low[i]数组存放A号节点到已知集合中i号节点的最短距离int vis[N]; //vis[i] = 1表示i号节点已经在已知集合中，否则反之int cost[N][N],n;//cost[i][j]表示i节点到j节点的直接距离void Dijkstra(int start)&#123; int edge,k; for(int i = 1;i&lt;=n;i++)&#123;//这里是要初始化low[]数组和vis[]数组 low[i] = cost[start][i]; vis[i] = 0; &#125; vis[start] = 1; low[start] = 0; for(int i = 1;i&lt;=n-1;i++)&#123; edge = INF;//edge是已知集合到未知集合的最短边 for(int j = 1;j&lt;=n;j++)&#123;//这里是要找到一条最短边:编号k,边长edge if(vis[j]==0&amp;&amp;edge&gt;low[j])&#123; edge = low[j]; k = j; &#125; &#125; vis[k] = 1; for(int j = 1;j&lt;=n;j++)&#123;//更新得到的新节点k号节点发出去的边 if(vis[j]==0&amp;&amp;low[j] &gt; low[k] + cost[k][j])&#123; low[j] = low[k] + cost[k][j]; &#125; &#125; &#125;&#125; &emsp;&emsp;上面是Dijkstra算法的C语言实现，大家可以将其作为模板记录下来，以后可以直接使用。我们就以上图为例，练习一下Dijkstra算法的使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define INF 0x0f0f0f0f#define N 1100int low[N];int vis[N];int cost[N][N],n;void Dijkstra(int start)&#123; int edge,k; for(int i = 1;i&lt;=n;i++)&#123; low[i] = cost[start][i]; vis[i] = 0; &#125; vis[start] = 1; low[start] = 0; for(int i = 1;i&lt;=n-1;i++)&#123; edge = INF; for(int j = 1;j&lt;=n;j++)&#123; if(vis[j]==0&amp;&amp;edge&gt;low[j])&#123; edge = low[j]; k = j; &#125; &#125; vis[k] = 1; for(int j = 1;j&lt;=n;j++)&#123; if(vis[j]==0&amp;&amp;low[j] &gt; low[k] + cost[k][j])&#123; low[j] = low[k] + cost[k][j]; &#125; &#125; &#125;&#125;int main() &#123; memset(cost,INF,sizeof(cost)); n=6; cost[1][2]=6,cost[1][3]=3; cost[2][3]=2,cost[2][4]=5; cost[3][4]=3,cost[3][5]=4; cost[4][5]=2,cost[4][6]=3; cost[5][6]=5; Dijkstra(1); printf(\"%d\\n\",low[n]); return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】4.2动态规划初体验","slug":"【ACM教程】4-2动态规划初体验","date":"2017-03-14T12:42:34.000Z","updated":"2017-04-13T13:25:15.916Z","comments":true,"path":"2017/03/14/【ACM教程】4-2动态规划初体验/","link":"","permalink":"http://www.z16388.top/2017/03/14/【ACM教程】4-2动态规划初体验/","excerpt":"","text":"第二节 动态规划初体验&emsp;&emsp;在完成了动态规划概念的理解之后，我们来拿一道简单的题目理解一下问题的解决过程。 &emsp;&emsp;斐波那契数列F(n)。当n=1、2时，F(2)=F(1)=1;其他情况F(n)=F(n-1)+F(n-2)。我们发现，这是一个递归的过程，根据前面所学知识，不难写程序： 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int F(int n)&#123; if(n&lt;3) return 1; else return F(n-2)+F(n-1);&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); printf(\"%d\",F(1)); for(int i=2;i&lt;=n;i++) &#123; printf(\" %d\",F(i)); &#125; printf(\"\\n\"); return 0;&#125; &emsp;&emsp;但是，如果把这道题用在一道题目里，可能会造成超时。因为我们在每次运算中，都要把之前的所有情况都要再计算一遍，这会造成很多浪费。如果我们把每次运算的结果存放在数组里，那么在计算F(n)时，我们只需要在存放的结果中把需要的找出来，进行计算，在存进去。下面是改进的函数F：(假设n&lt;=1000) 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define N 1010using namespace std;int A[N];int F(int n)&#123; if(n&lt;3) return 1; if(A[n]) return A[n]; else return A[n]=F(n-1)+F(n-2);&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); memset(A,0,sizeof(A)); printf(\"%d\",F(1)); for(int i=2;i&lt;=n;i++) &#123; printf(\" %d\",F(i)); &#125; printf(\"\\n\"); return 0;&#125; &emsp;&emsp;当状态转移方程太过于复杂的时候，我们可以使用打表的方法——把所有的可能计算一遍，存在数组里。根据输入直接给出结果，实现方法如下： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;iostream&gt;#define N 1010using namespace std;long long A[N];void F()&#123; A[1]=1; A[2]=1; for(int i=3;i&lt;=1000;i++) &#123; A[i]=A[i-2]+A[i-1]; &#125;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); F(); printf(\"%d\",A[1]); for(int i=2;i&lt;=n;i++) printf(\" %d\",A[i]); printf(\"\\n\"); return 0;&#125; &emsp;&emsp;这是动态规划中的枚举法，比较暴力。水题可以尝试使用这种方法去做，但是比赛的时候，oj系统会有防止打表的机制。因此，这种方法最好不要去使用。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.z16388.top/tags/动态规划/"}],"keywords":[]},{"title":"【ACM教程】4.3下降非降子序列问题","slug":"【ACM教程】4-3下降非降子序列问题","date":"2017-03-07T12:04:26.000Z","updated":"2018-01-10T12:41:32.669Z","comments":true,"path":"2017/03/07/【ACM教程】4-3下降非降子序列问题/","link":"","permalink":"http://www.z16388.top/2017/03/07/【ACM教程】4-3下降非降子序列问题/","excerpt":"","text":"第三节 下降/非降子序列问题&emsp;&emsp;这种题目在ACM竞赛中，通常作为“水题”出现。但是水题不水，不了解动态规划的还是AC不了这种类型。我们将会在这一节中，学习解决这种类型题。 模型抽象&emsp;&emsp;子序列问题分为下降子序列问题和非降子序列问题，解决方法类似： 最长非降子序列问题：在一个无序序列a[1],a[2],…,a[n]中，找到一个最长的子序列满足： &emsp;a[i]&lt;=a[j]&lt;=…&lt;=a[m] &emsp;i&lt;j&lt;…&lt;m 最长下降子序列问题：在一个无序序列a[1],a[2],…,a[n]中，找到一个最长的子序列满足： a[i]&gt;a[j]&gt;…&gt;a[m] i&gt;j&gt;…&gt;m &emsp;&emsp;我们从动态规划的三要素入手，来分析这种问题是否能使用动态规划来解决：如果要找到一个长度为k的子序列，那么我们需要一个长度为k-1的满足条件的的序列，再判断第k个元素是否满足条件，这显然满足最优子结构。在考虑第i个元素时，只需要看前面的i-1个，满足无后效性。因此这类题目可以使用动态规划来解决。 &emsp;&emsp;下面我们来做一道经典的题目：hdu1257：最少拦截系统 &emsp;&emsp; 12","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.z16388.top/tags/动态规划/"}],"keywords":[]},{"title":"【ACM教程】4.1动态规划简介","slug":"【ACM教程】4-1动态规划简介","date":"2017-03-06T12:05:18.000Z","updated":"2017-04-13T13:25:15.909Z","comments":true,"path":"2017/03/06/【ACM教程】4-1动态规划简介/","link":"","permalink":"http://www.z16388.top/2017/03/06/【ACM教程】4-1动态规划简介/","excerpt":"","text":"第一节 动态规划简介基本概念&emsp;&emsp;动态规划（DP）是运筹学的一个分支，是求解决策过程最优化的数学方法。它将多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。在现实生活中，我们经常会使用到动态规划。例如求最短路径、库存管理、排序、装载等问题，用动态规划方法比用其他方法更加简便。 &emsp;&emsp;动态规划主要用于求解以时间划分阶段的动态过程问题。但是在一些与时间无关的问题中，我们可以人为地引入时间因素，把它视为多阶段决策过程，也可以使用动态规划来求解。 基本思想&emsp;&emsp;动态规划算法经常用于求解具有某种最优性的问题中。在这类问题里，可能会有很多的可行解。每个解都对应一个值，我们希望得到具有最优解的值。动态规划算法的思路与分治法类似，其具体的思想也是将问题分割成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 &emsp;&emsp;在使用分治法的过程中，有些子问题可能计算了多次。如果我们能够保存已经解决的子问题的答案，在需要的时候直接拿出来，这样就会节省很多时间。我们可以使用一个表来存放我们计算的子问题的结果，无论这个问题在以后是否会用到，只要它被计算过，我们就将它存入表格中。这就是动态规划的基本思想。 相关术语与性质&emsp;&emsp;首先，我们来介绍动态规划的三要素——阶段、状态和决策。 &emsp;&emsp;阶段：把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。 &emsp;&emsp;状态：状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。过程的状态通常可以用一个或一组数来描述，称为状态变量。一般，状态是离散的，但有时为了方便也将状态取成连续的。 &emsp;&emsp;决策：一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史。 &emsp;&emsp;在介绍决策时，我们提到了一个很重要的性质——无后效性。这是动态规划算法的的基本准则： &emsp;&emsp;我们要求状态具有下面的性质：如果给定某一阶段的状态，则在这一阶段以后过程中的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了；换句话说，过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性。 &emsp;&emsp;状态转移方程：给定k阶段状态变量x(k)的值后，如果这一阶段的决策变量一经确定，第k+1阶段的状态变量x(k+1)也就完全确定，即x(k+1)的值随x(k)和第k阶段的决策u(k)的值变化而变化，那么可以把这一关系看成(x(k)，u(k))与x(k+1)确定的对应关系，我们来用x(k+1)=Tk(x(k),u(k))表示。它展示了从k阶段到k+1阶段的状态转移规律，我们称之为状态转移方程。 &emsp;&emsp;由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合。允许策略集合中达到最优效果的策略称为最优策略。 &emsp;&emsp;最优化原理:作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略”。一个问题满足最优化原理也称其拥有最优子结构性质。最优性原理实际上是要求问题的最优策略的子策略也是最优。 理解&emsp;&emsp;综合前面的概念，如果我们把动态规划求解问题的过程比作工厂的生产线，那么阶段就是生产某个商品的不同环节，状态就是工件当前的状态，决策就是对工件进行的操作。之前对工件进行的操作只是在当时起效，我们可以在后面的过程中对它进行进一步的加工。不同阶段是对前面产品的一个小小的总结，由一个个过程，最终构成了最终的生产线。 &emsp;&emsp;一个状态经过一个决策变成了另外的一个状态，这个过程就是状态转移。而用来描述状态转移的方程就是状态转移方程。 适用范围&emsp;&emsp;虽然动态规划很强大，但是它并不是万能的，只能够解决多阶段决策最优化问题。一般在题目中，出现让你求最优解的就要考虑使用动态规划了。但是需要满足一下两个条件。 最优子结构（最优化原理） 无后效性 &emsp;&emsp;一个最优解，它的子问题的解也是最优解，我们就称这个问题具有最优子结构。那无后效性呢？就是在状态i求解时需要用到状态j，而求解j的时候需要k…当求解状态N的时候，需要用到i。那么这个时候就形成了一个环，无法求解了。 解题方法&emsp;&emsp;在判断题目可以使用动态规划解决之后，我们可以使用以下几种方法进行解题： 模型匹配法我们首先要考虑的就是这个方法了。分析题目，如果这个题目是我们之后讲到的模型，就可以直接套用； 三要素法确定题目中的三要素，从比较明显的入手，尝试解题； 规律法多计算出几组数据，试寻找他们之间的联系，建立方程； 边界条件法找到问题的边界条件，分析边界条件和与之邻接状态之间的联系。 放宽约束和增加约束对问题修改，增加或删除一些条件，以便于解题。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.z16388.top/tags/动态规划/"}],"keywords":[]},{"title":"【ACM教程】5.2图的存储方式","slug":"【ACM教程】5-2图的存储方式","date":"2017-03-06T11:03:14.000Z","updated":"2018-01-10T12:38:55.730Z","comments":true,"path":"2017/03/06/【ACM教程】5-2图的存储方式/","link":"","permalink":"http://www.z16388.top/2017/03/06/【ACM教程】5-2图的存储方式/","excerpt":"","text":"第二节 图的存储方式链表&emsp;&emsp;我们在第三章对数据结构的简单了解中学习了，图和树可以使用链表来进行存储。参考第六节 数据结构基础（2）树、二叉树和图。虽然链表能够很方便地，在逻辑上对图进行定义和运算，但是我们知道，在比赛中我们的时间是有限的。如果花大量的时间去构建一个模型，然后针对这个模型的各种运算进行编写会耗费大量的时间。这个时候，我们就需要一个简单的数学模型，来处理这些数据。 图的矩阵表示&emsp;&emsp;在数学上，我们经常用矩阵来表示一个图。我们知道，图是由它们的顶点和他们之间的邻接关系来唯一确定的。这个时候我们只需要两个矩阵，一个用来存放他们的定点，另一个来存放他们之间的关系。 &emsp;&emsp;举个例子：在上一节中，我们接触到了一个非常经典的七桥问题的图。 &emsp;&emsp;图中的三个点我们分别命名为： AB &emsp;&emsp;&emsp;DC &emsp;&emsp;这时，我们可以用一个矩阵V来表示这个图中的点。V={A,B,C,D}那怎么来表示他们之间的联系呢？我们用另一个矩阵M，如果两个点之间是相连的，我们就让m^ij=m^ji=1。如果它们之间没有联系，则m^ij=m^ji=inf。那么，M= A B C D A 0 1 inf 1 B 1 0 1 1 C inf 1 0 1 D 1 1 1 0 &emsp;&emsp;如果这是个有向图，我们可以根据行和列来确定出发和到达的定点；如果这是个对路径长度有要求的图，就比如在计算最短路径的时候，我们可以将矩阵中的数据改为两个点之间的距离。 &emsp;&emsp;在编程的时候，我们可以使用数组来存放这样的矩阵。既方便计算，也能够精确表示。在今后的学习中，我们大多数时候都会使用这种方法来表示和运算。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】5.1图论的基本概念","slug":"【ACM教程】5-1图论的基本概念","date":"2017-03-06T10:25:05.000Z","updated":"2017-04-13T13:25:15.929Z","comments":true,"path":"2017/03/06/【ACM教程】5-1图论的基本概念/","link":"","permalink":"http://www.z16388.top/2017/03/06/【ACM教程】5-1图论的基本概念/","excerpt":"","text":"第一节 图论的基本概念&emsp;&emsp;在前面的学习中，我们简单地接触到了树、图等图论知识的基础概念，在这一章中，我们将对图论做系统的研究。图论相关的知识是ACM中比较重要的一部分，在日常的软件设计中，也较为常用。 图论的历史&emsp;&emsp;图论是一门应用十分广泛、内容非常丰富的数学学科，也是近几十年来较为活跃的数学分支之一。它的起源很早，瑞士数学家欧拉在1736年解决了当时颇为有名的一个数学问题，即哥尼斯堡七桥问题，从而使他成为了图论的创始人。 &emsp;&emsp;七桥问题呢，就是在一个城市的中间，有一条河，河中有两个小岛。在两岸和小岛之间呢，有七座桥。我们需要找到一个路径，使得我们从这四块陆地的其中一个开始，通过每一座桥，并恰好回到起点。 &emsp;&emsp;欧拉为了解决七桥问题，将这个问题转化为了一个数学问题。他认为这种走法是否存在，与岛的形状、大小、以及桥的长短等因素都没有关系，重要的是陆地之间是否有桥联通。因此他用点表示陆地，线表示陆地间的桥梁，就得出了七桥问题的示意图。欧拉在1736年证明了这个路径是不存在的，并进行了进一步的推广得出了一个判别法则—，用于判别给定一个图是否可以走遍。 &emsp;&emsp;除此之外，我们在高中曾经学习过基尔霍夫电压定律。基尔霍夫在1847年运用图论解决了电路理论中求解联立方程组问题，并引入了“树”的概念，可惜在当时并没有受到重视。1857年，凯莱在研究饱和碳氢化合物时，发现了一族重要的图，称其为树，并利用树来计算其同分异构体的数目。 &emsp;&emsp;20世纪后，图论的应用渗透到了其他的很多领域，在计算机网络、博弈论等方面起到了重要的作用。它是组合数学的一个分支，和数值分析、拓扑学等有着密切的联系。比如对于基础的图论来说，它不需要有高深复杂的数学工具，只需要一些集合、二元关系与线性代数知识，结合一般的逻辑推理来解决问题。 图论简介&emsp;&emsp;这里我们讨论的图论并不是几何学上的图形，而是客观世界中，某些具体事物间相互联系的一个数学抽象。用点来表示事物，用边来表示关系。这种由定点及连接这些点的所有边组成的就是我们图论中的图。其中的点我们称为顶点，线称之为边。当边具有方向性时，图是有向图。（否则为无向图） &emsp;&emsp;图在研究现实问题时会经常使用到，比如在地图上找到一条能够最快到达目的地的线路。这都是我们今后将要学习的内容。 &emsp;&emsp;从一个顶点出发，如果存在一个路径，能够回到该顶点，我们称之为圈。没有圈的连通图称为树，树是特殊的图。在解决问题时，我们有时候需要将图转化为它的“生成树”再对问题进行处理。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"第七届蓝桥杯C/C++省赛B组题目详解","slug":"lanqiao7","date":"2017-02-21T11:36:29.000Z","updated":"2017-04-13T13:25:15.869Z","comments":true,"path":"2017/02/21/lanqiao7/","link":"","permalink":"http://www.z16388.top/2017/02/21/lanqiao7/","excerpt":"","text":"第一题 煤球数目 有一堆煤球，堆成三角棱锥形。具体：第一层放1个，第二层3个（排列成三角形），第三层6个（排列成三角形），第四层10个（排列成三角形），….如果一共有100层，共有多少个煤球？请填表示煤球总数目的数字。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 &emsp;&emsp;经过简单的分析，我们可以发现：第n层(n&gt;=2)的煤球个数为该层层数与上一层煤球数之和。所以易写出程序：1234567891011121314#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int c,last=0,res=0; for(c=1;c&lt;=100;c++) &#123; last=c+last; res+=last; &#125; printf(\"%d\\n\",res); return 0;&#125; &emsp;&emsp;最终结果为：171700. 第二题 生日蜡烛 某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。现在算起来，他一共吹熄了236根蜡烛。请问，他从多少岁开始过生日party的？请填写他开始过生日party的年龄数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 &emsp;&emsp;对于这样的填空题目，不需要考虑代码的时间复杂度，直接暴力求解即可（就算在草稿纸上计算也很容易算出来），类似于之前讲过的百钱百鸡问题。这道题目的解决代码如下：12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int start,year,l; for(start=1;start&lt;=236;start++) for(year=start;year&lt;=236;year++) &#123; int sum=0; for(l=start;l&lt;=year;l++)&#123; sum+=l; if(sum==236) &#123; printf(\"%d\\n\",start); return 0; &#125; &#125; &#125; return 0;&#125; &emsp;&emsp;最终结果为26. 第三题 凑算式 B DEFA + —— + ——— = 10 C GHI这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。比如：6+8/3+952/714 就是一种解法，5+3/1+972/486 是另一种解法。这个算式一共有多少种解法？注意：你提交应该是个整数，不要填写任何多余的内容或说明性文字。 &emsp;&emsp;这道题也可以使用暴力枚举的方法：12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c,d,e,f,g,h,i,res=0; double sum; for(a=1;a&lt;=9;a++) for(b=1;b&lt;=9;b++) &#123; if(a==b) continue; for(c=1;c&lt;=9;c++) &#123; if(c==a||c==b) continue; for(d=1;d&lt;=9;d++) &#123; if(d==a||d==b||d==c) continue; for(e=1;e&lt;=9;e++) &#123; if(e==a||e==b||e==c||e==d) continue; for(f=1;f&lt;=9;f++) &#123; if(f==a||f==b||f==c||f==d||f==e) continue; for(g=1;g&lt;=9;g++) &#123; if(g==a||g==b||g==c||g==d||g==e||g==f) continue; for(h=1;h&lt;=9;h++) &#123; if(h==a||h==b||h==c||h==d||h==e||h==f||h==g) continue; for(i=1;i&lt;=9;i++) &#123; if(i==a||i==b||i==c||i==d||i==e||i==f||i==g||i==h) continue; sum=a+(b*1.0)/c+(d*100.0+e*10.0+f)/(g*100.0+h*10.0+i); if(sum==10.0) res++; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\",res); return 0;&#125; &emsp;&emsp;最终结果为29。 &emsp;&emsp;在做这种需要对大规模变量进行枚举的题目时（每年蓝桥杯都会出现几道类似的题目），大家应当注意尽量减少循环次数。就像上面的代码，有很多跳出循环的操作。这样会很快得出结果，否则的话可能会花费很多的宝贵时间。 &emsp;&emsp;后来呢，我在网上看到了一种更加好的解法，学习了之后和大家分享一下。首先，原作者对这道题目的算式进行了通分，这样做的好处就是避免了数据类型的不同，使题目中只出现了int型一种。做法是在等式两边都乘以C*GHI这样每一项就都是整数了。 &emsp;&emsp;第二步，使用全排列函数。下面是这道题的简便算法的代码：1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]; int i; int sum[4]; int ans; for(i=1;i&lt;=9;++i)&#123; a[i]=i; &#125; ans=0; do&#123; sum[0]=a[1]*a[3]*(a[7]*100+a[8]*10+a[9]); sum[1]=a[2]*(a[7]*100+a[8]*10+a[9]); sum[2]=(a[4]*100+a[5]*10+a[6])*a[3]; sum[3]=10*a[3]*(a[7]*100+a[8]*10+a[9]); if(sum[0]+sum[1]+sum[2]==sum[3])&#123; ++ans; &#125; &#125;while(next_permutation(a+1,a+1+9)); printf(\"%d\\n\",ans); return 0;&#125; 第四题 快速排序 排序在各种场合经常被用到。快速排序是十分常用的高效率的算法。其思想是：先选一个“标尺”，用它把整个队列过一遍筛子，以保证：其左边的元素都不大于它，其右边的元素都不小于它。这样，排序问题就被分割为两个子区间。再分别对子区间排序就可以了。下面的代码是一种实现，请分析并填写划线部分缺少的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;void swap(int a[], int i, int j)&#123;int t = a[i];a[i] = a[j];a[j] = t;&#125;int partition(int a[], int p, int r)&#123;int i = p;int j = r + 1;int x = a[p];while(1)&#123;while(i&lt;r &amp;&amp; a[++i]&lt;x);while(a[--j]&gt;x);if(i&gt;=j) break;swap(a,i,j);&#125;______________________;return j;&#125;void quicksort(int a[], int p, int r)&#123;if(p&lt;r)&#123;int q = partition(a,p,r);quicksort(a,p,q-1);quicksort(a,q+1,r);&#125;&#125;int main()&#123;int i;int a[] = &#123;5,13,6,24,2,8,19,27,6,12,1,17&#125;;int N = 12;quicksort(a, 0, N-1);for(i=0; i&lt;N; i++) printf(\"%d \", a[i]);printf(\"/n\");return 0;&#125; 注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。 &emsp;&emsp;这道题目我在【ACM教程】3.7排序（一）中有过介绍，需要对快速排序有一定程度的理解不难得出需要填的内容为swap(a,p,j)。 第五题 抽签 X星球要派出一个5人组成的观察团前往W星。其中：A国最多可以派出4人。B国最多可以派出2人。C国最多可以派出2人。….那么最终派往W星的观察团会有多少种国别的不同组合呢？下面的程序解决了这个问题。数组a[] 中既是每个国家可以派出的最多的名额。程序执行结果为：DEFFFCEFFFCDFFFCDEFFCCFFFCCEFFCCDFFCCDEFBEFFFBDFFFBDEFFBCFFFBCEFFBCDFFBCDEF….(以下省略，总共101行) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#define N 6#define M 5#define BUF 1024void f(int a[], int k, int m, char b[])&#123;int i,j;if(k==N)&#123; b[M] = 0;if(m==0) printf(\"%s/n\",b);return;&#125;for(i=0; i&lt;=a[k]; i++)&#123;for(j=0; j&lt;i; j++) b[M-m+j] = k+'A';______________________; //填空位置&#125;&#125;int main()&#123;int a= &#123;4,2,2,1,1,3&#125;;char b[BUF];f(a,0,M,b);return 0;&#125; 仔细阅读代码，填写划线部分缺少的内容。注意：不要填写任何已有内容或说明性文字。 &emsp;&emsp;这道题目最容易出问题的地方在于对函数参数的把握，在循环次数控制等。我们可以很容易看出来，函数f()是一个递归的过程。其中，在已经给出的代码中已经有了跳出递归的条件，也就是说，需要我们补全的是递归的过程方程。 &emsp;&emsp;我们看，函数f共有4个参数。第一个参数是数组a[]，表示的是每个国家最多派的人数。而且在函数的内部没有对数组的操作，因此第一个参数不变；第二个参数是一个整型变量k，观察函数的内部，k为数组a[]的下标变量。因此k为当前操作的国家编号；第三个参数是整形变量m，观察到在主函数中传入的是派遣人数M。那么每派出几个人，下次传进去的参数都要减去相应的人数；第四个参数是一个字符数组b[]，用来存放每一次的结果。经过上面的分析，可以确定需要补填的内容为： 1f(a,k+1,m-j,b) 第六题 方格填数 如下的10个格子&emsp;+–+–+–+ | | | |+–+–+–+–+| | | | |+–+–+–+–+| | | |+–+–+–+（4*3的长方形，左上角和右下角分别缺少一个方格）填入0~9的数字。要求：连续的两个数字不能相邻。（左右、上下、对角都算相邻）一共有多少种可能的填数方案？请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 &emsp;&emsp;这道题目又是可以使用暴力枚举做出来的，去年比赛的时候想的太复杂了，没做出来，也是非常后悔。但是最好还是使用dfs，深度优先搜索算法去做。在这里，像前面那道题那样，利用全排列函数，再写一个判断用的函数判断数字是否连续就行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int a[10];/* 0 1 23 4 5 67 8 9*/bool judge()&#123; if(abs(a[0]-a[1])==1||abs(a[0]-a[5])==1||abs(a[0]-a[4])==1||abs(a[0]-a[3])==1)&#123; return false; &#125; if(abs(a[1]-a[2])==1||abs(a[1]-a[6])==1||abs(a[1]-a[5])==1||abs(a[1]-a[4])==1)&#123; return false; &#125; if(abs(a[2]-a[6])==1||abs(a[2]-a[5])==1)&#123; return false; &#125; if(abs(a[3]-a[4])==1||abs(a[3]-a[8])==1||abs(a[3]-a[7])==1)&#123; return false; &#125; if(abs(a[4]-a[5])==1||abs(a[4]-a[9])==1||abs(a[4]-a[8])==1||abs(a[4]-a[7])==1)&#123; return false; &#125; if(abs(a[5]-a[6])==1||abs(a[5]-a[9])==1||abs(a[5]-a[8])==1)&#123; return false; &#125; if(abs(a[6]-a[9])==1)&#123; return false; &#125; if(abs(a[7]-a[8])==1)&#123; return false; &#125; if(abs(a[8]-a[9])==1)&#123; return false; &#125; return true;&#125;int main()&#123; int i; int sum; for(i=0;i&lt;10;++i)&#123; a[i]=i; &#125; sum=0; do&#123; if(judge())&#123; ++sum; &#125; &#125;while(next_permutation(a,a+10)); printf(\"%d\\n\",sum); return 0;&#125; 第七题 剪邮票 如【图1.jpg】, 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连）比如，【图2.jpg】，【图3.jpg】中，粉红色所示部分就是合格的剪取。请你计算，一共有多少种不同的剪取方法。请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。 图1 图2 图3 &emsp;&emsp;这道题需要使用dfs去做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int dir[4] = &#123;1,-1,5,-5&#125;;int temp1[12] = &#123;1,2,3,4,6,7,8,9,11,12,13,14&#125;;int temp2[5];int vis[5];int ans = 0;void dfs(int u)&#123; for(int i=0 ;i&lt;4 ;i++)&#123; int t = temp2[u]+dir[i]; if(t&gt;=1&amp;&amp;t&lt;=14)&#123; for(int j=0 ;j&lt;5 ;j++) if(t==temp2[j]&amp;&amp;!vis[j])&#123; vis[j]=1; dfs(j); &#125; &#125; &#125;&#125;int main()&#123; for(int a=0 ;a&lt;12 ;a++)&#123; for(int b=a+1 ;b&lt;12 ;b++)&#123; for(int c=b+1 ;c&lt;12 ;c++)&#123; for(int d=c+1 ;d&lt;12 ;d++)&#123; for(int e=d+1 ;e&lt;12 ;e++)&#123; temp2[0]=temp1[a]; temp2[1]=temp1[b]; temp2[2]=temp1[c]; temp2[3]=temp1[d]; temp2[4]=temp1[e]; //初始化访问标记数组 memset(vis,0,sizeof(vis)); vis[0]=1; dfs(0); //连通性判断 int flag = 1; for(int i=0 ;i&lt;5 ;i++)&#123; if(vis[i]==0)&#123; flag = 0; &#125; &#125; if(flag)ans++; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125; 第八题 四平方和&emsp;&emsp;每年的最后三道题都是大题。大题是得省一的关键。能够保证前面的正确率的同时，如果能够A一道大题省一就基本没有问题了。 四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多4个正整数的平方和。如果把0包括进去，就正好可以表示为4个数的平方和。比如：5 = 0^2 + 0^2 + 1^2 + 2^27 = 1^2 + 1^2 + 1^2 + 2^2（^符号表示乘方的意思）对于一个给定的正整数，可能存在多种平方和的表示法。要求你对4个数排序：0 &lt;= a &lt;= b &lt;= c &lt;= d并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法程序输入为一个正整数N (N&lt;5000000)要求输出4个非负整数，按从小到大排序，中间用空格分开例如，输入：5则程序应该输出：0 0 1 2再例如，输入：12则程序应该输出：0 2 2 2再例如，输入：773535则程序应该输出：1 1 267 838资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 3000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。 &emsp;&emsp;这道题可以通过枚举法暴力求解： 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAXN 2300int flag=0;int main()&#123; int n; scanf(\"%d\",&amp;n); for(int i=0;i&lt;MAXN;i++)&#123; if(i*i&lt;=n) for(int j=i;j&lt;MAXN;j++)&#123; if(i*i+j*j&lt;=n) for(int k=j;k&lt;MAXN;k++)&#123; int l=(int)sqrt(n-i*i-j*j-k*k); if(i*i+j*j+k*k+l*l==n)&#123; printf(\"%d %d %d %d\",i,j,k,l); return 0; &#125; &#125; &#125; &#125; return 0;&#125; 第九题 交换瓶子 有N个瓶子，编号 1 ~ N，放在架子上。比如有5个瓶子：2 1 3 5 4要求每次拿起2个瓶子，交换它们的位置。经过若干次后，使得瓶子的序号为：1 2 3 4 5对于这么简单的情况，显然，至少需要交换2次就可以复位。如果瓶子更多呢？你可以通过编程来解决。输入格式为两行：第一行: 一个正整数N（N&lt;10000）, 表示瓶子的数目第二行：N个正整数，用空格分开，表示瓶子目前的排列情况。输出数据为一行一个正整数，表示至少交换多少次，才能完成排序。例如，输入：53 1 2 5 4程序应该输出：3再例如，输入：55 4 3 2 1程序应该输出：2资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include ， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。 第十题 最大比例 最大比例X星球的某个大奖赛设了M级奖励。每个级别的奖金是一个正整数。并且，相邻的两个级别间的比例是个固定值。也就是说：所有级别的奖金数构成了一个等比数列。比如：16,24,36,54其等比值为：3/2现在，我们随机调查了一些获奖者的奖金数。请你据此推算可能的最大的等比值。输入格式：第一行为数字N，表示接下的一行包含N个正整数第二行N个正整数Xi(Xi","categories":[],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://www.z16388.top/tags/蓝桥杯/"}],"keywords":[]},{"title":"VPS笔记","slug":"VPS笔记","date":"2017-01-22T13:28:47.000Z","updated":"2017-04-13T13:25:15.880Z","comments":true,"path":"2017/01/22/VPS笔记/","link":"","permalink":"http://www.z16388.top/2017/01/22/VPS笔记/","excerpt":"","text":"&emsp;&emsp;登录： 1ssh root@ip &emsp;&emsp;安装可视化管理面板AMH 登录 运行脚本 1wget http://amysql.com/file/AMH/4.2/amh.sh; chmod 775 amh.sh; ./amh.sh 2&gt;&amp;1 | tee amh.log; 根据安装步骤提醒键入相应内容，完成安装 使用ip和配置的端口进行访问，例如http://ip:8888 &emsp;&emsp;ShadowsocksR一键安装脚本安装123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 卸载1./shadowsocksR.sh uninstall 其他操作12345678启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status配置文件路径：/etc/shadowsocks.json日志文件路径：/var/log/shadowsocks.log代码安装目录：/usr/local/shadowsocks","categories":[],"tags":[{"name":"VPS","slug":"VPS","permalink":"http://www.z16388.top/tags/VPS/"}],"keywords":[]},{"title":"【ACM教程】3.7排序（一）","slug":"【ACM教程】3-7排序（一）","date":"2017-01-18T03:25:23.000Z","updated":"2017-04-13T13:25:15.900Z","comments":true,"path":"2017/01/18/【ACM教程】3-7排序（一）/","link":"","permalink":"http://www.z16388.top/2017/01/18/【ACM教程】3-7排序（一）/","excerpt":"","text":"第七节 排序（一）&emsp;&emsp;我们在写程序的时候，经常需要去进行排序这种操作。在面对大量数据进行排序的时候，我们可能需要花费很多的时间和资源。因此，优化排序算法是我们在优化程序中的一个重要步骤。在我们前面的学习中，我们已经接触到了C++的STL中sort()函数。那么，在无法使用STL的情况或者是需要一些特殊的要求的排序，我们就需要对排序算法进行手撸。因此，掌握各种常见的排序方法极为重要。接下来，我们将会从冒泡排序开始，系统地对常见的排序算法进行练习。 冒泡排序（Bubble Sort）&emsp;&emsp;我们早在学习C语言的时候，就已经接触到这种排序方法了，是一种非常简便的排序方法。我们依次比较相邻的两个元素，以达到排序的目的。冒泡排序的运作方式如下： 重复走访所要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们相互交换如果这个数列一共有n个元素，我们需要进行n-1组比较，每一组需要进行n-i次比较 &emsp;&emsp;下面是冒泡排序的C语言代码： 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int a[15]; int n=10,i,j,t; for(i=0;i&lt;n;i++) a[i]=10-i; for(i=1;i&lt;n;i++) for(j=0;j&lt;n-i;j++) //这里可以记作i+j=n; sif(a[j]&gt;a[j+1]) &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; for(i=0;i&lt;n;i++) printf(\"%d \",a[i]); printf(\"\\n\"); return 0;&#125; &emsp;&emsp;冒泡排序是一种常用的排序方法，但是它的时间复杂度为O(n^2)，在做题时不推荐使用。 快速排序（Quick Sort）&emsp;&emsp;快速排序是对冒泡排序的一种改进，它的基本思想和冒泡排序类似： 通过一趟排序将序列分成两部分保证左侧部分的数据都比右侧的小再分别对两侧进行排序 &emsp;&emsp;快速排序是排序算法中的优等生，它的时间复杂度为O(logn)，但是要到达了最不理想的状态，也就是针对一个完全反序的数列进行排序。这个时候，它就变成了冒泡排序，时间复杂度为O(n^2)。在去年的蓝桥杯比赛中，就成为了一道代码填空题，题目是这样的： 排序在各种场合经常被用到。 快速排序是十分常用的高效率的算法。 其思想是：先选一个“标尺”， 用它把整个队列过一遍筛子， 以保证：其左边的元素都不大于它，其右边的元素都不小于它。 这样，排序问题就被分割为两个子区间。 再分别对子区间排序就可以了。 下面的代码是一种实现，请分析并填写划线部分缺少的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;void swap(int a[], int i, int j)&#123; int t = a[i]; a[i] = a[j]; a[j] = t;&#125;int partition(int a[], int p, int r)&#123; int i = p; int j = r + 1; int x = a[p]; while(1)&#123; while(i&lt;r &amp;&amp; a[++i]&lt;x); while(a[--j]&gt;x); if(i&gt;=j) break; swap(a,i,j); &#125;______________________;return j;&#125;void quicksort(int a[], int p, int r)&#123; if(p&lt;r)&#123; int q = partition(a,p,r); quicksort(a,p,q-1); quicksort(a,q+1,r); &#125;&#125;int main()&#123; int i; int a[] = &#123;5,13,6,24,2,8,19,27,6,12,1,17&#125;; int N = 12; quicksort(a, 0, N-1); for(i=0; i&lt;N; i++) printf(\"%d \", a[i]); printf(\"/n\"); return 0;&#125; 注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。 &emsp;&emsp;这里的答案是swap(a,p,j)，我们就以上面的例子来简单地描述一下快速排序。首先我们看，这个程序中有四个函数，swap()函数实现的是值交换，main()是声明了一个数组，然后对他进行快速排序然后打印出来，我们就不多说了。现在我们来看一下quicksort这个函数。这个函数就是用来实现我们在前面描述过的“分别对两个子区间进行快速排序”这个过程，也比较简单。比较让人头疼就是要我们填空的这个partition()函数。 &emsp;&emsp;下面就让我们来回忆一下快速排序的方法。快速排序就是找一个标尺（一般是一段序列的第一个），比他大的放在他左边，比他小的放在他右边。那么程序上是怎么实现的呢？ &emsp;&emsp;我们需要在程序中定义两个指针，分别从序列的两端出发，左侧的指针向右寻找比标尺大的数据，右侧的指针向左寻找比标尺小的数据，但是在实现上，有两种方法。第一种：先从右侧出发，找到第一个比标尺小的数据，将其和标尺交换位置。然后从左侧出发，找到第一个比标尺大的数据，交换位置，直到两标尺相遇。但是这种方法会频繁地使用赋值操作，那么还有一种改进思路：我们让标尺在a[0]的位置不动，将a[1]作为左侧指针的出发点。两指针分别从左右出发，找到相应的数据之后对两个数据交换位置，直到两个指针相遇。之后再把标尺放在正确的位置上，完成排序。而这个正确的位置呢，就是两指针相遇的位置。 &emsp;&emsp;在partition()函数中，有三个参数，第一个参数i,j,x。i作为low指针，j作为high指针，而x即是标尺。我们看在函数中，i初始化为标尺的位置后，在下面的while循环里，使用的是++i。这就保证了标尺是不移动的，也就是说这个程序使用的是第二种思路。仔细阅读代码，我们可以发现，函数中缺少的正是最后一步——将标尺移动到正确的位置。所以需要补填的代码是swap(a,p,j)。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"2017新年祝福","slug":"2017","date":"2016-12-31T16:16:10.000Z","updated":"2017-04-13T13:25:20.963Z","comments":true,"path":"2017/01/01/2017/","link":"","permalink":"http://www.z16388.top/2017/01/01/2017/","excerpt":"","text":"&emsp;&emsp;2016已经成为了过去式，新的一年已经来临。过去的一年里，无论有多少收获，2017，我们都会遇到一个新的自己。祝大家在新的一年里，能够距离自己的目标更进一步，保持自己的信心，继续前进。无论结果如何，这都会是我们人生中最精彩的一年——今年。 &emsp;&emsp;2017，要实训，要考研，要学习日语，要加强算法的练习，完善ACM的教程，要增进刀塔的技术… &emsp;&emsp;我们笑着送走2016，2017，也会是快乐的一年。","categories":[],"tags":[{"name":"心情","slug":"心情","permalink":"http://www.z16388.top/tags/心情/"}],"keywords":[]},{"title":"hdu1326,hdu2088","slug":"hdu1326-hdu2088","date":"2016-11-16T12:06:16.000Z","updated":"2017-04-13T13:25:20.911Z","comments":true,"path":"2016/11/16/hdu1326-hdu2088/","link":"","permalink":"http://www.z16388.top/2016/11/16/hdu1326-hdu2088/","excerpt":"","text":"&emsp;&emsp;这两道是同一道题，只是区别在输出格式。 &emsp;&emsp;算出需要移动的方块个数（相差平均数的总个数）即可，需要注意的是每两个输出之间有一个空行。 &emsp;&emsp;2088就比较套路，最后一组输出没有空行。 hdu1326 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 55int a[N];using namespace std;int main()&#123; int n,flag=0,ave,sum; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; ave=0,sum=0; memset(a,0,sizeof(a)); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); ave+=a[i]; &#125; ave/=n; for(int i=1;i&lt;=n;i++) &#123; if(a[i]&lt;ave) &#123; sum+=ave-a[i]; &#125; &#125; printf(\"Set #%d\\n\",++flag); printf(\"The minimum number of moves is %d.\\n\\n\",sum); &#125; return 0;&#125; hdu 2088 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define N 55int a[N];using namespace std;int main()&#123; int n,ave,sum,flag=0; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; ave=0,sum=0; if(flag++) printf(\"\\n\"); memset(a,0,sizeof(a)); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); ave+=a[i]; &#125; ave/=n; for(int i=1;i&lt;=n;i++) &#123; if(a[i]&lt;ave) &#123; sum+=ave-a[i]; &#125; &#125; printf(\"%d\\n\",sum); &#125; return 0;&#125;","categories":[],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://www.z16388.top/tags/hdu/"},{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"}],"keywords":[]},{"title":"hdu1720 A+B Coming","slug":"hdu1720","date":"2016-11-16T11:32:29.000Z","updated":"2017-04-13T13:25:20.904Z","comments":true,"path":"2016/11/16/hdu1720/","link":"","permalink":"http://www.z16388.top/2016/11/16/hdu1720/","excerpt":"","text":"&emsp;&emsp;这是一道简单的输入输出问题，把输入当做十六进制，计算和并按照十进制输出即可。 &emsp;&emsp;以下是C和C++两种做法： 1234567891011#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; while(scanf(\"%x%x\",&amp;a,&amp;b)!=EOF) &#123; printf(\"%d\\n\",a+b); &#125; return 0;&#125; 123456789101112#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() &#123; int a,b; while(cin&gt;&gt;hex&gt;&gt;a&gt;&gt;b) &#123; cout&lt;&lt;a+b&lt;&lt;endl; &#125; return 0; &#125;","categories":[],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://www.z16388.top/tags/hdu/"},{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"}],"keywords":[]},{"title":"ACM Steps","slug":"Steps","date":"2016-11-16T11:06:30.000Z","updated":"2017-04-13T13:25:20.828Z","comments":true,"path":"2016/11/16/Steps/","link":"","permalink":"http://www.z16388.top/2016/11/16/Steps/","excerpt":"","text":"&emsp;&emsp;hdu里的题目，题目量大，种类多，很多人用，同时也不方便找对应难度的试题。只知道水题都在11页，那么其他的题目都该怎么刷呢。 &emsp;&emsp;其实hdu有一个比较隐蔽的功能叫做ACM Steps，按照难度将题目随机分配出来的，难度相近，全部做完才能进入下一关，比较适合练习。 链接：http://acm.hdu.edu.cn/game(需要登录) 第一章： A+B 输入输出，快速幂，排序，ascii问题","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】3.6数据结构基础（2）树、二叉树和图","slug":"【ACM教程】3-6数据结构基础（2）树、二叉树和图","date":"2016-11-16T06:49:28.000Z","updated":"2017-04-13T13:25:15.899Z","comments":true,"path":"2016/11/16/【ACM教程】3-6数据结构基础（2）树、二叉树和图/","link":"","permalink":"http://www.z16388.top/2016/11/16/【ACM教程】3-6数据结构基础（2）树、二叉树和图/","excerpt":"","text":"第六节 数据结构基础（2）树、二叉树和图&emsp;&emsp;我们之前讲了数据结构中的几个线性结构，链表、栈还有队列。那么如果想要一个能表示多个元素之间关系的数据结构，就要使用我们的树形结构和图了。在ACM和蓝桥杯的比赛中，有关树和图的题目是百分百出现的。 树&emsp;&emsp;树形结构是一类非常重要的非线性数据结构，其中以树和二叉树最为常用。树结构在客观世界中广泛存在，比如我们日常生活中常见的组织结构图： &emsp;&emsp;树是n个结点的有限集合，在任意一棵非空的树中： 有且仅有一个特定的，称为根（Root）的结点 当n&gt;1时，其余结点可分别为m（m&gt;0）个互不相交的有限集合T1,T2,…,Tm，其中每一个集合本身又是一棵树，并且称为根的子树 &emsp;&emsp;以上就是一棵树的定义。 &emsp;&emsp;结点的子树称为它的“孩子”，相应地，该节点称为“双亲”。同一个双亲的孩子称为“兄弟”。孩子的数量称为“度”。 &emsp;&emsp;规定根为第一层，它的孩子为第二层，以此类推。树中最大的层数称为树的深度或高度。 &emsp;&emsp;森林：m（m&gt;0）课互不相交的树的集合。 二叉树&emsp;&emsp;二叉树的定义和性质&emsp;&emsp;在讨论一般树的存储结构及操作之前，我们首先研究一种名为二叉树的抽象数据结构类型。 &emsp;&emsp;二叉树是另一种树形结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点）。并且，二叉树的子树左右之分，其次序不能任意颠倒。 &emsp;&emsp;下面是二叉树的一些性质： 在二叉树的第i层上至多有2^(i-1)个结点（i&gt;=1）；可以使用数学归纳法来证明 深度为k的二叉树至多有2^k-1个结点（k&gt;=1）；由第一个性质推导 对任何一棵二叉树T，若其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。 … &emsp;&emsp;二叉树的存储结构&emsp;&emsp;二叉树的概念和性质不是我们研究的主要问题，我们来看一下二叉树的存储结构。二叉树可以使用顺序存储结构和链式存储结构，这里我们先讲一下顺序存储结构。 &emsp;&emsp;我们规定，用一组地址连续的存储单元，自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存放在一维数组下表为i（i-1）的分量中。对于一般的二叉树，则应该将其每个节点与完全二叉树相对照，存放在一维数组中。其中0表示不存在此结点。（想想我们之前讲过的memset函数） &emsp;&emsp;链式存储可以使用拥有两个指针域或者三个指针域的链表来表示，这里要看我们对这个二叉树的操作需求。如果需要返回访问根节点，则需要三个指针域。结合下面的内容，理解一下。 &emsp;&emsp;lchild&emsp;&emsp;data&emsp;&emsp;rchild&emsp;&emsp;lchild&emsp;&emsp;data&emsp;&emsp;parent&emsp;&emsp;rchild &emsp;&emsp;二叉树的遍历和线索二叉树&emsp;&emsp;在二叉树的一些应用中，我们常常要求在树种查找具有某种特征的结点，或者对树中全部结点做统一处理，我们就要对二叉树进行遍历。遍历就是按照某条搜索路径巡访树中的每个节点，就比如我们要输出的时候。对于一个线性结构，比如说数组，我们进行遍历就很方便，但是二叉树就比较复杂了。下面我们介绍三种操作方法： 先序遍历： 访问根节点 先序遍历左子树 先序遍历右子树 中序遍历： 中序遍历左子树 访问根节点 中序遍历右子树 后序遍历： 后序遍历左子树 后序遍历右子树 访问根节点 &emsp;&emsp;我们知道，二叉树的遍历是以一定的规则将其排列成一个线性结构，但是当以二叉链表作为存储结构时，我们只能找到结点的左右孩子信息，而不能找到结点在任一序列中的前驱和后继。这种信息只有在动态的过程中才能够得到。那么想要保存的话，我们需要在每个节点上再加两个指针域用来存放结点的前驱和后继的信息。 &emsp;&emsp;lchild&emsp;&emsp;LTag&emsp;&emsp;data&emsp;&emsp;RTag&emsp;&emsp;rchild &emsp;&emsp;以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索二叉链表，对某种次序遍历使其变成线索二叉树的过程叫做线索化。 图&emsp;&emsp;图的定义&emsp;&emsp;图是较线性表和树更为复杂的数据结构。在图结构中，结点之间的关系是任意的——图中任意两个元素都有可能相关。图中的数据元素称为定点（Vertex），VR是表示两个点之间的关系的集合,是VR中的元素，表示的是从v到w的的一条弧（Arc）。v为初始点（弧尾），w为终端点（弧头），此时的图称为有向图。如果对任意的都有，则用无序队（v,w）来代替这个有序对，表示v和w之间的一条边，此时的图为无向图。 &emsp;&emsp;有关图的问题还有很多，在数学上，我们专门有一门研究图的学科，叫做图论，这也将是接下来我们的研究对象。在今后的学习中，我们可能会接触到以下内容： &emsp;&emsp;图的存储方法&emsp;&emsp;图的遍历&emsp;&emsp;&emsp;&emsp;深度优先搜索（dfs）&emsp;&emsp;&emsp;&emsp;广度优先搜索（bfs）&emsp;&emsp;图的连通性&emsp;&emsp;克鲁斯卡尔算法 &emsp;&emsp;最短路径&emsp;&emsp;&emsp;&emsp;单源最短路径&emsp;&emsp;迪杰斯特拉算法 &emsp;&emsp;&emsp;&emsp;多源最短路径&emsp;&emsp;普里姆算法","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】3.5常用C++容器vector,set和map","slug":"【ACM教程】3-5常用C++容器vector,set和map","date":"2016-11-13T11:44:37.000Z","updated":"2017-04-13T13:25:15.898Z","comments":true,"path":"2016/11/13/【ACM教程】3-5常用C++容器vector,set和map/","link":"","permalink":"http://www.z16388.top/2016/11/13/【ACM教程】3-5常用C++容器vector,set和map/","excerpt":"","text":"第五节 常用C++容器vector，set和map&emsp;&emsp;上一节我们介绍了一些简单的数据结构，大家只要理解概念就可以了，为下面的概念和模型打下基础。这一节，我们讲一讲C++中一些常用的容器。就像之前的list，stack一样，能给我们写程序带来很大的帮助。 vector&emsp;&emsp;动态数组（vector）是比较常用的容器之一，它的用法和数组类似，但是大小不确定。在我们对它的值进行更改的时候，它的大小也会变化。它的声明方法和数组类似： 1vector&lt;int&gt; v; &emsp;&emsp;push_back()可以在结尾添加元素： 123v.push_back(1);v.push_back(2);v.push_back(3); &emsp;&emsp;vector可以和数组一样通过下标来访问。下标也是从0开始的： 1print(\"%d %d %d\\n\",v[0],v[1],v[2]); &emsp;&emsp;v.begin()和v.end()返回的是两个指针，分别指向vector的第一个元素和最后一个元素。 &emsp;&emsp;和我们之前讲过的list一样，vector也可以使用迭代器： 1234vector&lt;int&gt; v; vector&lt;int&gt;::iterator it; for(it=v.begin();it!=v.end();it++) printf(\"%d \",*it); &emsp;&emsp;我们来做一道练习题吧，hdu2561，思路很简单，我们用vector来存放数据，sort()排序之后输出。在输出完一组数据之后，我们应该使用clear()来清空容器。AC代码如下： 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int c,n,t; vector&lt;int&gt; v; scanf(\"%d\",&amp;c); while(c--) &#123; scanf(\"%d\",&amp;n); while(n--) &#123; scanf(\"%d\",&amp;t); v.push_back(t); &#125; sort(v.begin(),v.end()); printf(\"%d\\n\",v[1]); v.clear(); &#125; return 0;&#125; &emsp;&emsp;除此之外，还有一些常用的函数： front() back() 返回首尾元素的引用。empty() 是否为空size() 元素的个数pop_back() 删除容器中最后一个元素clear() 删除所有元素erase(iterator it) 删除迭代器指向的的元素 set&emsp;&emsp;set被称为集合类，存放的元素会按照大小自动排序，但是不能有重复的元素。如果想要存放重复的元素，应该使用multiset。 &emsp;&emsp;声明、初始化和迭代器等： 12345678set&lt;int&gt; set01; set&lt;int&gt;::iterator it; set01.insert(3); set01.insert(1); set01.insert(1); for(it01=set.begin();it!=set.end();it++) printf(\"%d \",*it); return 0; &emsp;&emsp;正如它的名字，在处理集合之类的问题的时候我们可以使用。可以看这道题：hdu1412。同一个set存储连个数据，不仅实现了相同元素的排除还排好了序。在输出一组结果之后，应该使用clear()来清空容器。下面是AC代码： 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main()&#123; int i,n,m,t; set&lt;int&gt; st; set&lt;int&gt;::iterator it; while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF) &#123; for(i=0;i&lt;n+m;i++) &#123; scanf(\"%d\",&amp;t); st.insert(t); &#125; for(it=st.begin();it!=st.end();) &#123; printf(\"%d\",*it); printf(\"%c\",(++it)==st.end()?'\\n':' '); &#125; st.clear(); &#125; return 0;&#125; empty() 是否为空size() 元素的个数erase(iterator it) 删除迭代器指向的的元素 map&emsp;&emsp;map称为映射，元素成对出现。，前面的称为关键字，后面是关键字对应的值。映射中的元素会按照key的大小自动排序。map是单映射，key和value是一对一的关系。如果想要实现多映射就要使用multimap。 &emsp;&emsp;声明、初始化 1234567map&lt;int,string&gt; map01; pair&lt;int,string&gt;p1(1,\"这是1\"); pair&lt;int,string&gt;p2(2,\"这是2\"); pair&lt;int,string&gt;p3(3,\"这是3\"); map01.insert(p1); map01.insert(p2); map01.insert(p3); &emsp;&emsp;除此之外，我们还可以使用赋值的方法来进行初始化，但是仅限于单映射。 123map01[5]=25;map01[3]=9;map01[4]=16; &emsp;&emsp;begin()和end()返回的是两个指针，分别指向map的第一个元素和最后一个元素。如果需要访问映射中的元素，需要使用迭代器： 1234567map&lt;int,int&gt; map01; map&lt;int,int&gt;::iterator it01; map01[5]=25; map01[3]=9; map01[3]=10; for(it01=map01.begin();it01!=map01.end();it01++) printf(\"Key:%d Value:%d\\n\",(*it01).first(*it01).second); &emsp;&emsp;下面做一道练习题：(hdu2550)[http://acm.hdu.edu.cn/showproblem.php?pid=2550] 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;int main()&#123; map&lt;int,int&gt; mp; map&lt;int,int&gt;::iterator it; int t,n,key,value,i,j; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d\",&amp;n); while(n--) &#123; scanf(\"%d%d\",&amp;key,&amp;value); mp[key]=value; &#125; for(it=mp.begin();it!=mp.end();it++) &#123; for(i=0;i&lt;(*it).second;i++) &#123; printf(\"&gt;+\"); for(j=0;j&lt;(*it).first-2;j++) printf(\"-\"); printf(\"+&gt;\\n\"); &#125; printf(\"\\n\"); &#125; mp.clear(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】3.4数据结构基础（1）栈、队列和链表","slug":"【ACM教程】3-4数据结构基础（1）栈、队列和链表","date":"2016-11-11T08:43:29.000Z","updated":"2017-04-13T13:25:15.897Z","comments":true,"path":"2016/11/11/【ACM教程】3-4数据结构基础（1）栈、队列和链表/","link":"","permalink":"http://www.z16388.top/2016/11/11/【ACM教程】3-4数据结构基础（1）栈、队列和链表/","excerpt":"","text":"第四节 数据结构基础（1）栈，队列和链表&emsp;&emsp;接下来的章节会介绍简单的数据结构，包括线性表（栈、队列、链表等）、二叉树和图。这些这些内容可能在我们今后要学习的算法中经常出现，都是需要去掌握的概念和内容。如果数据结构的基础没有打好，那么我们就很难设计出准确、高效的算法。 &emsp;&emsp;这一节我们要介绍三个基础的概念，栈、队列和链表。他们是最简单、最基础，同时也是最常用的数据结构。他们同属于线性表：n（n&gt;=0）个具有相同属性（数据类型一致）的数据元素的有限序列。我们之前学习过的数组，就是经常用来记录线性表的一种常用工具。 栈（Stack）&emsp;&emsp;栈是一种运算受到限制的线性表，它的插入和删除操作都只能在同一端进行。如果非要在生活中举个例子的话，那么栈的话，就像是一桶薯片。无论是拿出一片还是放进去一片，都只能从一个口里进行。这个口我们称之为栈顶（Top）。这样的规定会让先进去的元素后出来，我们称之为先进后出。（FILO） &emsp;&emsp;向栈顶插入新元素成为入栈，反之为出栈。栈的存储结构的C语言表述为： 12345typedef struct&#123; int a[N]; int top;&#125;SeqStack; &emsp;&emsp;栈为空时，我们将Top赋值-1；非空时，我们将可以使用下标0以上的元素。类似的表述方式我们在之前讲过的二分法中提到过。当存入一个元素或取出一个元素时，我们对结构体中的top进行相应的自增和自检，记录当前栈顶的位置。 &emsp;&emsp;我们在处理先进后出的问题时，推荐使用栈。比如，我们在进行进制换算时，将十进制转为八进制需要进行多次相除求余数。算出来的数越早，它的位置就越低。比如：十进制数字1835转化为八进制需要除以四次才能将商变为0，得到的余数分别为3 5 4 3，转化为十进制就是3453。所以对于这种问题来说，使用栈来存储计算结果是再好不过的了，我们不需要对存入的数据进行反转再输出。 &emsp;&emsp;令人可喜的是，在C++的STL中给我们提供了栈这种容器，我们在使用的时候不需要再用语言来构造出来这种结构以及对这种结构的操作函数了。以后介绍的数据结构中，我们也会提到相应的STL。 头文件： #include “stack”声明方法：stack&lt;类型&gt; s;成员函数：&emsp;&emsp;&emsp;&emsp;s.push(x)&emsp;&emsp;无返回值，将元素x压栈&emsp;&emsp;&emsp;&emsp;s.pop();&emsp;&emsp;退栈，无返回值&emsp;&emsp;&emsp;&emsp;s.top();&emsp;&emsp;取栈顶元素，返回栈顶元素&emsp;&emsp;&emsp;&emsp;s.empty();&emsp;&emsp;判断栈是否为空，如果是空，返回1，否则返回0&emsp;&emsp;&emsp;&emsp;s.size();&emsp;&emsp;返回栈中元素的个数 &emsp;&emsp;大家可以思考一下怎么把栈里所有的元素打印出来，也可以试着做一下上面的进制转换问题。 队列（Queue）&emsp;&emsp;刚刚我们提到的栈，是一种先进后出的线性表，那么这里的队列也是线性表的一种，不过是先进先出（FIFO）型的。我想这个名字应该比较形象，就像我们在超市排队付款一样，先到的先来。我们把允许插入的一端称为队尾（Rear），允许删除的一端称为队头（Front），没有元素的队列称为空队列。元素的插入和删除分别称为入队和出队。 &emsp;&emsp;为了便于理解，我们来看一下队列的的存储结构吧。 12345typedef struct&#123; int a[N]; int rear,front;&#125;SeQueue; &emsp;&emsp;我们看，它的结构和栈类似，但是在结构中比栈多了一个用来表示不同出口的“指针”。在空队列时，两个“指针”的初值都为-1。当有入队操作时，我们的队尾（rear）就要进行自增；有出队操作时，队头（front）自增。（思考一下为什么会这样） &emsp;&emsp;经过这样的操作，我们的队列可能会浪费很多的存储空间，所以在常用的队列存储方式中，我们经常使用首尾相连的数据结构，这就变成了一个“循环队列”。当然，我们的STL为我们已经做好了一切，我们只要用就好了。 头文件：#include “queue”声明方式：queue Q;常用成员函数：&emsp;&emsp;&emsp;&emsp;Q.push()&emsp;&emsp;入队&emsp;&emsp;&emsp;&emsp;Q.size()&emsp;&emsp;返回队列中元素的个数&emsp;&emsp;&emsp;&emsp;Q.front()&emsp;&emsp;显示队头元素&emsp;&emsp;&emsp;&emsp;Q.back()&emsp;&emsp;显示最后一个元素&emsp;&emsp;&emsp;&emsp;Q.pop()&emsp;&emsp;出队&emsp;&emsp;&emsp;&emsp;Q.empty()&emsp;&emsp;判断队列是否为空，如果是空，返回1，否则返回0 链表（List）&emsp;&emsp;用数组存储的元素具有空间上的连续性。那么如果我们需要一个逻辑上联系很紧密的结构，比如说树或者是图的话，就有可能要使用链表了。这里只是简单介绍一下链表的概念和基本类型，在后面我们会具体研究这种重要的数据结构。 &emsp;&emsp;首先我们来看一个链表节点的存储结构： 12345typedef struct Node //结点类型定义&#123; int data; struct Node *next;&#125;LinkList; &emsp;&emsp;我们看，在定义链表节点的时候，我们使用了一个类似于递归的方法，不过我们发现，它存放的是下一个结点的指针。我们来看一下简单的单链表的结构吧。 结点结构： ┌───┬───┐ │data&emsp;│next&emsp;│ └───┴───┘ 链表结构： &emsp;&emsp;除了单链表，还有我们刚刚提到过的队列要用到的循环链表以及双链表、静态链表等。下一节我们将对链表进行专门的研究。比起线性表，除了链表的结构关系比较强之外，还能提高存储空间的利用率。链表的存储密度小、存储内存随机。但是在查找的时候，链表必须按照顺序。所以我们应该根据需求来选择相应的数据结构。 &emsp;&emsp;理解了链表的结构之后，我们并不需要像在上数据结构课的时候那样搞得那么清楚，同样，会使用STL中的链表就可以了。 头文件：#include “list”声明方式：&emsp;&emsp;&emsp;&emsp;list l; //空链表&emsp;&emsp;&emsp;&emsp;list l(3); //长度为3的链表&emsp;&emsp;&emsp;&emsp;list l2(3,4); //有两个确定元素的链表 常用成员函数：push_front/pop_front和push_back/pop_back在开头和结尾插入或删除元素 begin() 返回指向第一个元素的迭代器end() 返回末尾的迭代器sort() 对链表中的数据进行排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt; #include &lt;list&gt; #include &lt;numeric&gt; #include &lt;algorithm&gt; using namespace std; //创建一个list容器的实例LISTINT typedef list&lt;int&gt; LISTINT; //创建一个list容器的实例LISTCHAR typedef list&lt;int&gt; LISTCHAR; void main() &#123; //用list容器处理整型数据 //用LISTINT创建一个名为listOne的list对象 LISTINT listOne; //声明i为迭代器 LISTINT::iterator i; //从前面向listOne容器中添加数据 listOne.push_front (2); listOne.push_front (1); //从后面向listOne容器中添加数据 listOne.push_back (3); listOne.push_back (4); //从前向后显示listOne中的数据 cout&lt;&lt;\"listOne.begin()--- listOne.end():\"&lt;&lt;endl; for (i = listOne.begin(); i != listOne.end(); ++i) cout &lt;&lt; *i &lt;&lt; \" \"; cout &lt;&lt; endl; //从后向后显示listOne中的数据 LISTINT::reverse_iterator ir; cout&lt;&lt;\"listOne.rbegin()---listOne.rend():\"&lt;&lt;endl; for (ir =listOne.rbegin(); ir!=listOne.rend();ir++) &#123; cout &lt;&lt; *ir &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //使用STL的accumulate(累加)算法 int result = accumulate(listOne.begin(), listOne.end(),0); cout&lt;&lt;\"Sum=\"&lt;&lt;result&lt;&lt;endl; cout&lt;&lt;\"------------------\"&lt;&lt;endl; //-------------------------- //用list容器处理字符型数据 //-------------------------- //用LISTCHAR创建一个名为listOne的list对象 LISTCHAR listTwo; //声明i为迭代器 LISTCHAR::iterator j; //从前面向listTwo容器中添加数据 listTwo.push_front ('A'); listTwo.push_front ('B'); //从后面向listTwo容器中添加数据 listTwo.push_back ('x'); listTwo.push_back ('y'); //从前向后显示listTwo中的数据 cout&lt;&lt;\"listTwo.begin()---listTwo.end():\"&lt;&lt;endl; for (j = listTwo.begin(); j != listTwo.end(); ++j) cout &lt;&lt; char(*j) &lt;&lt; \" \"; cout &lt;&lt; endl; //使用STL的max_element算法求listTwo中的最大元素并显示 j=max_element(listTwo.begin(),listTwo.end()); cout &lt;&lt; \"The maximum element in listTwo is: \"&lt;&lt;char(*j)&lt;&lt;endl; &#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】3.3二分查找","slug":"【ACM教程】3-3二分查找","date":"2016-11-09T08:40:36.000Z","updated":"2017-04-13T13:25:15.896Z","comments":true,"path":"2016/11/09/【ACM教程】3-3二分查找/","link":"","permalink":"http://www.z16388.top/2016/11/09/【ACM教程】3-3二分查找/","excerpt":"","text":"第三节 二分查找&emsp;&emsp;这次我们要学习的，就是著名的高效的，并且应用非常广泛的二分查找算法，简称二分法（Binary Search）。二分查找的时间复杂度为O(lgn)，是优化程序的常用方法之一。在我们使用的java教科书中，经常会见到作者举的一个例子——猜数字。这个程序就是让你去猜测一个给定范围内的数字，当然，我们可以暴力一点，把所有可能的结果都掏出来试一试——枚举。但是真正在写程序的时候，这样效率可能会非常低，这个时候我们就需要使用二分法来去做这个游戏。 &emsp;&emsp;我们可以这样去做：选择这个区间中间的数，大了，就把它当做新的区间的起点，继续做；小了就往左去找区间，以此类推，这就是我们在数学上学习过的二分法，那么，怎么能够在程序中实现呢？代码如下： 123456789int bSearch(int a[],int b,int low,int high)&#123; int mid; if(low&gt;high) return -1; mid=(low+high)/2; if(b==a[mid]) return mid; if(b&lt;a[mid]) return bSearch(a,b,low,mid-1); else return bSearch(a,b,mid+1,high);&#125; &emsp;&emsp;我们看代码中的函数使用了四个参数，其中需要注意的是，第一个参数不仅仅是一个普通的数组，而是一个经过排序的序列，所以应该对需要查找的数组进行排序再进行二分查找。需要注意的是，我们应当注意对相同数据的处理，就是说如果我们的序列中会出现相同的数据，它应当返回哪一个下标。 &emsp;&emsp;这个函数的功能是查找一个数在数组中是否存在，如果存在返回它的下标；如果不存在，则返回-1。在C++的STL中，给我们提供了类似的函数binary_search()，它的功能是判断一个数是否在给定序列中存在，返回值类型为布尔型。它的三个参数分别为： binary_search(起始地址，终止地址，查找值); &emsp;&emsp;遗憾的是，上面的函数只能告诉我们这个值是否存在，并不能知道它的确切位置，这个时候，我们可以使用这两个函数：lower_bound()和upper_bound()。这两个函数是用来算出要查元素的上界和下界的，意思是说，对于序列中出现相同的元素的情况，这两个函数是可以解决的。但是，需要注意的是： 返回值的类型是地址,不是下标；如果元素出现一次，lower_bounder()返回这个元素的地址，upper_bounder()返回它后面一个元素的地址；如果元素出现多次，lower_bounder()返回第一个元素的地址，upper_bounder()返回最后一个元素的后面一的元素的地址。 &emsp;&emsp;返回值是地址怎么办，我们也可以想办法投机取巧。我们知道，一个数组的名同时是一个数组第一个元素的地址，那么拿得到的地址减去首地址，就刚好是这个元素在数组中的下标了： 1lower_bounder(a,a+100,shu)-a &emsp;&emsp;除此之外，二分法还有非递归的写法，大家可以了解一下： 123456789101112int bSearch(int a[],int b,int n)&#123; int low,high,mid; low=0;high=n-1; while(low&lt;=high) &#123; mid=(low+high)/2; if(a[mid]==b) return mid; if(a[mid]&lt;b) low=mid+1; else high=mid-1; &#125; return -1;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"R语言二三事","slug":"R语言二三事","date":"2016-11-04T09:18:34.000Z","updated":"2017-04-13T13:25:20.828Z","comments":true,"path":"2016/11/04/R语言二三事/","link":"","permalink":"http://www.z16388.top/2016/11/04/R语言二三事/","excerpt":"","text":"&emsp;&emsp;上午上完第一节课之后，想要到图书馆寻找几本算法相关的书籍未果，偶然发现了两本不错的书。一本是《Python语言程序设计》，另一本就是《R语言初学指南》了。 &emsp;&emsp;早些时候我就有关注过R了，听说是一个最近很火的数据分析语言，具有强大的数据分析功能，在各领域都有所使用。这也算是第一次接触，还没回到寝室就迫不及待地打开翻了两页，顿时整个人都不好了——我看到了一堆讨厌极了的矩阵。。。 &emsp;&emsp;回到寝室，从序开始看，发现这是一本很浅显的书，内容的话还涉及一些行业上的实例，比如说在第三节就有一个金融数学上的例子，刚好我们才学过的一些东西都用上了。 &emsp;&emsp;下载好，给win和mac都安装好，摸索使用了一下，发现这真是一个非常好的数学工具。比起MATLAB臃肿的安装包，R的基础包只有不到100mb，而且足够初学者的使用，这一点我非常欣赏。虽然UI不是很理想，但是功能强大不就好了吗。 &emsp;&emsp;基本的语法和Python有着一定的相似之处，使用起来和MATLAB也很类似。总之，希望能够学下去吧。下面总结一下今天学到的R常用的基础语法： 12&gt; 5+7[1] 12 &emsp;&emsp;和Python类似，可以直接实现两个数的运算。常用的运算除了加减乘除之外，还有乘方，例：e^2 1234&gt; sally=5+7&gt; ralph=4-2&gt; sally-ralph[1] 10 &emsp;&emsp;可以将数据存放在变量中进行运算。 &emsp;&emsp;赋值有两种方法，较老的版本使用箭头来进行赋值，现在和其他语言类似，都可以使用一个等号表示赋值，这两种方法是等价的： 12&gt; a=a+1&gt; a&lt;-a+1 向量： &emsp;&emsp;向量是数学中一个相当常用的概念，在R里当然是必不可少的。我们可以通过下面的方法来创建一个向量： 1&gt; x=c(2,3,5,7) &emsp;&emsp;向量可以进行加减乘除乘方等运算。除此之外，还有一种特殊的向量，用来表示一个连续的序列，例如： 123&gt; j=0:5&gt; j[1] 0 1 2 3 4 5 &emsp;&emsp;冒号申请的连续序列可能在后面的过程中经常使用，比如在绘图时，可能需要很多的坐标，这时候使用这种向量会极大地方便我们的绘图工作。 学习ing","categories":[],"tags":[{"name":"R","slug":"R","permalink":"http://www.z16388.top/tags/R/"}],"keywords":[]},{"title":"【ACM教程】3-1枚举","slug":"【ACM教程】3-1枚举","date":"2016-11-02T07:55:31.000Z","updated":"2017-04-13T13:25:15.894Z","comments":true,"path":"2016/11/02/【ACM教程】3-1枚举/","link":"","permalink":"http://www.z16388.top/2016/11/02/【ACM教程】3-1枚举/","excerpt":"","text":"第一节 枚举&emsp;&emsp;枚举又叫穷举，是程序设计中最常用的算法之一，是一种很*很暴力的算法。要说它的方法，就是没有方法——通过将所有可能的结果一一列举出来进行判断，获得想要的结果的方法。枚举算法的特点就是比较单纯，容易写出来程序，但是速度非常慢，只能用来解决小规模的问题。 &emsp;&emsp;常见的题型有很多，比如计算空缺算式或者是火柴棒问题，接下来我们来举例说明一道非常经典的题目，来体会一下枚举算法。 &emsp;&emsp;我国古代数学家章丘建在《算经》一书中提过一道数学问题：鸡翁一值钱五，鸡母一值钱散，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何。这就是经典的百钱百鸡问题。除了原书中使用的方程式之外，我们还可以使用枚举法来进行计算，代码如下： 12345678910111213#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int i,j,k; for(i=1;i&lt;=20;i++) for(j=1;j&lt;=33;j++) for(k=1;k&lt;=100;k++) if((i*5+j*3+k/3==100)&amp;&amp;(i+j+k==100)&amp;&amp;(k%3==0)) printf(\"%d %d %d\\n\",i,j,k); return 0;&#125; &emsp;&emsp;在之前杭电的练习题中，我们也遇到过使用枚举算法的题目，hdu2010题的水仙花数就是。大家可以练习一下全排列的问题，练习一下枚举算法。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"关于杉果社区发展的二三想法","slug":"关于杉果社区发展的二三想法","date":"2016-10-31T04:52:28.000Z","updated":"2017-04-13T13:25:20.504Z","comments":true,"path":"2016/10/31/关于杉果社区发展的二三想法/","link":"","permalink":"http://www.z16388.top/2016/10/31/关于杉果社区发展的二三想法/","excerpt":"","text":"&emsp;&emsp;在杉果一年多，不算久也不算短，也剁了很多东西。从开始的陌生，到现在的熟悉，杉果带给了我很多（剁手的机会）一步步走来，看着社区的变化，想要说很多，各种想法也很凌乱。总之，还是本着站着说话不腰疼的立场，说一说自己的看法吧。 &emsp;&emsp;社区要想发展，定位、内容、管理、活动、UI等等，各种都不能少，那么，我就结合现状，发表一下自己的意见。 &emsp;&emsp;首先在定位上，杉果社区应该是成为一个玩家的交流平台，而不是一个评价商品的地方。那么，我们就应该给客户提供这样一个地方。之前我在给员子的私信中提到了这一点。刚好，也看到了这样的一个功能即将要上线的消息，我觉得，在“垃圾内容”上，应该很快会有所改善。毕竟，比起谈论什么怎么还不发key，我们更想看到什么更好剁，大家一起剁什么。 &emsp;&emsp;当然，没了活动时的抱怨，干货也要有对不对。所以第二点比较重要的，就是“独家内容”。必须是杉果特色的，必须是别家都找不到的。像之前和游戏厂商黑恶势力的谈笑风生活动啦，这样的好机会不应该成为给直播平台带来流量的活动对不对，为什么要便宜别人呢。结合自己的社区，发布自己的独家内容，这一点很重要。而且，杉果电台虽然做的很良心，但是我觉得受众可能还不是很广。我觉得如果去b站发视频的话，可能会有更好的效果。 &emsp;&emsp;管理层面我觉得暂时还不需要考虑，因为没人（心疼）。当然，人多之后的打算也是要提前做的。分区，管理，内容，各种方面，都要去做，当然这是后话。 &emsp;&emsp;活动，社区活动从来不缺，看万圣节活动对不对，下面复制粘贴300多回复，多火热。但是，活动结束呢？没有员子水贴和某up主的视频，我觉得可能三四天都看不到新的内容。活动是带来流量的方法，但是也要做对活动。像这样直接拿key走的活动，给人一种廉价感，而且是为了奖品而活动。我觉得应该活动日常化，积分化，让所有的人都参与进来。不是什么新人活动啦，发评测活动啦，这样除了会让人注册一堆小号，或者多一堆没有营养的测评之外，没有别的用处了。记得很久以前听说社区会有大改，但是等了好久也没有见到变化。。。社区现状就是抱怨和领key的地方。。。 &emsp;&emsp;UI不说了，毕竟不是专业搞UI的，但是至少steam的api该更新一下了，移动端密码框的安全性还有不能用psn的话就去掉这个功能对不对。 &emsp;&emsp;总之，千言万语总结成一句话：希望杉果越来越好，至少，我会等着。","categories":[],"tags":[{"name":"心情","slug":"心情","permalink":"http://www.z16388.top/tags/心情/"},{"name":"游戏","slug":"游戏","permalink":"http://www.z16388.top/tags/游戏/"}],"keywords":[]},{"title":"ACM常用模版","slug":"ACM常用模版","date":"2016-10-30T15:57:55.000Z","updated":"2017-04-13T13:25:20.947Z","comments":true,"path":"2016/10/30/ACM常用模版/","link":"","permalink":"http://www.z16388.top/2016/10/30/ACM常用模版/","excerpt":"","text":"求素数1234567int su(int b)&#123; for(int i=2;i&lt;=(int)sqrt(b);i++) &#123; if(b%i==0) return 0; &#125; return 1;&#125; 最大公约数和最小公倍数欧几里得定力：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。123456789int gcd(int a,int b) //最大公约数&#123; if(b==0) return a; else return gcd(b,a%b);&#125;int lcm(int a,int b) //最小公倍数&#123; return a/gcd(a,b)*b;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】2.4编程细节","slug":"【ACM教程】2-4编程细节","date":"2016-10-30T14:39:21.000Z","updated":"2017-04-13T13:25:15.892Z","comments":true,"path":"2016/10/30/【ACM教程】2-4编程细节/","link":"","permalink":"http://www.z16388.top/2016/10/30/【ACM教程】2-4编程细节/","excerpt":"","text":"第四节 编程细节 细节决定成败，态度决定一切。 &emsp;&emsp;在我们程序编写的过程中，有一些细节我们需要注意，这对你以后的代码质量都会有很大的影响。下面，我会介绍一些常见的细节。 合理的缩进&emsp;&emsp;虽然编译器会忽略代码中一切空格和换行，但是一段乱奇葩早的缩进的代码真的是能逼死强迫症的。 &emsp;&emsp;常见的缩进方式是使用Tab键，默认4个空格。相同等级的语句不缩进，次级语句需要缩进，比如：123for(int i=1;i&lt;=100;i++) sum+=i;printf(\"%d\\n\",sum); &emsp;&emsp;在上面的代码中，我们看到循环体是累加计算，属于循环语句的次级语句，所以应当缩进。而输出是和循环同一等级的，所以要和for循环对齐。 &emsp;&emsp;除此之外，大括号的缩进也很重要，这一点在下面会介绍。 统一的大括号&emsp;&emsp;大括号也是决定一个程序是否整齐的关键，我们常用以下两种方法：12345678910int main()&#123; int sum=0; for(int i=1;i&lt;=100;i++) &#123; sum+=i; &#125; printf(\"%d\\n\",sum); return 0;&#125; 123456789public class Main() &#123; public static void main(String args[]) &#123; int sum=0; for(int i=1;i&lt;=100;i++) &#123; sum+=i; &#125; System.out.println(sum); &#125;&#125; 不同类型数据之间的计算&emsp;&emsp;这种情况经常出现在ACM的题目中，就比如hdu2002和hdu2009。如果是把int型数据赋值给double是没有问题的，但是如果是double数据给int，就会出现精度的损失，造成计算的失误。 &emsp;&emsp;hdu2002中的分数4/3。如果直接在程序里这么写，程序会当成4整除3来计算，应当写成4.0/3.0。 &emsp;&emsp;hdu2009题如果想要写成m=sqrt(m)的话，就要保证m的类型是double类型，否则在赋值时会损失精度。 程序的模块化&emsp;&emsp;模块化思想很重要，像C++和Java都是面向对象的编程语言，集成化程度很高。但是并不意味着我们写C就不要模块化。模块化的程序可读性高，便于修改。 &emsp;&emsp;比如hdu2005，判断是否是闰年的题目。我在判断是否是闰年时，写了一个函数，功能是：如果是闰年返回1，否则返回0。 &emsp;&emsp;当然不仅限于如此，假设某程序需要按照一个公式进行计算，但是后来我们突然想要改变计算过程，如果你把公式写在函数里，那么只需要修改函数就行了，避免了对主函数的修改。 关于数组&emsp;&emsp;关于数组有两点需要注意。 &emsp;&emsp;首先是对下标的确定。我们知道，数组的下标和元素的序号是刚好相差1的。那么我们可以抛弃数组的第一个元素，只使用数组的第二个往后的元素，这样可以统一下标和元素序号，比如： 1234int a[101];for(int i=1;i&lt;=100;i++) &#123; scanf(\"%d\",&amp;a[i]);&#125; &emsp;&emsp;再者，在申请数组大小的时候，我们可以多申请几个。有时候也可能要同时申请多组，这时候，推荐大家使用宏定义，比如： 12#define N 10010int a[N],b[N],c[N];","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"hud2011-2020答案","slug":"hud2011-2020答案","date":"2016-10-30T14:28:10.000Z","updated":"2017-04-13T13:25:15.863Z","comments":true,"path":"2016/10/30/hud2011-2020答案/","link":"","permalink":"http://www.z16388.top/2016/10/30/hud2011-2020答案/","excerpt":"","text":"hdu2011 多项式求和12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int m,n; double sum=0.0,f=1.0; scanf(\"%d\",&amp;m); while(m--) &#123; scanf(\"%d\",&amp;n); sum=0.0,f=1.0; for(int i=1;i&lt;=n;i++) &#123; sum+=f/i; f=-1.0*f; &#125; printf(\"%.2f\\n\",sum); &#125; return 0;&#125; hud2012 素数判定123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int cal(int a)&#123; return a*a+a+41;&#125;int su(int b)&#123; for(int i=2;i&lt;=(int)sqrt(b);i++) &#123; if(b%i==0) return 0; &#125; return 1;&#125;int main()&#123; int x,y,flag=1; while(scanf(\"%d%d\",&amp;x,&amp;y)&amp;&amp;(x||y)) &#123; flag=1; for(int i=x;i&lt;=y;i++) if(su(cal(i))==0) flag=0; if(flag==1) printf(\"OK\\n\"); else printf(\"Sorry\\n\"); &#125; return 0;&#125; hdu2013 蟠桃记&emsp;&emsp;这是一道非常经典的OI明星题，原名是《猴子吃桃》，我在2008年初二的时候第一次接触这道题目，也是因为这一道题爱上了算法。这道题目是非常经典的循环题，类似的题目还有《王小二切大饼》、《母牛问题》等。 123456789101112131415#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n,sum=0; while(scanf(\"%d\",&amp;n)!=EOF) &#123; sum=1; for(int i=1;i&lt;n;i++) &#123; sum=2*(sum+1); &#125; printf(\"%d\\n\",sum); &#125; return 0;&#125; hdu2014 青年歌手大赛_评委会打分&emsp;&emsp;这是一道日常生活中常见的题目，唯一需要注意的就是在使用sort()函数时，需要排序的范围，这里还请大家思考一下。 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 110using namespace std;int li[N];int main()&#123; int n; double p; while(scanf(\"%d\",&amp;n)!=EOF) &#123; p=0.0; memset(li,0,sizeof(li)); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;li[i]); &#125; sort(li+1,li+n+1); for(int i=2;i&lt;n;i++) &#123; p+=li[i]; &#125; printf(\"%.2f\\n\",p/(n-2)); &#125; return 0;&#125; hdu2015 偶数求和&emsp;&emsp;这道题算是这几道里面比较麻烦的了，开始想的可能比较复杂，取第几项加几什么的很烦。但是后来发现，按照题目的意思直接去计算可能比较简单。 &emsp;&emsp;首先，我们的思路是算出每组数的第一个数2+(m2)\\i,然后向后求和，去平均值。最后要判断一下最后一组是否完全，不全的话则需要除以n%m求平均值。 &emsp;&emsp;除此之外，还有输出的循环控制，最后一个元素的后面没有空格。代码如下： 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n,m; while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF) &#123; int sum=0,a=2,flag=0,i; for(i=1;i&lt;=n;i++) &#123; sum+=a; a+=2; if(i%m==0) &#123; flag++; if(flag!=1) printf(\" \"); printf(\"%d\",sum/m); sum=0; &#125; &#125; if(n%m==0) printf(\"\\n\"); else printf(\" %d\\n\",sum/(n%m)); &#125; return 0;&#125; hdu2016 数据的交换输出1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n,a[110],mi; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; mi=1; for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); if(a[i]&lt;a[mi]) &#123; mi=i; &#125; &#125; int t; t=a[mi]; a[mi]=a[1]; a[1]=t; printf(\"%d\",a[1]); for(int i=2;i&lt;=n;i++) &#123; printf(\" %d\",a[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125; hdu2017 字符串统计123456789101112131415161718#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n,sum; scanf(\"%d\",&amp;n); getchar(); while(n--) &#123; char s; int sum=0; while((s=getchar())!='\\n') &#123; if(s&gt;=48&amp;&amp;s&lt;=57) sum++; &#125; printf(\"%d\\n\",sum); &#125; return 0;&#125; hdu2018 母牛的故事&emsp;&emsp;这是一道简单的动态规划问题，这类问题的其他内容我们将在后来的教程中着重讨论。 12345678910111213141516#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int func(int y)&#123; if(y&lt;4) return y; else return func(y-3)+func(y-1);&#125;int main()&#123; int n; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; printf(\"%d\\n\",func(n)); &#125; return 0;&#125; hdu2019 数列有序！123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define N 110int a[N];using namespace std;int main()&#123; int n,m,ji=0; while(scanf(\"%d%d\",&amp;n,&amp;m)&amp;&amp;(n||m)) &#123; memset(a,0,sizeof(a)); ji=1; for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++) &#123; if(a[i]&gt;=m) &#123; ji=i; break; &#125; &#125; for(int i=n+1;i&gt;ji;i--) &#123; a[i]=a[i-1]; &#125; a[ji]=m; printf(\"%d\",a[1]); for(int i=2;i&lt;=n+1;i++) &#123; printf(\" %d\",a[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125; hdu2020 绝对值排序```C++","categories":[],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://www.z16388.top/tags/hdu/"},{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"}],"keywords":[]},{"title":"hdu1089-1096输入输出练习答案","slug":"1089-1096输入输出练习","date":"2016-10-28T11:40:22.000Z","updated":"2017-04-13T13:25:15.839Z","comments":true,"path":"2016/10/28/1089-1096输入输出练习/","link":"","permalink":"http://www.z16388.top/2016/10/28/1089-1096输入输出练习/","excerpt":"","text":"&emsp;&emsp;这是ACM基本的输入输出练习，答案如下： hdu10891234567891011#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b)!=EOF) &#123; printf(\"%d\\n\",a+b); &#125; return 0;&#125; hdu109012345678910111213#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,n; scanf(\"%d\",&amp;n); while(n--) &#123; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",a+b); &#125; return 0;&#125; hdu10911234567891011#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b)&amp;&amp;(a||b)) &#123; printf(\"%d\\n\",a+b); &#125; return 0;&#125; hdu1092123456789101112131415#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; int s=0,b,i; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;b); s+=b; &#125; printf(\"%d\\n\",s); &#125; return 0;&#125; hdu1093123456789101112131415161718#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; scanf(\"%d\",&amp;n); while(n--) &#123; int a,b,i,s=0; scanf(\"%d\",&amp;a); for(i=1;i&lt;=a;i++) &#123; scanf(\"%d\",&amp;b); s+=b; &#125; printf(\"%d\\n\",s); &#125; return 0;&#125; hdu109412345678910111213141516#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; while(scanf(\"%d\",&amp;n)!=EOF) &#123; int s=0,b,i; for(i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;b); s+=b; &#125; printf(\"%d\\n\",s); &#125; return 0;&#125; hdu10951234567891011#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b)!=EOF) &#123; printf(\"%d\\n\\n\",a+b); &#125; return 0;&#125; hdu109612345678910111213141516171819#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; scanf(\"%d\",&amp;n); while(n--) &#123; int a,b,i,s=0; scanf(\"%d\",&amp;a); for(i=1;i&lt;=a;i++) &#123; scanf(\"%d\",&amp;b); s+=b; &#125; printf(\"%d\\n\",s); if(n!=0) printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://www.z16388.top/tags/hdu/"},{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"}],"keywords":[]},{"title":"hdu2000-2010答案","slug":"hdu2000-2010","date":"2016-10-28T11:16:10.000Z","updated":"2017-04-13T13:25:15.854Z","comments":true,"path":"2016/10/28/hdu2000-2010/","link":"","permalink":"http://www.z16388.top/2016/10/28/hdu2000-2010/","excerpt":"","text":"hdu2000 ASCII码排序&emsp;&emsp;这是一道简单的排序问题，可以直接使用sort函数解决，但是如果使用值交换的方法则需要注意回车的消除。 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; char a[4],t; while(scanf(\"%c%c%c\",&amp;a[1],&amp;a[2],&amp;a[3])!=EOF) &#123; getchar(); if(a[1]&gt;a[2]) &#123; t=a[1]; a[1]=a[2]; a[2]=t; &#125; if(a[2]&gt;a[3]) &#123; t=a[2]; a[2]=a[3]; a[3]=t; &#125; if(a[1]&gt;a[2]) &#123; t=a[1]; a[1]=a[2]; a[2]=t; &#125; printf(\"%c %c %c\\n\",a[1],a[2],a[3]); &#125; return 0;&#125; 12345678910111213#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; char str[3]; while(cin&gt;&gt;str) &#123; sort(str,str+3); cout&lt;&lt;str[0]&lt;&lt;\" \"&lt;&lt;str[1]&lt;&lt;\" \"&lt;&lt;str[2]&lt;&lt;endl; &#125; return 0;&#125; hdu2001 计算两点间的距离&emsp;&emsp;这是一道简单的计算题，第一次使用了数学函数和双精度的数，没有太多需要注意的地方。 1234567891011121314#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; double x1,y1,x2,y2; while(cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2) &#123; double jie=sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)); printf(\"%.2lf\\n\",jie); &#125; return 0;&#125; hdu2002 计算球体体积&emsp;&emsp;这是一道求球体体积的计算题，需要注意的是，这里可能会出现整数和实数之间的乘法，需要注意的是题目中的4/3需要写成4.0/3.0，这一点很容易犯错。 &emsp;&emsp;还有一点需要注意的是，我们应当使用题目中所给的pi值，否则结果可能会出现一定的误差。 123456789101112131415#define PI 3.1415927#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; double r; while(cin&gt;&gt;r) &#123; double jie=4.0*PI*r*r*r/3.0; printf(\"%.3lf\\n\",jie); &#125; return 0;&#125; hdu2003 求绝对值123456789101112131415#define PI 3.1415927#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; double r; while(cin&gt;&gt;r) &#123; double jie=fabs(r); printf(\"%.2lf\\n\",jie); &#125; return 0;&#125; #hdu2004 成绩转换 &emsp;&emsp;这道题需要仔细审题，一定要注意分数的范围，无论是上界还是下界。 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int grade; while(scanf(\"%d\",&amp;grade)!=EOF) &#123; if(grade&gt;=90&amp;&amp;grade&lt;=100) printf(\"A\\n\"); else if(grade&gt;=80&amp;&amp;grade&lt;=89) printf(\"B\\n\"); else if(grade&gt;=70&amp;&amp;grade&lt;=79) printf(\"C\\n\"); else if(grade&gt;=60&amp;&amp;grade&lt;=69) printf(\"D\\n\"); else if(grade&gt;=0&amp;&amp;grade&lt;=59) printf(\"E\\n\"); else printf(\"Score is error!\\n\"); &#125; return 0;&#125; hdu2005 第几天？123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int runn(int yy)&#123; if(yy%400==0||(yy%100!=0&amp;&amp;yy%4==0)) return 1 ; else return 0 ;&#125;int main()&#123; int y,m,d,sum; while(scanf(\"%d/%d/%d\",&amp;y,&amp;m,&amp;d)!=EOF) &#123; sum = 0 ; switch(m-1) &#123; case 11 : sum+=30; case 10 : sum+=31; case 9 : sum+=30; case 8 : sum+=31; case 7 : sum+=31; case 6 : sum+=30; case 5 : sum+=31; case 4 : sum+=30; case 3 : sum+=31; case 2 :if (runn(y)==1) sum+=29; else sum+=28; case 1 : sum+=31; &#125; sum+=d; printf(\"%d\\n\",sum); &#125; return 0;&#125; hdu2006 求奇数的乘积12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; int liste[100]; while(scanf(\"%d\",&amp;n)!=EOF) &#123; int i; for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;liste[i]); int sum=1; for(i=1;i&lt;=n;i++) if(liste[i]%2!=0) sum*=liste[i]; printf(\"%d\\n\",sum); &#125; return 0;&#125; hdu2007 平方和与立方和123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int m,n,t,i; while(scanf(\"%d%d\",&amp;m,&amp;n)!=EOF) &#123; if(m&gt;n) &#123; t=m; m=n; n=t; &#125; int s1=0,s2=0; for(i=m;i&lt;=n;i++) &#123; if(i%2==0) s1=s1+i*i; else s2=s2+i*i*i; &#125; printf(\"%d %d\\n\",s1,s2); &#125; return 0;&#125; hdu2008 数值统计123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n; double liste[100]; while(scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; for(int i=1;i&lt;=n;i++) &#123; scanf(\"%lf\",&amp;liste[i]); &#125; int a=0,b=0,c=0; for(int i=1;i&lt;=n;i++) &#123; if(liste[i]&lt;0) a++; if(liste[i]==0) b++; if(liste[i]&gt;0) c++; &#125; printf(\"%d %d %d\\n\",a,b,c); &#125; return 0;&#125; hdu2009 求数列的和&emsp;&emsp;这一题看起来很简单，但是需要进行不同类型数据的运算。这一点还是比较容易犯一些错误的，大家需要注意一些。 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; double sum; int m,n; while(scanf(\"%d%d\",&amp;m,&amp;n)!=EOF) &#123; sum=0.0; double mm=m; for(int i=1;i&lt;=n;i++) &#123; sum+=mm; mm=sqrt(mm); &#125; printf(\"%.2f\\n\",sum); &#125; return 0;&#125; hdu2010 水仙花数&emsp;&emsp;这是一道很经典的题目，可能需要使用比较多的判断。 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int m,n,flag; while(scanf(\"%d%d\",&amp;m,&amp;n)!=EOF) &#123; int i=m; flag=0; for(i=m;i&lt;=n;i++) &#123; int a,b,c; a=i/100; b=i/10%10; c=i%10; if(i==a*a*a+b*b*b+c*c*c) &#123; if(flag==0) &#123; flag++; printf(\"%d\",i); &#125; else &#123; flag++; printf(\" %d\",i); &#125; &#125; &#125; if(flag==0) &#123; printf(\"no\\n\"); &#125; else &#123; printf(\"\\n\"); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://www.z16388.top/tags/hdu/"},{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"}],"keywords":[]},{"title":"【ACM教程】2.2从排序开始","slug":"【ACM教程】2-2从排序开始","date":"2016-10-28T08:29:49.000Z","updated":"2017-04-13T13:25:15.889Z","comments":true,"path":"2016/10/28/【ACM教程】2-2从排序开始/","link":"","permalink":"http://www.z16388.top/2016/10/28/【ACM教程】2-2从排序开始/","excerpt":"","text":"第二节 从排序开始&emsp;&emsp;今天看群里有同学说：“看dalao的博客，今天晚上估计要讲C++框架了”，这我能忍？让你们猜到了，我该多没面子啊。所以呢，今天我就把教程改了一下，顺便更好地串联后面的内容。 &emsp;&emsp;如题，我们今天要讲的是排序，排序是写程序中，比较重要的一个部分，以后也会专门做一个章节去讲，今天只涉及一些简单的排序方法。 这他喵叫排序？——桶排序&emsp;&emsp;一直讲排序，可能会有些枯燥，我们先来点好玩的。 &emsp;&emsp;桶排序是最简单的排序算法，思路也是最奇葩的，奇葩到我都不想把它算作排序。那么它具体是怎么来的呢，我们来看下面一个题目： &emsp;&emsp;在一次体育比赛中，某个选手的动作将会由多名裁判进行打分，分值在0～10之间的整数。输入一个数组，存放有N名裁判给出的分数(1&lt;=N&lt;=10000)，输出要求从大到小输出裁判打出的分数。 &emsp;&emsp;这道题很简单，有同学该说了，“我知道！用冒泡！”行，冒泡的确可以解决这个问题，但是时间复杂度可能会比较高。这道题，有一种更好的方法，那就是我们这一节的主角——桶排序，今天学了可能一辈子都再也用不到的排序方法。那么，究竟应该怎么去做呢？ &emsp;&emsp;首先声明一个长度为11的数组a[11]，再将该数组的每个元素都赋值为0。当选手得分为s时，进行操作a[s]++。这样进行一遍便利之后，我们数组中每个元素都将表示得s分的次数。这样，我们只需要将s打印a[s]次，就会得到我们需要的结果，代码如下： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define N 10010int grade[N];using namespace std;int main()&#123; int n,a[11]; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;grade[i]); &#125; memset(a,0,sizeof(a)); for(int i=1;i&lt;=n;i++) &#123; a[grade[i]]++; &#125; for(int i=10;i&gt;=1;i--) &#123; if(a[i]==0) continue; else &#123; for(int j=1;j&lt;=a[i];j++) &#123; printf(\"%d\",i); &#125; &#125; &#125; printf(\"\\n\"); return 0;&#125; 基础中的基础，“牛奶杯”排序&emsp;&emsp;有一杯水，一杯牛奶，想让他们两个换一下，那么我们得需要另一个杯子作为中转站。这是我们在写程序中，进行值交换的最简单的方法。比如航电上的hdu2000题：http://acm.hdu.edu.cn/showproblem.php?pid=2000这就是一道使用牛奶杯排序法的题目,我们只需要一个中间变量就可以实现两个变量值的交换，然后比较三次达到排序的目的。这种方法比较麻烦，适用于样本比较少的排序。 C++，带带我（利用C++的STL函数排序）&emsp;&emsp;其实在竞赛中，我们最常使用的是C++的STL中的排序函数。（STL是C++的标准模版库） &emsp;&emsp;sort()函数是我们最常用的排序函数，它在algorithm头文件中，使用时需要在你的程序上方添加一行： 1#include&lt;algorithm&gt; &emsp;&emsp;排序函数在比赛中都是被允许的，它拥有三个参数： sort(起始地址,终止地址,[比较方法]) &emsp;&emsp;其中比较方法不是必须参数，它的使用方法我们将会在下一节进行说明。那么，一个使用sort()函数进行排序的简单程序如下： 1234567891011121314151617#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[11]; for(int i=1;i&lt;=10;i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a+1,a+10); for(int i=1;i&lt;=10;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; return 0;&#125; &emsp;&emsp;刚刚的那道hdu2000也可以使用这种方法去做，代码如下： 12345678910111213#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; char str[3]; while(cin&gt;&gt;str) &#123; sort(str,str+3); cout&lt;&lt;str[0]&lt;&lt;\" \"&lt;&lt;str[1]&lt;&lt;\" \"&lt;&lt;str[2]&lt;&lt;endl; &#125; return 0;&#125; 初始化&emsp;&emsp;除了排序，初始化也很重要。在做和图、矩阵有关的题目时，我们经常会对二维数组进行初始化。将两个无关点之间的距离初始化为无穷，或者是给单位矩阵非对角线元素进行的初始化。C++给我们提供了memset() 函数实现初始化，这个函数在cstring头文件中。下面是memset() 函数的参数： Memset(数组名，初始化内容，初始化范围)；","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"大连交通大学 软件竞赛协会介绍","slug":"aboutdjac","date":"2016-10-22T05:46:19.000Z","updated":"2018-01-10T12:13:33.657Z","comments":true,"path":"2016/10/22/aboutdjac/","link":"","permalink":"http://www.z16388.top/2016/10/22/aboutdjac/","excerpt":"","text":"关于大连交通大学软件竞赛协会&emsp;&emsp;大连交通大学软件竞赛协会（以下简称：协会），前身是大连交通大学ACM俱乐部。ACM俱乐部是由参加ACM竞赛的学长们自发组织成立的学习交流性组织，多年来诞生了我校大批技术大牛。前辈们参赛诸多，为我校捧得诸多荣誉。协会由学生自发组织，大连交通大学软件学院支持，进行算法相关的学习与培训，参加ACM和蓝桥杯为主的算法竞赛，为校争光。 协会招新&emsp;&emsp;协会面向大连交通大学全体四年制／五年制全日制本科生开放，如果你拥有以下条件那就更好了~： 参加过ACM／OI等竞赛的 对算法感兴趣或接触过的 学习过C/C++或Java &emsp;&emsp;联系我们：&emsp;&emsp;&emsp;&emsp;QQ群号：216063864 大连交通大学竞赛相关政策&emsp;&emsp;根据《大连交通大学关于大学生科技创新活动的若干规定》（大交大发[2006】63号]、《大连交通大学指导学生科技创新活动教师工作量核算及奖励办法》（大交大发[2007]147号）等文件精神，为进一步加强和规范我校大学生科技创新活动的深入发展，培养学生的创新精神和实践能力，鼓励学生积极参与科技创新活动，鼓励教师积极参与指导大学生科技创新活动、浓厚校园学术科技氛围，提高大学生创新能力和综合素质，颁发了大学生科技创新活动实施细则。详见：http://202.199.128.101/cxjy/shownews.asp?id=82","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"MAC下hexo的安装与使用","slug":"MAC下hexo的安装与使用","date":"2016-10-06T15:37:24.000Z","updated":"2017-04-13T13:25:20.841Z","comments":true,"path":"2016/10/06/MAC下hexo的安装与使用/","link":"","permalink":"http://www.z16388.top/2016/10/06/MAC下hexo的安装与使用/","excerpt":"","text":"&emsp;&emsp;不知道就是造了什么孽，电脑，又炸了。唉～没想到，我这么肝，倒下的竟然是我的电脑，也是可怕。 &emsp;&emsp;闲话不多说了。哥哥把他的Mac接我救急用了，刚到手还没捂热乎呢，只是随意的装了一些必须的东西。什么java啦，jsp啦，xcode啦。总之搞了很多，但是博客这个东西一直没搞好，因为一直没去研究Mac下GitHub的使用。今天，借着这个炸的机会，把我的博客给挪到啦Mac上，继续更新啦。 &emsp;&emsp;讲道理，苹果的工业设计还是很好的。到手没几天，已经熟悉的七七八八了；当然也不能说熟悉到windows这种程度，但是也是到了能够日常使用，应付一些简单的coding。我们话说回来啊，这个hexo我本来是打算放弃掉的。因为前几天，我用微软的azure搭建了一个Wordpress的博客。但是令人蛋疼的是，DreamSpark订阅的微软Azure它不能使用域名绑定功能，这就很尴尬了，谁会顶着一个超长的链接去看你的博客呢对不对。所以既然电脑炸了，没了办法，那只能研究mac上怎么去使用hexo了。来，我们闲话不多说，正式开始了。 第一步 安装Node.js&emsp;&emsp;这是hexo必须的一步，毕竟是基于Node.js的框架嘛。至于在哪里下载，怎么安装，以及GitHub的注册，域名什么的，我就不过多赘述了，这在我之前的博客里面都有的。 第二步 安装hexo&emsp;&emsp;这里直接使用Node.js的npm去安装，在终端中，浏览到你想要存放博客内容的文件夹，比如cd /Applications/blog。之后执行hexo的安装命令： 1sudo npm install -g hexo &emsp;&emsp;安装好之后，把你之前博客的内容放到里面去；如果没有，则执行hexo init。然后就可以正常地去使用你的hexo了，和windows环境下的操作完全一样。 &emsp;&emsp;唉～说点题外话，讲道理，上天真的是逼我这学期要好好学习啊，害怕。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"}],"keywords":[]},{"title":"联想Y400折腾第二天","slug":"联想Y400折腾第二天","date":"2016-09-30T13:45:23.000Z","updated":"2017-04-13T13:25:15.963Z","comments":true,"path":"2016/09/30/联想Y400折腾第二天/","link":"","permalink":"http://www.z16388.top/2016/09/30/联想Y400折腾第二天/","excerpt":"","text":"&emsp;&emsp;我也是够闲的。本着不抛弃，不放弃地原则，抢救我的笔记本小Y。虽然从早上开机到现在，我。。。不不不，不能奶！总之，倒持了一天吧，不说成果怎么样，也是有一些收获的。相比于昨天的硬件，我把今天折腾的方向转向了软件。 &emsp;&emsp;嘛，有一只老学长，作为长者，在计算机的各种心肝脾肺肾上都有涉猎，我很是佩服的一颗赛艇。其实我昨天就想请教他的，但是硅脂到了，也就没麻烦他了。但是，对于硬件靠脚踹，软件做系统的我，想要搞个大新闻出来，也是没那么容易的。 &emsp;&emsp;看了一上午的《齐木楠雄的灾难》，真的希望万能的齐神能够保佑我。打开了AIDA64，一直监测着CPU的温度——毕竟我是怀疑CPU出问题了的。然后我就发现，AIDA64有个功能，叫做“生成报告”，随手就点了进去。然后，搞了一大串东西出来。我就看啊看，天哪，这个东西把我电脑里各种信息都搞出来了，比香港记者的新闻还要详细，不能忍。我就往下看，看到了超频这一项，发现我的CPU超频了15%。我就怀疑，是不是超频让CPU过热了，才造成的死机。 &emsp;&emsp;我就去百毒了一下，怎么去关掉超频。看了一会儿觉得太麻烦，就放弃了。哎~还要进BIOS,还不如等我哥把他的笔记本给我寄过来呢。。。好麻烦~好麻烦。 &emsp;&emsp;刚好，这会儿去问候了一下我们的老学长。老学长提了提裤腰回复道：“你这是睿频吧”。 &emsp;&emsp;天哪，睿频，睿频是啥，我不能说我不知道什么是睿频吧，多丢人。百毒，百毒，赶紧百毒。很关键啊，有一篇很关键的博文告诉我了睿频和超频的区别。好吧，不是这玩意儿的错，那我只能继续求助长者了。 &emsp;&emsp;“是不是你的系统炸了”。 &emsp;&emsp;ありえない、ありえない！有时候关机之后都开不开，怎么可能是软件的问题，肯定是硬件的问题。 &emsp;&emsp;“我觉得不是CPU导致的，你硅脂没涂好吧。” &emsp;&emsp;嘛~不排除这种可能，但是至少比之前的强很多啊。 &emsp;&emsp;长者的话总是言简意赅：“唔。。。那你去看看事件管理器吧。” &emsp;&emsp;事件管理器？事件管理器！事件管理器はなに～？わがりｒない！！！はやく百毒！百毒百毒愛してる～！嗯嗯，百毒不负众望，在众多广告和莆田系医院和工口网站中，我找到了正确答案。 &emsp;&emsp;找啊找啊，摸索了两分钟，搞清楚了这是个什么东西。あああああ～一堆错误和警告啊，作为程序猿，肯定要看错误嘛，警告是个什么东西!程序猿会看的警告，只有FBI的好吗！！！咳~咳~~ &emsp;&emsp;在事件管理器中，我看到了一个比较敏感的时间。2016年9月26日晚上21：40：23。没错了！就是这个时间!第一次自动关机的时候！只要看每次错误关机的时间，以及前面发生了什么！不就知道错误在哪里了吗！！！我真是太机智了!! &emsp;&emsp;这时候，我看到了一连串的四个来自CPU的错误，天哪！肯定是它！绝对是CPU！还说不是！呵呵呵!被我打脸了吧！哈哈哈哈~但是。。。我又去查了一下，好吧，然而并没有什么卵关系，这是因特尔节能技术的那个功能。哎，又一次失望了。 &emsp;&emsp;但是，我又多看了一眼！！！就是你了！犯人就是你!!!! &emsp;&emsp;查了一下，果然，这个服务！就是鲁大师！！！修改的！！！！！鲁大娘！！！！原来罪魁祸首！！！就是你啊！！！！害怕。然后我去开启这个服务，但是发现，缺少模块，还原服务的话虽然可以做到，但是我觉得可以顺便做一个系统嘛，一年了也该换了。再说今天一天都没。。。。不不不！不能奶!好吧，再死机我就装win10。 &emsp;&emsp;胆儿肥了之后，我又上FF14排了个本，打了2小时！@#￥%。（23333懂的都懂）都没有问题。嘛~今天是撑过去了，但是，还是再观察一下吧。反正万一修不好的话（这不是钦定！），有我哥的笔记本嘛~233333。讲道理，这么赛艇的大新闻，还是第一次搞。嘛~自己修的话，还是比那些个电脑店放心靠谱的~。","categories":[],"tags":[{"name":"笔记本","slug":"笔记本","permalink":"http://www.z16388.top/tags/笔记本/"}],"keywords":[]},{"title":"联想Y400拆机换硅脂过程","slug":"联想Y400拆机换硅脂过程","date":"2016-09-29T08:02:08.000Z","updated":"2017-04-13T13:25:20.497Z","comments":true,"path":"2016/09/29/联想Y400拆机换硅脂过程/","link":"","permalink":"http://www.z16388.top/2016/09/29/联想Y400拆机换硅脂过程/","excerpt":"","text":"&emsp;&emsp;最近笔记本出了一个问题，从前天开始，玩着玩着就炸了。从讨鬼传开始，一玩就自动断电，一点办法都没有。前天晚上开始炸了1次，昨天炸了3次，但是还是可以玩的。然后查了一下，可能是散热的问题，就去网上买了硅脂换了。今天换上，还是有些问题，但是整个拆机的过程还是很惊险刺激的，下面分享给大家： &emsp;&emsp;首先是我们今天的患者，联想Y400。 &emsp;&emsp;然后是我们的硅脂：MX-4 &emsp;&emsp;接下来是工具介绍： 一套小螺丝刀一个用来吸螺丝的螺丝刀一个拆笔记本专用的小螺丝刀棉签酒精雕刻刀（不知道干什么用）清灰刷 &emsp;&emsp;之后进行的是Y400的标准拆解过程，将电池拆掉，后盖打开，拆掉硬盘光驱以及内存条。 &emsp;&emsp;然后我们可以拆一下网卡的排线。小心翼翼的用镊子夹掉，然后卸下唯一一个螺丝，就可以拿掉了。 &emsp;&emsp;接下来是拆键盘了。键盘还是比较好拆的，把两个螺丝卸掉，就可以抠出来了。 &emsp;&emsp;然后我们要把键盘面的电源键排线，触控板排线和键盘排线拆掉；再把反面的风扇排线拆掉，再卸掉螺丝，就可以拆掉键盘面的面板了：&emsp;&emsp;这是卸掉的键盘面板： &emsp;&emsp;拆掉之后，把摄像头排线和硬盘排线拆掉，再卸掉主板的两个螺丝就可以拆了。因为有一个风扇的排线不是太好拆，所以我就没拆，但是这样已经可以拆散热件了： &emsp;&emsp;我怕刮花了屏幕，所以就垫了一本书，然后拧掉散热片的螺丝，就可以涂硅脂了。 &emsp;&emsp;涂完之后我就迫不及待地装上去了，虽然打开了，表示存活，也开了下摄像头测试了一下没问题，但是还是会炸。没办法，只能等过年回家找售后了。这学期的话，先学习好吧。这是上天给我的学习的好机会，玩什么游戏！学习！","categories":[],"tags":[{"name":"笔记本","slug":"笔记本","permalink":"http://www.z16388.top/tags/笔记本/"}],"keywords":[]},{"title":"hexo+github博客搭建教程","slug":"hexo-github博客搭建教程","date":"2016-09-13T10:24:56.000Z","updated":"2018-01-10T12:22:49.951Z","comments":true,"path":"2016/09/13/hexo-github博客搭建教程/","link":"","permalink":"http://www.z16388.top/2016/09/13/hexo-github博客搭建教程/","excerpt":"","text":"&emsp;&emsp;之前写了一篇域名绑定的教程，但是只有域名没有东西也不行啊。其实早在前几天就想写这样一篇总结性教程了，但是一直没有抽出时间。我这个博客最初也是在朋友的帮助之下搭建的，这个技术并不难用，所以我想让更多的人能够使用它。 &emsp;&emsp;hexo是一个基于node.jsd静态博客框架。另外，我们可以使用github pages来存放我们的博客。这才有了现在静态博客的黄金搭档hexo+github。 账号注册我们需要以下的账号： &emsp;&emsp;github：用于存放页面，是一个非常流行的开源社区，拥有众多的开源项目。 &emsp;&emsp;多说:用来实现博客的评论和点赞。 &emsp;&emsp;七牛云：用来存放博客中使用的图片。 &emsp;&emsp;阿里云：如果你需要一个域名，可以到阿里云购买。 &emsp;&emsp;CNZZ：如果你需要统计你的博客访问，可以注册一个CNZZ账号，或者是在你的博客首页加上google统计。 环境搭建你需要下载以下几种软件： &emsp;&emsp;Node.js:用来生成静态页面，hexo的环境。 &emsp;&emsp;Git Bash:把本地的内容提交到github上的软件。 &emsp;&emsp;Markdown Pad:用来写博客。 &emsp;&emsp;NotePad++:一款比较好的记事本，用来修改配置文件。 &emsp;&emsp;在github创建一个新的项目，命名为： YourUserName.github.io 开始安装&emsp;&emsp;Node.js和Git Bash安装好之后，首先，创建一个文件夹,比如叫blog，用于存放你的博客相关的文件。然后进入文件夹，开始安装hexo。 &emsp;&emsp;右键，git bash here,打开git bash，然后运行安装命令： npm install -g hexo &emsp;&emsp;然后执行初始化命令： hexo init &emsp;&emsp;打开根目录下的_config.yml配置文件，修改最后的信息为：1234567deploy: type: git repo: Your_git_io_url branch: master &emsp;&emsp;按照备注修改相关的参数，比如博客的名字，你的姓名等等。除此之外，你还可以到hexo的官网的主题页面，去下载你喜欢的主题，放在themes文件夹下。需要修改的参数大部分在主题的配置文件上。当然这一步你以后都可以去做。 &emsp;&emsp;执行命令： npm install hexo-deployer-git –save &emsp;&emsp;执行配置命令： hexo deploy （或者是缩写：hexo d） &emsp;&emsp;至此，博客搭建完成，你可以在浏览器输入http://YourUserName.github.io来访问。每次对博客修改之后，我们都需要先生成(hexo g)，再提交到git(hexo d)。当然，我们可以先进行本地预览，运行本地的服务器(hexo s)，然后用浏览器访问。hexo g和hexo d可以合并成一个指令：hexo d -g &emsp;&emsp;hexo的常用命令和写博客使用的markdown语法请参考： hexo常用命令：http://z16388.top/2016/09/09/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Markdown常用语法：http://z16388.top/2016/09/09/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"}],"keywords":[]},{"title":"Python常用知识","slug":"Python常用知识","date":"2016-09-12T14:04:46.000Z","updated":"2017-04-13T13:25:15.878Z","comments":true,"path":"2016/09/12/Python常用知识/","link":"","permalink":"http://www.z16388.top/2016/09/12/Python常用知识/","excerpt":"","text":"&emsp;&emsp;想要学Python很久了。一是流行，再是强大。现在写一篇博客，整理一下常用的知识点，以备复习。 1.数据类型数据Python可以处理任意大小的整数可以用0xff00的方法表示十六进制整数 浮点数处理的精度也比较高，但是太高精度需要用科学记数法表示 字符串用单引号或双引号括起来转义字符大体同C大量需要转义字符的地方，可以简写成：r’\\\\\\\\\\’Python允许字符串内换行，使用…来表示：123print(str1...str2...str3) 布尔值：true false可使用and or not 运算 Python中的强制类型转换方法如下：12&gt;&gt;&gt;s=input('birth:')&gt;&gt;&gt;birth=int(s) 注意，input()返回的数据类型是str。 运算符/ 除法，结果一定是浮点型// 整除% 求余 2.字符串和字符编码字符串和整数的转换ord()函数，获取字符的整数表示chr()函数，把编码转换成对应的字符可以使用转义字符表示，例如：\\u4e2d会显示代表的汉字”中” 字符串和字节str是字符串类型bytes是字节类型，需要用带b前缀的单引号或双引号表示：x=b’ABC’‘ABC’和b’ABC’占用的内存不同，后者每个字符都只占用一个字节encode()方法可以把str转换成指定的bytes，例如：12&gt;&gt;&gt;'ABC'.encode('ascii')&gt;&gt;&gt;'中文'.encode('utf-8') 把字节转换成字符串需要使用decode()方法：1&gt;&gt;&gt;'ABC'.decode('ascii') len()函数，用于计算str中的字符数和bytes中的字节数（英文字符只占一个字节，中文字符经常占3个字节） 要保证编译的python文件能够正确显示中文，我们除了在编写环境中指定编码类型为utf-8之外，通常还要在开头加上两行：12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 replace()方法，用于取代字符串中某个字符，但是不影响字符串本身：12345&gt;&gt;&gt;a='abc'&gt;&gt;&gt;a.replace('a','A')'Abc'&gt;&gt;&gt;a'abc' 格式化同C的格式化类似1&gt;&gt;&gt; 'Hello, %s' % 'world' %开头的叫做占位字符，常用的占位字符有： %&emsp;&emsp;&emsp;&emsp;整数 %f&emsp;&emsp;&emsp;&emsp;浮点数 %s&emsp;&emsp;&emsp;&emsp;字符串 %x&emsp;&emsp;&emsp;&emsp;十六进制整数 格式化整数和浮点数可以指定是否补0或者确定小数的位数1234&gt;&gt;&gt; '%2d-%02d' % (3, 1)' 3-01'&gt;&gt;&gt; '%.2f' % 3.1415926'3.14' 3.list和tuplelistlist是Python内置的一种数据类型，列表。它是一种有序的集合，可以随时添加和删除其中的元素，声明方式如下：1&gt;&gt;&gt;name=['tom','cat','car'] 可以使用len()函数获取list元素的个数用索引来访问每个元素，索引从0开始：12&gt;&gt;&gt;name[0]tom 可以使用-1做索引，访问最后一个元素，依次类推，可以访问倒数第二，第三个元素：1234&gt;&gt;&gt;name[-1]car&gt;&gt;&gt;name[-2]cat 可以使用append()方法，向list中追加元素到末尾：123&gt;&gt;&gt;name.append('apple')&gt;&gt;&gt;name['tom','cat','car','apple'] 可以使用insert()方法，将元素插入到指定位置，比如下标为1的位置：123&gt;&gt;&gt;name.insert(1,'banana')&gt;&gt;&gt;name['tom','banana','cat','car','apple'] 可以使用pop()方法，删除list末尾的元素：123&gt;&gt;&gt;name.pop()&gt;&gt;&gt;name['tom','banana','cat','car'] 可以使用pop(i)方法，删除指定位置的元素：123&gt;&gt;&gt;name.pop(1)&gt;&gt;&gt;name['tom','cat','car'] 可以使用直接赋值的方法将某元素替换成别的元素：123&gt;&gt;&gt;name.[2]='apache'&gt;&gt;&gt;name['tom','cat','apache'] list中可以存放不同类型的元素，也可以存放list（可以看做二维数组）如果list中没有元素，就是一个空list，长度为0。 tupletuple叫做元组，一旦初始化就不能修改，可以使用索引来访问每个元素，但是不能赋值成另外的元素。因为它无法被修改，所以更加安全。 tuple的定义方法：1234567891011&gt;&gt;&gt;t=(1,2)&gt;&gt;&gt;t(1,2)&gt;&gt;&gt;t=()&gt;&gt;&gt;t()&gt;&gt;&gt;t=(1,)&gt;&gt;&gt;t(1,) 不能使用t=(1)的方法来定义只有一个元素的tuple，这会让python认为它是个括号，而将t认为是一个整形变量。 4.dict和setdictdict即C++中的map，全称是dictionary，具有极快的查找速度。它的元素有两种，一种叫做key，另一种叫做value。前者是查询的参数，后者则是它所对应的值。dict的声明方法如下：123&gt;&gt;&gt;d=&#123;'tom':90,'cat':80,'apache':70&#125;&gt;&gt;&gt;d['tom']90 当然，我们在“放入”的时候也很方便：123&gt;&gt;&gt;d['apache']=60&gt;&gt;&gt;d['apache']60 每个key只对应一个值，后面赋的值会将前面的覆盖。 我们可以使用in来判断一个key是否存在：12&gt;&gt;&gt;'toom' in dFalse 可以使用get方法来获取指定的value。如果不存在，可以返回指定的值：1234&gt;&gt;&gt;d.get('tom')90&gt;&gt;&gt;d.get('tomm',-1)-1 dict的特点 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 setset是一组key的集合，但不存储value。因为key不能重复，所以在set中没有重复的元素。要创建一个set需要提供一个list作为输入集合：1234567&gt;&gt;&gt;s=set([1,2,3])&gt;&gt;&gt;s&#123;1,2,3&#125;&gt;&gt;&gt;s=set([1,1,2,2,3,3])&gt;&gt;&gt;s&gt;&#123;1,2,3&#125; 通过add(key)方法可以添加到set中：123&gt;&gt;&gt;s.add(4)&gt;&gt;&gt;s&#123;1,2,3,4&#125; 通过remove(key)方法可以删除元素：123&gt;&gt;&gt;s.remove(4)&gt;&gt;&gt;s&#123;1,2,3&#125; set可以看成无序无重复元素的集合，可以进行交集，并集等操作：123456&gt;&gt;&gt;s1=set([1,2,3])&gt;&gt;&gt;s2=set([2,3,4])&gt;&gt;&gt;s1&amp;s2&#123;2,3&#125;&gt;&gt;&gt;s1|s2&#123;1,2,3,4&#125; 5.判断与循环判断Python也有if和else语句，但是和C比起来又显得非常“任性”。它没有小括号，也没有大括号，具体例子如下：1234age = 20if age &gt;= 18: print(\"your age is %d\",age) print('adult') 根据Python的缩进规则，如果满足if后的条件，则会执行缩进的两个print语句，else也类似：1234567age = 3if age &gt;= 18: print('your age is', age) print('adult')else: print('your age is', age) print('teenager') 注意不要少写了：。 Python中还有elif语句，也就是else if的缩写，所以if语句的完整版就是：12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 循环for…in循环，可以依次将list或tuple中的每个元素迭代出来：123names=['tom','cat','apache']for name in names: print(name) 执行这段代码，就会依次打印出names中的每个元素：123tomcatapache for x in …循环，可以将元素依次代入变量x，然后执行缩进的语句，例如：1234sum=0;for x in [1,2,3,4,5,6,7,8,9,10]: sum+=x;print(sum) 这段代码显示的结果是0-10的累加和 Python提供了range()函数来生成一个整数序列，比如range(5)生成的是从0开始的5个整数：12&gt;&gt;&gt;list(rangr(5))[0,1,2,3,4] 则0累加到100的程序可以写成：1234sum=0for x in range(101): sum+=xprint(sum) Python中也有while循环，用法和C类似：123456sum=0n=0;while n&lt;101: sum+=n n+=1print(sum)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.z16388.top/tags/Python/"}],"keywords":[]},{"title":"博客第三天","slug":"博客第三天","date":"2016-09-11T14:29:29.000Z","updated":"2017-04-13T13:25:15.948Z","comments":true,"path":"2016/09/11/博客第三天/","link":"","permalink":"http://www.z16388.top/2016/09/11/博客第三天/","excerpt":"","text":"&emsp;&emsp;今天零零星星看了好多东西。早上知乎给我推送了一篇文章，讲的是一些比较好的Python资料。随便点进去一个看了，然后就收藏在手机上了，打算下床用电脑看。之后研究了一会儿插入网易云音乐歌单，然后看了一点儿java，打算写一点网络程序。 &emsp;&emsp;一口气零零散散搞了好多东西，但是什么都没有搞成，什么都没有学到。看来以后应当集中精力去做一件事，一步一个脚印，走好做好，这样才能有更多的收获吧。感觉应该先去整理一下Python的基础知识，然后再看java的多线程和网络，再做一个小东西。当然，六级也要开始准备了，之前计划的日语学习也要开始了。 &emsp;&emsp;要做的事情还有很多，，， &emsp;&emsp;博客的话，明天把插入的音乐改掉，侧边栏减少内容，想办法增加右上角的功能按钮。另外再研究一下今天刚刚搞的Font-Awesome的用法。 &emsp;&emsp;学习是一件很难的事，但是一点一点来，总有能够学成的时候，加油。Yes you can！","categories":[],"tags":[{"name":"心情","slug":"心情","permalink":"http://www.z16388.top/tags/心情/"}],"keywords":[]},{"title":"在博客中插入网易云音乐歌单","slug":"在博客中插入网易云音乐歌单","date":"2016-09-11T03:37:44.000Z","updated":"2017-04-13T13:25:15.956Z","comments":true,"path":"2016/09/11/在博客中插入网易云音乐歌单/","link":"","permalink":"http://www.z16388.top/2016/09/11/在博客中插入网易云音乐歌单/","excerpt":"","text":"&emsp;&emsp;因为版权的原因，网易云音乐已经禁止了歌单的“生成外链播放器”的功能，只能单首歌曲的进行。之前还有查看代码的方法，现在连生成外链播放器的代码都找不到了。但是，方法还是有的。 &emsp;&emsp;首先我们找到以前的代码，以我的歌单为例：1234&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=240 height=100 src=&quot;http://music.163.com/outchain/player?type=0&amp;id=462197233&amp;auto=0&amp;height=430&quot;&gt;&lt;/iframe&gt; &emsp;&emsp;我们来解释一下里面几个比较有用的几个参数： &emsp;&emsp;1.第二行里面的 width=240 height=100 是用来控制播放器的大小的。但是要注意的是，播放器左侧有图片，如果要完全显示的话，宽度一定要长于270&emsp;&emsp;2.第三行有两个比较有用的参数，一个是id 一个是auto。id改成你歌单的ID，可以在网页端进入你的歌单，在地址栏里查看；auto是自动播放属性，0是关闭，非0即开启。后面的height没有任何意义。 &emsp;&emsp;另外歌单的歌曲顺序由加入歌单的顺序决定，这点很麻烦，在歌曲时一定要注意次序。 &emsp;&emsp;令人遗憾的是，网易云音乐的歌单插入毕竟是已经禁止了的功能，有些时候会出现资源加载失败的状况。所以说，想要让自己的博客唱起来，还是只能单个音乐地用。如果想要更好的效果，还是要选用第三方播放器。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"},{"name":"音乐","slug":"音乐","permalink":"http://www.z16388.top/tags/音乐/"}],"keywords":[]},{"title":"博客第二天","slug":"博客第二天","date":"2016-09-10T10:12:05.000Z","updated":"2017-04-13T13:25:15.952Z","comments":true,"path":"2016/09/10/博客第二天/","link":"","permalink":"http://www.z16388.top/2016/09/10/博客第二天/","excerpt":"","text":"&emsp;&emsp;昨天转了很多以前写的东西，搞域名解析到一点多，直到笔记本没电，写博客真心会上瘾啊。 &emsp;&emsp;上午十一点多到一期，等开题，谁知道搞到四点一道都没做出来，真心心累。回到寝室什么都不想干，浑身乏力，好久没有体会过学习的辛苦了。 &emsp;&emsp;总之，从昨天起，开始坚持写吧，也算是对自己的督促。养成习惯，记录自己今天学到了什么，有哪些不做。积少成多，这么做真真是极好的233333。","categories":[],"tags":[{"name":"心情","slug":"心情","permalink":"http://www.z16388.top/tags/心情/"}],"keywords":[]},{"title":"【ACM教程】3.2递归","slug":"【ACM教程】3-2递归","date":"2016-09-10T07:12:02.000Z","updated":"2017-04-13T13:25:20.705Z","comments":true,"path":"2016/09/10/【ACM教程】3-2递归/","link":"","permalink":"http://www.z16388.top/2016/09/10/【ACM教程】3-2递归/","excerpt":"","text":"第二节 递归&emsp;&emsp;递归是一个语言中最难理解的内容之一，它是通过自己调用自己的方法，来进行运算的方法。关于递归有一个非常有意思的定义： 递归：参见“递归” &emsp;&emsp;在生活中，我们也会遇到这样的递归例子： 导员：“你给任课老师请假就行了”。任课老师：“去让你导员给你写个假条”。 &emsp;&emsp;其实在以前的学习中，我们也遇到过递归的思想，数学归纳法就是： 1是正整数如果k是正整数，证明k+1也是正整数若①和②满足，则证明序列n是正整数序列 &emsp;&emsp;C语言和C++是支持递归的。但是，在使用递归的时候，大家应该注意跳出递归的条件，不然就会发生上面导员和任课老师模型之间的无限循环问题。C/C++语言中的递归一般是通过函数来实现的： 1234567func(n) &#123; if(xxx) &#123; func(n+1);&#125;else return xxx;&#125; &emsp;&emsp;像我们常用的求最大公约数最小公倍数的方法，和hdu2018的母牛问题，都是递归的经典题目。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【游戏安利】噬神者","slug":"【游戏安利】噬神者","date":"2016-09-10T00:56:37.000Z","updated":"2017-04-13T13:25:20.518Z","comments":true,"path":"2016/09/10/【游戏安利】噬神者/","link":"","permalink":"http://www.z16388.top/2016/09/10/【游戏安利】噬神者/","excerpt":"","text":"&emsp;&emsp;噬神者是我非常喜欢的游戏系列，它由日本万代南梦宫制作发行，初版在psp上，二代之后以及我要安利的狂怒解放和解放重生都是在PS4，PSV，Steam三平台都有的。 &emsp;&emsp;要说玩，那玩的时间可不少，但是让我安利的话，我却不知道怎么说了。于是，我就问我的联机群里的小伙伴们，如果让他们安利，他们会怎么做。 乳摇 大枪 啪啪啪 &emsp;&emsp;群里的月冷dalao是这么说的。 mh式的操作，精美的人设，未来风，武器多且酷炫，各种大触的子弹，alisa &emsp;&emsp;群里的英灵Archer是这么说的。 &emsp;&emsp;嘛~这里顺便说一下，噬神者Steam联机群： &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;533840872 &emsp;&emsp;但是，其实让我来说的话，作为一个动漫风格，剧情很好的共斗游戏，和朋友在一起联机的体验是最好的。当劳累了一天，和朋友们在游戏里用子弹对♂轰时，仿佛一天的压力都没了。 &emsp;&emsp;嘛~总之，我安利一个人也是马马虎虎的。拉他进群，下午就买游戏了。。。 &emsp;&emsp;还是放一个宣传片吧，官方的安利还是更可靠点的呢2333。","categories":[],"tags":[{"name":"心情","slug":"心情","permalink":"http://www.z16388.top/tags/心情/"},{"name":"游戏安利","slug":"游戏安利","permalink":"http://www.z16388.top/tags/游戏安利/"},{"name":"游戏","slug":"游戏","permalink":"http://www.z16388.top/tags/游戏/"},{"name":"Steam","slug":"Steam","permalink":"http://www.z16388.top/tags/Steam/"}],"keywords":[]},{"title":"给Github Pages绑定阿里云域名","slug":"给Github-Pages绑定阿里云域名","date":"2016-09-09T15:54:20.000Z","updated":"2018-01-10T12:45:23.840Z","comments":true,"path":"2016/09/09/给Github-Pages绑定阿里云域名/","link":"","permalink":"http://www.z16388.top/2016/09/09/给Github-Pages绑定阿里云域名/","excerpt":"","text":"&emsp;&emsp;我在阿里云上注册了一个域名，现在想把它和我的Github Pages绑定起来，也就是说我想达到访问这个域名，能够进入我的博客的目的。 第一步&emsp;&emsp;运行cmd，输入 1ping yourusername.github.io &emsp;&emsp;然后我们会看到一个IP地址。 第二步&emsp;&emsp;在你的阿里云域名解析设置中，添加以下两项内容 A&emsp;&emsp;&emsp;&emsp;www&emsp;&emsp;&emsp;&emsp;&emsp; Your IPA&emsp;&emsp;&emsp;&emsp;@&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; Your IP &emsp;&emsp;保存，等待十分钟左右，你就可以使用你的域名来访问你的博客了。 &emsp;&emsp;除此之外，你需要在你的github pages项目的根目录新建一个CNAME文件，用于存放显示给用户的域名。如果你的域名是def.com，你的CNAME存放的域名是blog.def.com，那么用户在浏览器看到的域名将会是blog.def.com。需要注意的是，每一个github pages项目只能绑定一个域名。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"},{"name":"域名","slug":"域名","permalink":"http://www.z16388.top/tags/域名/"}],"keywords":[]},{"title":"【ACM教程】2.XJAVA大数","slug":"【ACM教程】2-4JAVA大数","date":"2016-09-09T14:35:24.000Z","updated":"2017-04-13T13:25:20.755Z","comments":true,"path":"2016/09/09/【ACM教程】2-4JAVA大数/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】2-4JAVA大数/","excerpt":"","text":"第X节 JAVA大数&emsp;&emsp;由于近些年，大数据的兴起，在ACM比赛中，经常会出现大数的问题。 &emsp;&emsp;大数，字面意思很简单。而在编程中，特指超过32位二进制的数。虽然低于64位的数据计算可以使用long long 的数据类型，但是如果出现乘法，则难免会越界。这样的问题，我们称为大数问题。 &emsp;&emsp;虽然C++给我们提供了大数，但是使用起来不是很方便。特别是在处理乘法和除法的时候，代码可能会达到上百行。JAVA的大数类则比较实用，在ACM竞赛中，我们大多使用JAVA语言进行大数题目的计算。下面是JAVA大数加法的程序:12345678910111213import java.math.BigInteger; import java.util.Scanner; public class Main &#123; public static void main (String args[]) &#123; Scanner in = new Scanner(System.in); while(in.hasNextBigInteger()) &#123; BigInteger a = in.nextBigInteger(); BigInteger b = in.nextBigInteger(); System.out.println(b.add(a)); &#125; in.close(); &#125; &#125; &emsp;&emsp;需要特别注意的是，普通的四则运算符号在大数加减时不能使用，我们要使用类似于C++中运算符重载的方法来进行计算。常用的几种运算如下： add( ) 加法subtract( ) 减法multiply( ) 乘法divide( ) 除法remainder ( ) 求余abs( ) 绝对值pow( int n ) n次幂 &emsp;&emsp;不仅如此，大数只能和大数进行运算。在需要使用常数的时候，我们需要用下面这种方法进行定义：1BigInteger a = new BigInteger ( “XXXXXXX” ); 练习： &emsp;&emsp;&emsp;&emsp;Ti6奖金池","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】2.3排序、查找与初始化","slug":"【ACM教程】2-3(旧)排序、查找与初始化","date":"2016-09-09T14:26:37.000Z","updated":"2017-04-13T13:25:20.772Z","comments":true,"path":"2016/09/09/【ACM教程】2-3(旧)排序、查找与初始化/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】2-3(旧)排序、查找与初始化/","excerpt":"","text":"第三节 排序、查找与初始化&emsp;&emsp;STL指的是C++的标准模板库。使用STL能给我们带来很大的便利，但是它比较复杂，我们只选取一些算法竞赛中常用的STL进行一系列的讲解。首先，我们先学习第一部分。排序和初始化。 排序与查找&emsp;&emsp;排序与查找是两个对于数据常用的操作。C++给我们提供了sort() 和lower_bound() 两个函数来实现这两个功能，这两个函数都在algorithm头文件中。首先，介绍一下两个函数的参数。 sort（起始地址，终点地址，比较方法）；lower_bound（起始地址，终点地址，查找元素）； &emsp;&emsp;sort() 函数可以对任意对象进行排序，不一定是默认的数据类型。但是，在使用其他类型的时候，我们要首先要对该类型进行“大于”或者“小于”运算进行定义。排序的对象可以存放在数组里，也可以存放在vector中（动态数组，以后会进行讲解）。但是，在使用的细节上有所不同。前者是：sort(a,a+n) 后者是：sort(v.begin(),v.end())。 Lower_bound() &emsp;&emsp;这个函数的作用是查找“大于或等于x的第一个位置”。 &emsp;&emsp;stable_sort()函数和sort()函数类似，与后者的区别是，排序之后，不改变相同值元素的相对位置。我们称stable_sort()为稳定排序，举个例子，a1,a2,a3,a4,a5是一数组，其中a2=a4，那么经过排序之后是：a1,a2,a4,a3,a5，我们能看到，排序前后a2总是在a4的前面。在数组的排序中，可能效果不太明显，但是如果是对结构体的排序就会有明显的区别。 &emsp;&emsp;使用这两个函数，将会给我们带来很大的便利。不仅缩短了代码的长度，而且可能要比我们所了解的各种排序查找方法更加优秀，无论是时间复杂度或者空间复杂度。 &emsp;&emsp;请练习下面的题目： &emsp;&emsp;&emsp;&emsp;好汉杯积分问题 &emsp;&emsp;请练习下面的题目： &emsp;&emsp;&emsp;&emsp;我要送人头！","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】2.3竞赛C++入门","slug":"【ACM教程】2-3竞赛C++入门","date":"2016-09-09T14:11:43.000Z","updated":"2017-04-13T13:25:20.765Z","comments":true,"path":"2016/09/09/【ACM教程】2-3竞赛C++入门/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】2-3竞赛C++入门/","excerpt":"","text":"第三节 竞赛C++入门&emsp;&emsp;本系列文章是以读者学习过C语言为背景的。C语言是一门很好的语言，但是在算法竞赛中却不是十分流行。举个例子：在2013年的ACM/ICPC世界总决赛中，有1347份代码使用C++提交，323份使用Java提交，但唯独C语言没有人使用。 &emsp;&emsp;在我们参加各类软件竞赛时，C语言的程序代码其实都可以直接作为C++程序来进行编译。C++博大精深，但是也会有很多让人诟病的地方。我们在比赛中，重点只需要利用它其中很少的一部分特性。 C++框架&emsp;&emsp;虽然C语言的程序可以直接在C++中运行，但是并不是以C++的写法，下面简单地区别一下两种语言。 C:a+b。12345678#include&lt;stdio.h&gt; int main() &#123; int a,b; while(scanf(\"%d%d\",&amp;a,&amp;b)==2) printf(\"%d\\n\",a+b); return 0; &#125; C++:返回两个个实数中，较小的一个的绝对值。123456789101112#include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; int main() &#123; double a,b; while(cin&gt;&gt;a&gt;&gt;b) &#123; cout&lt;&lt;fabs(min(a,b))&lt;&lt;endl; &#125; return 0; &#125; &emsp;&emsp;首先，和之前我们写的C程序进行比较，在我们使用数学相关的函数时，调用的头文件变成了cmath。实际上math.h依然存在，但是在C++中我们比较推荐使用cmath。类似地，stdio.h变成了cstdio，string.h变成了cstring。 &emsp;&emsp;其次，在我们新增的两个头文件中：iostream提供了输入输出流，而algorithm则提供了一些常用的算法，就比如我们刚刚使用的min()函数。但是，在比赛中建议大家手动编写max和min函数，以免发生意外。 &emsp;&emsp;cin&gt;&gt;a 和 cout&lt;&lt;a 就是我们前面提到的输入输出流，他们就相当于C语言中的scanf和printf函数。相比于后面两个函数，我们在使用输入输出流时省略了%d、%s等占位符。一个是简化了这些繁琐的东西，再一个可以轻易地避免long long 型的输入输出占位符不统一的问题（%i64d、%lld）。但是，C++流是不完美的，其最致命的缺点就是运行太慢，以致于有些题目会在后面明确注明：本题的输入量很大，请不要使用C++的流输入。另外，不要将cout和printf混合使用，会造成输出的数据混乱。 &emsp;&emsp;cin&gt;&gt;a我们还看到了有这一行：using namespace std; 。在C++中，有个概念叫做名称空间。把函数放在名称空间里，我们可以通过这样的方法进行调用： 空间名:函数名(); &emsp;&emsp;cin&gt;&gt;a而我们头文件iostream和algorithm就是放在std 名空间中的。如果我们在写程序的时候，不把std里的名字导入默认空间，那么我们在使用输入输出流的时候就要这么写了： std:cin&gt;&gt;a;std:cout&lt;&lt;a; &emsp;&emsp;C++和C语言的数据类型非常相近，最显著的区别就是多了一个bool类型（ture/false）。 引用&emsp;&emsp;如果想要在一个函数中去操作主函数中的数值，我们除了可以利用指针之外，C++还给我们提供了引用。相比于指针，引用的功能上比指针要弱，但是减少了出错的可能，还能提高代码的可读性。下面我们来看一个例子:1234567891011121314#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; void swapp(int&amp; a,int&amp; b) &#123; int t=a;a=b;b=t; &#125; int main() &#123; int a=3,b=4; swapp(a,b); cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;endl; return 0; &#125; &emsp;&emsp;在上面的程序中，我们使用了饮用。在参数的前面加上“&amp;”符号，就表示这个传参是按照传引用的方式进行传递，而不是C语言中的按值传递。这样，在上面的函数内改变参数的值，也会修改到函数的实参。 模板&emsp;&emsp;在之前，我们可能接触过一些C++给我们提供的函数，比如sort()。默认的函数功能是提供从小到大的排序。如果我们需要从大到小排序，难道需要我们重写sort()吗。 &emsp;&emsp;C++给我们提供了模板功能，可以对一些函数进行修改。 &emsp;&emsp;sort()函数的参数实际上有三个：sort(begin,end,[compare]);第三个是非必填项，意思是排序方式。我们只需要在使用sort函数之前，对它的排序方式进行规定，就可以实现从大到小的排序了。下面是代码：1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;bool compare(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int a[5]; for(int i=0;i&lt;5;i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+5,compare); for(int i=0;i&lt;5;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】2.1常用输入输出格式","slug":"【ACM教程】2-1常用输入输出格式","date":"2016-09-09T12:34:22.000Z","updated":"2017-04-13T13:25:20.793Z","comments":true,"path":"2016/09/09/【ACM教程】2-1常用输入输出格式/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】2-1常用输入输出格式/","excerpt":"","text":"第一节 常用输入输出格式&emsp;&emsp;写程序，大家都会写。但是在比赛里面怎样写程序，应该按照怎样的格式去写程序，都是有严格的要求的。下面简单介绍一下各种比赛中，常见的输入输出格式。 OI&emsp;&emsp;OI比赛中，输入输出均需要使用文件操作。常见的格式如下：123456789101112#include&lt;stdio.h&gt; int main() &#123; FILE *fin,*fout; fin=fopen(\"fin.txt\",\"r\"); fout=fopen(\"fout.txt\",\"w\"); int a,b,sum; fscanf(fin,\"%d %d\",&amp;a,&amp;b); sum=a+b; fprintf(fout,\"%d\\n\",sum); return 0; &#125; 蓝桥杯&emsp;&emsp;蓝桥杯比赛对格式的要求不是很高，养成良好的代码书写习惯即可。123456#include&lt;stdio.h&gt; int main() &#123; printf(\"Hello world\\n\"); return 0; &#125; ACM&emsp;&emsp;ACM比赛中，对输入输出的要求多种多样。因为题目都是英语，所以大家应当仔细审题，控制好输入和输出。其中，一下几种情况会经常出现。 &emsp;&emsp;第一种，输入一个或一组数据。方法同蓝桥杯比赛。123456#include&lt;stdio.h&gt; int main() &#123; printf(\"Hello world\\n\"); return 0; &#125; &emsp;&emsp;第二种，输入多组数据。题目中，常见的描述方式为：The input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line.1234567891011#include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; int main() &#123; int i,j; while(scanf(\"%d%d\",&amp;i,&amp;j)!=EOF) &#123; printf(\"%d\\n\",i+j); &#125; return 0; &#125; &emsp;&emsp;这里我们的输入语句是写在while循环语句里面的，后面有一个!=EOF。EOF是文件结尾的标志，也就是说循环在输入结束时停止。这种输入方法在ACM中最为常见，大家应当熟练掌握。 &emsp;&emsp;第三种，输入多组数据，直到遇到0，0这组数据时，停止输入。常见描述方式为：Input contains multiple test cases. Each test case contains a pair of integers a and b, one pair of integers per line. A test case containing 0 0 terminates the input and this test case is not to be processed.1234567891011#include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; int main() &#123; int i,j; while(scanf(\"%d%d\",&amp;i,&amp;j)&amp;&amp;(i||j)) &#123; printf(\"%d\\n\",i+j); &#125; return 0; &#125; &emsp;&emsp;第四种，输入一个数字n，接下来输入n组测试数据。常见的描述方式为：Input contains an integer N in the first line, and then N lines follow.1234567891011121314#include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; int main() &#123; int n; scanf(\"%d\",&amp;n); while(n--) &#123; int i,j; scanf(\"%d%d\",&amp;i,&amp;j); printf(\"%d\\n\",i+j); &#125; return 0; &#125; &emsp;&emsp;另外，在输入字符串时，我们可以使用gets()函数12char buf [ 20 ] ; gets ( buf ) ; 练习题目：hdu1089~hdu1096题","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】1.3常用编译环境与OJ系统","slug":"【ACM教程】1-3算法竞赛介绍","date":"2016-09-09T11:35:32.000Z","updated":"2017-04-13T13:25:15.888Z","comments":true,"path":"2016/09/09/【ACM教程】1-3算法竞赛介绍/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】1-3算法竞赛介绍/","excerpt":"","text":"第三节 常用编译环境与OJ系统编译环境&emsp;&emsp;编译环境就是我们编写代码时所使用的软件。在参加算法类竞赛时，我们通常使用以下三种软件。 DEV-C++ &emsp;&emsp;Dev-C++为OI和蓝桥杯C/C++组比赛中的指定编译环境。 Code::Blocks &emsp;&emsp;Code::Blocks为ACM比赛中指定的C/C++编译环境。 Eclipse &emsp;&emsp;Eclipse为蓝桥杯java组和ACM中指定的java编译环境。 常用OJ系统HDU: http://acm.hdu.edu.cn/PKU: http://poj.org/Clang: http://www.clang.cc/Codevs: http://www.codevs.cn/51nod: http://www.51nod.com/","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】1.2算法竞赛介绍","slug":"【ACM教程】1-2算法竞赛介绍","date":"2016-09-09T11:21:37.000Z","updated":"2017-04-13T13:25:20.799Z","comments":true,"path":"2016/09/09/【ACM教程】1-2算法竞赛介绍/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】1-2算法竞赛介绍/","excerpt":"","text":"第二节 算法竞赛介绍&emsp;&emsp;本教程是针对参加各种算法竞赛的同学们编写的。这一节主要介绍几种比较有名的算法竞赛。 OI(Olympiad in Informatics，信息学奥林匹克竞赛)&emsp;&emsp;OI是Olympiad in Informatics的简称，1987年，保加利亚的Sendov教授在联合国教科文组织第24届全体会议上，倡议举行国际信息学奥林匹克，定名为International Olympiad in Informatics，简称IOI。OI是面向中学生的一年一度的信息学科竞赛。第一届国际信息学奥林匹克竞赛于1989年在保加利亚的布拉维茨举行。 &emsp;&emsp;考的内容主要是计算机编程。OI的比赛有NOIP，NOI，IOI等。NOIP是最初级别的比赛，分初赛和复赛，初赛为笔试，选出成绩优秀的选手参加复赛；复赛是上机编程，选出各个省市的一等奖，参加省级OI（NOIP是参加NOI的必备条件）。NOI是通过NOIP或各省省选选出的优秀选手组成省队参加的全国比赛。NOI选出全国一二三等奖，并选出国家集训队。 &emsp;&emsp;中国队参加8届大赛，届届名列前茅。中国队共计派出选手31人次，全部获奖，累计金牌17块、银牌6块，铜牌8块。在这种世界级别的智能大赛中，中国的娃娃们给参赛国的领队和选手留下了深刻的印象，盛赞“中国队是整体实力最强的队”。在波IOI’92 的发奖大会上，组委会为金牌得主设置了6台高档微计算机， 中国队捧回了3台。在IOI’94（瑞典），黄天明同学编的程序比组委会的标准答案运行速度快了20倍，组委会非常欣赏，派专人到中国队驻地索取原程序。1995年中国队首次派女选手参加IOI， 结果两位女选手杨域和林凌荣登金牌领奖台，填补了国际信息学赛事上女选手从未拿过金牌的空白，引起轰动。IOI’96（匈牙利）中国队经努力拼搏，4名选手夺得4枚金牌，实现了全“金”的突破，创造了新的纪录。近几年来，中国选手在国际信息学奥林匹克竞赛中表现优异，已连续三年在IOI中全部摘得金牌。 ACM-ICPCACM-Association for Computing Machinery，国际计算机学会。ICPC-International Collegiate Programming Contest，国际大学生程序设计竞赛。 &emsp;&emsp;ACM国际大学生程序设计竞赛是由国际计算机学会（ACM）主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过近40年的发展，ACM国际大学生程序设计竞赛已经发展成为最具影响力的大学生计算机竞赛。赛事目前由IBM公司赞助。 &emsp;&emsp;赛事由各大洲区域预赛和全球总决赛两个阶段组成。各预赛区第一名自动获得参加全球总决赛的资格。决赛安排在每年的3-4月举行，而区域预赛一般安排在上一年的9-12月举行。一个大学可以有多支队伍参加区域预赛，但只能有一支队伍参加全球总决赛 &emsp;&emsp;竞赛进行5个小时，一般有11—13道试题，由同队的三名选手使用同一台计算机协作完成。当解决了一道试题之后，将其提交给评委，由评委判断其是否正确。若提交的程序运行不正确，则该程序将被退回给参赛队，参赛队可以进行修改后再一次提交该问题。竞赛结束后，参赛各队以解出问题的多少进行排名，若解出问题数相同，按照总用时的长短排名。总用时为每个解决了的问题所用时间之和。一个解决了的问题所用的时间是竞赛开始到提交被接受的时间加上该问题的罚时(每次提交通不过，罚时20分钟)。没有解决的问题不记时。美国英语为竞赛的工作语言。竞赛的所有书面材料(包括试题)将用美国英语写出，区域竞赛中可以使用其它语言。总决赛可以使用的程序设计语言包括pascal，c，c++及java，也可以使用其它语言。具体的操作系统及语言版本各年有所不同。 竞赛流程：123456参赛队伍最多由三名参赛队员组成。 竞赛中一般命题10题左右，试题描述为英文，比赛时间为5个小时，前四个小时可以看到实时排名，最后一小时封榜，无法看到排名。竞赛可以使用的语言：C++、C、Java和Pascal。但final赛只有C/C++;重点考察选手的算法和程序设计能力，不考察任何Windows编程知识；选手可携带任何非电子类资料，包括书籍和打印出来的程序等，部分赛区会对携带的资料进行限制；评委负责将结果（正确或出错的类型）通过网络尽快返回给选手，除此之外不提供任何额外帮助； 返回结果：1234567Accepted. ---通过！(AC)Wrong Answer. ---答案错。(WA)Run Time Error. ---程序运行出错，意外终止等。(RTE)Time Limit Exceeded. ---超时。程序没在规定时间内出答案。(TLE)Presentation Error. ---格式错。程序没按规定的格式输出答案。(PE)Memory Limit Exceeded. ---超内存。程序没在规定空间内出答案。(MLE)Compile Error. ---编译错。程序编译不过。(CE) ACM试题的特点：1234严格的输入输出格式，有一点儿偏差都不能够AC；对算法的高效有着极致的追求，即使算法正确，但是如果效率不高，也不能AC；测试数据庞大，即使算法是正确的，不能应对极端的测试数据的话，也不能AC；强调解决实际问题的能力，试题大多会有大篇幅的描述，需要有一定的读题能力，分析能力，当然，英语也很重要。 蓝桥杯&emsp;&emsp;蓝桥杯由工业和信息化部人才交流中心举办，全称为：“全国软件专业人才设计与创业大赛”。包含个人和团队两个比赛项目。个人竞赛分为：C/C++本科A组，C/C++本科B组，C/C++高职高专组，java本科A组， java本科B组，java高职高专组，嵌入式设计与开发大学组，嵌入式设计与开发研究生组，单片机设计与开发本科组，单片机设计与开发高职高专组，电子设计与开发本科组，电子设计与开发高职高专组共12个组别。每位选手只能参加其中一个组别的竞赛。 &emsp;&emsp;蓝桥杯算法类比赛是一个比较新的比赛，到2016年共举办了七次，在国内外的知名度还不是很高。但是获得省赛一等奖以上可以获得IBM颁发的“高级软件工程师认证”和工信部颁发的“电子信息从业人员高级证书”。 参考资料： IOI官方网站： ACM-ICPC：https://icpc.baylor.edu/ 蓝桥杯官方网站：http://www.lanqiao.org/","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"【ACM教程】1.1算法概述","slug":"【ACM教程】1-1算法概述","date":"2016-09-09T11:00:24.000Z","updated":"2017-04-13T13:25:20.805Z","comments":true,"path":"2016/09/09/【ACM教程】1-1算法概述/","link":"","permalink":"http://www.z16388.top/2016/09/09/【ACM教程】1-1算法概述/","excerpt":"","text":"第一节 算法概述算法是什么？&emsp;&emsp;算法是软件工程非常重要的基础科目。简单来说，算法就是解决特定问题的方法和步骤。为了解决现实生活中的各种问题，我们就把现实问题对应成数学问题，然后设计公式，编写程序，让计算机编译，运行得到答案——这时候运用的方法就是算法。 &emsp;&emsp;尽管这里运用了“公式”这个词来形容算法，然而算法并不是大家印象中死板的数学公式。因为计算机能够执行复杂的计算，所以公式可以设计成好几行，甚至几百行，用到很多数学理论。因此，就算学习过算法的人，也不一定会设计算法。因为数学、程序上面的东西都比较复杂。想要把现实中的问题对应到数学问题，那就更加复杂了。 &emsp;&emsp;通常，算法具有由三部分组成：输入、输出、计算过程。说到这里，大家可能会联想到函数。 &emsp;&emsp;输入、输出是一个或一组数据，实际上是将这些数字放在数据结构中比如数组、链表。输入的来源，通常是硬盘中存储的数据，或者是由键盘输入的数字；输出的去处可能是硬盘中的文件或是由硬盘中的数据转换之后以其他的形式呈现，例如显示器。 &emsp;&emsp;计算过程是一连串处理数字的指令。指令有两种类型，一种是运算，例如数学运算的加减乘除、逻辑预算的与或非、比较大小、位运算等等；另一种则是读写，例如读取某处的数字，存储数字至某处。 &emsp;&emsp;在算法之前的定义中，算法的计算步骤必须是有限的。用程序的语言说：算法不能无限轮回。之所以规定算法的步骤有限是为了方便统计计算的步数。但是事实上，很多的计算机程序都是开启之后保持运行的状态，直到遇到死机或者关机。例如用于网络传输的算法。因此，实际上，算法是可以有无限步的。 计算机只会算数字&emsp;&emsp;计算机就是一台用于计算的机器，它只会计算、判断以及存储数据，但是能够做得又快又准。而程序，是一连串计算、判断、存储数据的过程。 &emsp;&emsp;计算机只会处理二进制数字，计算机中的每一个文字、每一种颜色、每一种声音，都有它所对应的数字。例，我们规定：用1代表数字“一”，用2代表汉字“乙”，用3代表汉字“人”…一个数字对应一个汉子。按照这样的规定，计算机中所有的汉字都变成了数字。同理，呈现在电脑屏幕上的不同颜色、图片、影像等，都可以转化成数字。一切事物在计算机里都是数字。 &emsp;&emsp;如果我们想要利用计算机解决实际问题，通常要考虑两个方面：一、计算机应该使用哪些设备?计算机如何操作这些设备？二、显示问题如何对应到数学问题?如何设计算法？当然，编写程序，计算数字，这就是程序设计师的工作。 数学和程序这么复杂，为什么要用计算机解决现实问题？&emsp;&emsp;计算机解决问题的速度很快，一秒可以进行几千万次以上的计算。即使是很大的数据量，计算机也能够轻松解决。打开计算机中的一份文件，用鼠标滑动页面。眼镜还没来得及眨一下，正确的内容就已经显示在显示器上了。事实上，在我们滑动页面的时候，计算机已经完成了很多次的计算，然后把正确的内容展示在显示器上了。 &emsp;&emsp;人们想要用计算机来解决问题，就是因为它速度快，正确率高，而且计算机会按照人们设计的程序来进行运算。程序设计师只要设计好一个好的程序，接下来的工作就可以让计算机代劳了。计算机的运算速度比人要更快更好，计算机做得到人类做不到是事。相比于算法的复杂，程序和计算机的组合能够给人们带来更多的便利。现在，计算机应用在人们生产生活的各个方面，程序设计师们设计的程序也在世界各地发光发热。 如何表示一个算法&emsp;&emsp;有人用伪代码来表示一个算法。如要实际计算机程序，伪代码是比较方便使用的。下面是一段伪代码：1234567GREATEST_COMMON_DIVISOR(a, b) while a ≠ b do if a &gt; b then a ← a - b else b ← b - a return a &emsp;&emsp;当然，你也可以使用流程图来表示一个算法。下面是一个流程图： 如何实现一个算法&emsp;&emsp;实现的意思就是实际操作，实际运行。对于程序设计师来说，就是把算法写成程序，比如C/C++程序或者是java程序，然后在计算机上去执行。这个是我们接下来我们主要研究的东西。 衡量算法优良的标准&emsp;&emsp;要评价一个算法的好坏，最基本的两个指标就是时间复杂度和空间复杂度。用直观的感觉来说，就是程序的执行时间和内存使用量。但是由于不同的计算机执行时间会有所不同，而且这两项指标同时会受到程序语言的类型、程序设计的技巧的影响。因此，执行时间和内存使用量并不是一个稳定的评判标准。1234for ( i = 0 ; i &lt; length(A) ; i ++ ) for (j = 0 ; j &lt; length(A)-I ; j ++ ) if A [ j ] &lt; A [ j+1] swap A [ j ] and A [ j+1 ] &emsp;&emsp;上面的程序是一个简单的数组排序问题，我们经常采用统计计算步骤的方法来去衡量一个算法的时间复杂度。1234567 Code stepfor ( i = 0 ; i &lt; length(A) ; i ++ ) n for (j = 0 ; j &lt; length(A)-I ; j ++ ) n ( n - 1) / 2 if A [ j ] &lt; A [ j+1] &#123; n ( n - 1) / 2 Temp = A [ j ] ; n ( n - 1) / 2 A [ j ] = A [ j + 1 ] ; n ( n - 1) / 2 A [ j + 1 ] = temp ; n ( n - 1) / 2 Sum = n + 5n ( n – 1 ) / 2= n + 2.5n2 – 2.5n= 2.5n2 – 1.5n= O ( n2 ) &emsp;&emsp;像上面那个算法，我们称它的时间复杂度为O ( n2 )。这是因为在上式中，我们进行的并不是精确的步骤计算。针对不同的数据，系数变动会很大。因此，我们只取代数式的最高次方。最高次方越大，时间复杂度越高，算法的速度也就越慢。并且，我们规定n必须足够大。尽管这样的估算并不是非常精准，但是还是可以对一些常见的算法进行简易的分类，粗略地比较快慢。 &emsp;&emsp;下面是几种常见算法的时间复杂度和空间复杂度。（空间复杂度的计算和时间复杂度类似。）1234567type time spacebubble sort ( 冒泡排序 ) O ( n2 ) O ( n ) insertion sort ( 插入排序 ) O ( n2 ) O ( n ) merge sort ( 归并排序 ) O ( n log ( n ) ) O ( n ) quicksort ( 快速排序 ) O ( n2 ) O ( n ) heapsort ( 堆排序 ) O ( n log ( n ) ) O ( n ) counting sort ( 计数排序 ) O ( n + r ) O ( n + r ) 学习编程语言&emsp;&emsp;学习编程语言，有两个层次：一是语言本身的语法，二是把算法转换成代码的能力。算法固然重要，然而更重要的是用一种语言来把它表述出来，这样它才能发挥作用。而使用编程语言将算法描述出来这个过程，正是我们今后学习的重点。关于各种编程语言，本教程不作详细介绍，因为其他的书籍已经介绍得足够详细了。接下来对算法的描述，以C/C++语言为主，部分辅以java语言。 参考书目： 1.《算法竞赛入门经典（第二版）》 （刘汝佳编著，2009年，清华大学出版社）2.《数据结构实用教程（C语言版）（第二版）》（2009年，清华大学出版社）","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"ACM教程","slug":"ACM教程","date":"2016-09-09T10:53:22.000Z","updated":"2018-01-10T12:42:57.602Z","comments":true,"path":"2016/09/09/ACM教程/","link":"","permalink":"http://www.z16388.top/2016/09/09/ACM教程/","excerpt":"","text":"ACM教程前言&emsp;&emsp;从今天起，我将会在我的博客同步更新我的ACM教程系列。虽说是教程，但是两年ACM经历的我还是有许多要学的东西，在这里写下自己的学习经历，也算是共同进步吧。 目录第一章 简介第1节 算法概述第2节 算法竞赛介绍第3节 常用编译环境与OJ系统大连交通大学 软件竞赛协会介绍第二章 走进算法竞赛第1节 常用输入输出格式第2节 从排序开始第3节 竞赛C++入门第4节 编程细节第5节 数学简单问题第X节 JAVA大数第三章 算法初步第1节 枚举第2节 递归第3节 二分查找第4节 数据结构基础（1）栈、队列和链表第5节 常用C++容器vector,set和map第6节 数据结构基础（2）树、二叉树和图第7节 排序（一）第8节 从全排列到深度优先搜索算法第四章 动态规划第1节 动态规划简介第2节 动态规划初体验第3节 下降/非降子序列问题第五章 图论第1节 图论的基本概念第2节 图的存储方式第3节 单源最短路径Dijkstra算法附录HDU答案：http://www.z16388.top/answer/ ACM常用模板：http://www.z16388.top/2016/10/30/ACM常用模版/ 第六届蓝桥杯C/C++省赛B组题目详解：http://www.z16388.top/2017/03/21/lanqiao6/ 第七届蓝桥杯C/C++省赛B组题目详解:http://www.z16388.top/2017/02/21/lanqiao7/","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://www.z16388.top/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://www.z16388.top/tags/算法/"},{"name":"ACM教程","slug":"ACM教程","permalink":"http://www.z16388.top/tags/ACM教程/"}],"keywords":[]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2016-09-09T10:38:06.000Z","updated":"2017-04-13T13:25:15.863Z","comments":true,"path":"2016/09/09/hexo常用命令/","link":"","permalink":"http://www.z16388.top/2016/09/09/hexo常用命令/","excerpt":"","text":"hexo常用命令笔记 1.hexo相关123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 2.常用的缩写12345hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 持续更新","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"}],"keywords":[]},{"title":"Markdown常用语法","slug":"Markdown常用语法","date":"2016-09-09T09:35:47.000Z","updated":"2017-04-13T13:25:15.875Z","comments":true,"path":"2016/09/09/Markdown常用语法/","link":"","permalink":"http://www.z16388.top/2016/09/09/Markdown常用语法/","excerpt":"","text":"Markdown常用语法 一.标题&emsp;&emsp;使用#来表示标题d大小。123# 一级标题## 二级标题### 三级标题 二.列表&emsp;&emsp;用-、+或者*来使用无序列表，数字后加点使用无序列表。 无序列表1234无序列表- 1- 2- 3 1 2 3 有序列表12345有序列表1. abc2. def3. ghi abc def ghi 嵌套列表12345678嵌套列表- 嵌套列表1 + 嵌套列表2 + 嵌套列表3 - 嵌套列表4 * 嵌套列表5- 嵌套列表6 嵌套列表1 嵌套列表2 嵌套列表3 嵌套列表4 嵌套列表5 嵌套列表6 三.引用&emsp;&emsp;使用大于号&gt;来表示引用。1&gt;这里是引用 这里是引用 四.图片与链接123456![图片名](图片链接)[链接名](链接地址)&lt;链接&gt;图片：![百毒](https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png)链接：[bilibili](http://www.bilibili.com/)&lt;http://www.bilibili.com/&gt; 五.字体&emsp;&emsp;支持html字体。1234567**粗体** *斜体* &lt;del&gt;删除线&lt;/del&gt;&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt; 六.分割线1--- 七.代码把代码用三个`符号括起来，可以选择所使用的语言。123456#include&lt;stdio.h&gt;int main()&#123; printf(\"Hello world\\n\"); return 0;&#125; 八.注释1&lt;!-- 注释 --&gt; 九.转义字符及空格&emsp;&emsp;同html。12345678910111213141516171819202122232425262728\\\\ 反斜杠\\` 反引号\\* 星号\\_ 下划线\\&#123;\\&#125; 大括号\\[\\] 中括号\\(\\) 小括号\\# 井号\\+ 加号\\- 减号\\. 英文句号\\! 感叹号半方大的空白&amp;ensp;或&amp;#8194;看，飞碟全方大的空白&amp;emsp;或&amp;#8195;看，飞碟不断行的空白格&amp;nbsp;或&amp;#160;看，飞碟&amp;emsp;&amp;emsp;段落从此开始。 \\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号 半方大的空白&ensp;或&#8194;看，飞碟全方大的空白&emsp;或&#8195;看，飞碟不断行的空白格&nbsp;或&#160;看，飞碟&emsp;&emsp;段落从此开始。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.z16388.top/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://www.z16388.top/tags/markdown/"}],"keywords":[]},{"title":"博客第一天","slug":"博客第一天","date":"2016-09-09T09:21:52.000Z","updated":"2017-04-13T13:25:15.937Z","comments":true,"path":"2016/09/09/博客第一天/","link":"","permalink":"http://www.z16388.top/2016/09/09/博客第一天/","excerpt":"","text":"博客第一天hexo试用心情 &emsp;&emsp;今天折腾了一天，终于算是做了一个还算满意的网站。 &emsp;&emsp;从昨天开始，安装hexo，各种配置，到今天选择主题，各种改，最后成了这个样子。一天过去，没玩游戏，感到非常地充实——好久没有体会过学习的快感了。 &emsp;&emsp;明天就要开始ACM网络赛了，加油！","categories":[],"tags":[{"name":"心情","slug":"心情","permalink":"http://www.z16388.top/tags/心情/"}],"keywords":[]}]}